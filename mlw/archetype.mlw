theory Types

  use int.Int

  (* default type mapping *)
  type arstring  = string

  type key       = arstring
  type key_hash  = int
  type role      = arstring
  type address   = arstring
  type tez       = int
  type date      = int
  type duration  = int
  type bytes     = arstring
  type signature = arstring
  type chain_id  = int
  type nat       = int


  exception Break
  exception NotFound
  exception KeyExist
  exception NegAssignNat
  exception InvalidCaller
  exception InvalidCondition
  exception NoTransfer
  exception InvalidState
  exception Invalid string
end

module Utils
  use int.Int
  use Types
  use option.Option

  (* ------------------------------------------------------------------------ *)
  (* Tuples *)

  let function fst (a : ('t1, 't2)) : 't1
  =
  match a with
  | (l,_) -> l
  end

  let function snd (a: ('t1, 't2)) : 't2
  =
  match a with
  | (_,r) -> r
  end

  let function snd_opt (a: option ('t1, 't2)) : option 't2
  =
  match a with
  | Some (_,r) -> Some r
  | None -> None
  end

  let function nth1_of_2 (a: ('t1,'t2))     : 't1 = match a with | (v,_) -> v end
  let function nth1_of_3 (a: ('t1,'t2,'t3)) : 't1 = match a with | (v,_,_) -> v end
  let function nth1_of_4 (a: ('t1,'t2,'t3,'t4)) : 't1 = match a with | (v,_,_,_) -> v end
  let function nth1_of_5 (a: ('t1,'t2,'t3,'t4,'t5)) : 't1 = match a with | (v,_,_,_,_) -> v end

  let function nth2_of_2 (a: ('t1,'t2))     : 't2 = match a with | (_,v) -> v end
  let function nth2_of_3 (a: ('t1,'t2,'t3)) : 't2 = match a with | (_,v,_) -> v end
  let function nth2_of_4 (a: ('t1,'t2,'t3,'t4)) : 't2 = match a with | (_,v,_,_) -> v end
  let function nth2_of_5 (a: ('t1,'t2,'t3,'t4,'t5)) : 't2 = match a with | (_,v,_,_,_) -> v end

  let function nth3_of_3 (a: ('t1,'t2,'t3)) : 't3 = match a with | (_,_,v) -> v end
  let function nth3_of_4 (a: ('t1,'t2,'t3,'t4)) : 't3 = match a with | (_,_,v,_) -> v end
  let function nth3_of_5 (a: ('t1,'t2,'t3,'t4,'t5)) : 't3 = match a with | (_,_,v,_,_) -> v end

  let function nth4_of_4 (a: ('t1,'t2,'t3,'t4)) : 't4 = match a with | (_,_,_,v) -> v end
  let function nth4_of_5 (a: ('t1,'t2,'t3,'t4,'t5)) : 't4 = match a with | (_,_,_,v,_) -> v end

  let function nth5_of_5 (a: ('t1,'t2,'t3,'t4,'t5)) : 't5 = match a with | (_,_,_,_,v) -> v end

  (* ------------------------------------------------------------------------ *)
  (* Math *)

  let function abs (a : int) : int
  ensures { a >= 0 -> result = a }
  ensures { a <= 0 -> result = -a }
  =
  if a >= 0 then a else -a

  use int.EuclideanDivision

  let function floor (a : (int,int)) : int
  requires { not (snd a) = 0 }
  =
  match a with
  | (n,d) ->
   if d > 0 then
     div n d
   else
     (div n d) - 1
  end

  let function ceil (a : (int,int)) : int
  requires { not (snd a) = 0 }
  =
  match a with
  | (n,d) ->
   if d > 0 then
     (div n d) + 1
   else
     div n d
  end

  val function xor_int int int : int

  (* ------------------------------------------------------------------------ *)
  (* Rational *)

  type op_cmp =
   | OpCmpLt
   | OpCmpLe
   | OpCmpGt
   | OpCmpGe

  let function rat_cmp (op : op_cmp) (lhs : (int, int)) (rhs : (int, int)) : bool
  =  let a = (fst lhs) * (snd rhs) in
     let b = (snd lhs) * (fst rhs) in
     let pos = (fst lhs) * (fst rhs) > 0 in
     match op with
     | OpCmpLt -> if pos then
                    a < b
                  else
                    a > b
     |OpCmpLe -> if pos then
                   a <= b
                 else
                   a >= b
     |OpCmpGt -> if pos then
                   a > b
                 else
                   a < b
     |OpCmpGe -> if pos then
                   a >= b
                 else
                   a <= b
     end

  let function rat_eq (lhs : (int, int)) (rhs : (int, int)) : bool
  = fst lhs * snd rhs = fst rhs * snd lhs

  type op_arith =
   | OpArithPlus
   | OpArithMinus
   | OpArithMult
   | OpArithDiv

  let function rat_arith (op : op_arith) (lhs : (int, int)) (rhs : (int, int)) : (int, int)
  =  match op with
     | OpArithPlus -> (((fst lhs) * (snd rhs)) + ((snd rhs) * (snd lhs)) , (snd lhs) * (snd rhs))
     | OpArithMinus -> (((fst lhs) * (snd rhs)) - ((snd rhs) * (snd lhs)) , (snd lhs) * (snd rhs))
     | OpArithMult -> ((fst lhs) * (fst rhs) , (snd lhs) * (snd rhs))
     | OpArithDiv -> ((fst lhs) * (snd rhs) , (snd lhs) * (fst rhs))
     end

  let function rat_tez (c : (int, int)) (t : tez) : tez
  requires { not (snd c) = 0 }
  =  div ((abs (fst c)) * t) (abs (snd c))

  let function abs_rat (a : (int, int)) : (int, int)
  =
  match a with
  | (l,r) -> (abs l, abs r)
  end

  let function int_to_rat (a : int) : (int, int)
  = (a,1)

  let function rat_uminus (r : (int, int)) : (int, int)
  =
  match r with
  | (l,r) -> (-l,r)
  end

  let function rat_min (a : (int, int)) (b : (int, int)) : (int, int)
  = if rat_cmp OpCmpLe a b then a else b

  let function rat_max (a : (int, int)) (b : (int, int)) : (int, int)
  = if rat_cmp OpCmpLe a b then b else a

  let function rat_dur (a : (int, int)) (b : int) : int
  requires { not (snd a) = 0 }
  = div ((fst a) * b) (snd a)

  (* ----------------------------------------------------------------------- *)
  (* String *)

  use string.String as S

  val function str_concat arstring arstring : arstring

  (* axiom str_concat_spec : forall s1 s2.
  str_concat s1 s2 = S.concat s1 s2 *)

  val function substring arstring int int : arstring

  (* axiom substring_spec : forall s i j.
  substring s i j = S.substring s i j *)

  val function str_length arstring : int

  axiom str_length_spec : forall s.
  str_length s = S.length s

  val function str_eq (_ : arstring) (_ : arstring) : bool

  (* axiom str_eq_spec : forall s1 s2.
  str_eq s1 s1 <-> s1 = s2 *)

  (* let function str_le (s1 : arstring) (s2 : arstring) : bool = s1 <= s2
  let function str_ge (s1 : arstring) (s2 : arstring) : bool = s1 >= s2
  let function str_lt (s1 : arstring) (s2 : arstring) : bool = s1 < s2
  let function str_gt (s1 : arstring) (s2 : arstring) : bool = s1 > s2 *)

  val function str_le arstring arstring : bool

  (* axiom str_le_spec : forall s1 s2.
  str_le s1 s2 = S.le s1 s2 *)

  val function str_ge arstring arstring : bool

  (* axiom str_ge_spec : forall s1 s2.
  str_ge s1 s2 = not (S.le s1 s2) \/ s1 = s2 *)

  val function str_lt arstring arstring : bool

  axiom str_lt_spec : forall s1 s2.
  str_lt s1 s2 = S.lt s1 s2

  val function str_gt arstring arstring : bool

  (* axiom str_gt_spec : forall s1 s2.
  str_gt s1 s2 = not (S.le s1 s2) *)

  val function from_int int : arstring

(*  axiom from_int_spec : forall i.
  from_int i = S.from_int i
*)
  (* ----------------------------------------------------------------------- *)
  (* Option *)

  let function issome (v : option 'a) : bool
  =
  match v with
  | Some _ -> true
  | None -> false
  end

  let function isnone (v : option 'a) : bool
  =
  match v with
  | Some _ -> false
  | None -> true
  end

  let getopt (o : option 'a) : 'a
  raises { NotFound }
  =
  match o with
  | Some v -> v
  | None -> raise NotFound
  end

  (* ----------------------------------------------------------------------- *)
  (* crypto *)
  let function blake2b (b : bytes) : bytes = b
  let function sha256 (b : bytes) : bytes = b
  let function sha512 (b : bytes) : bytes = b
  let function hash_key (_k : key) : key_hash = 0
  let check_signature (_k : key) (_s : signature) (_b : bytes) = true

  (* ----------------------------------------------------------------------- *)
  (* serialization *)
  val function pack (_x : 'a) : bytes
  val function unpack bytes : option 'a

  (* ----------------------------------------------------------------------- *)
  (* bool *)
  let function neq_bool (a : bool) (b : bool) : bool = not (a && b)
  let function xor_bool (a : bool) (b : bool) : bool = (a || b) && not (a && b)

  (* ------------------------------------------------------------------------ *)
  axiom inv_pack_unpack: forall x : bytes. exists a : int. unpack(x) = Some(a) -> pack(a) = x

end

module Trace

  use Types
  use list.List
  use list.Mem
  use option.Option

  type _asset
  type _entry
  type _field

  type _action =
  | TrRm_ _asset
  | TrAdd_ _asset
  | TrUpdate_ _field
  | TrGet_ _asset
  | TrIterate _asset
  | TrTransfer int
  | TrCallContract int

  type _traces = list _action

  predicate changes_performed_by (changes : _traces) (tr : _traces) (p : bool) =
  forall x : _action.
  mem x tr ->
  mem x changes ->
  p

  predicate performed_by  (tr : _traces) (p : bool) =
  forall x : _action.
  mem x tr ->
  p

end

theory Operation

  use Types
  use int.Int
  use list.List
  use option.Option
  use Utils

  type call = {
    _name : arstring;
    _args : list arstring;
  }

  let _eq_call (c1 : call) (c2 : call) : bool
  =  str_eq c1._name c2._name (* TODO : complete *)

  type operation = {
     _destination_ : address;
     _amount_      : tez;
     _call_        : option call;
  }

  let function _eq_operation (o1 : operation) (o2 : operation)
  = str_eq o1._destination_ o2._destination_ &&
    o1._amount_ = o2._amount_ &&
    match o1._call_, o2._call_ with
    | Some c1, Some c2 -> _eq_call c1 c2
    | _ -> false
    end


  let _mk_transfer (d : address) (a : tez) : operation = {
    _destination_ = d;
    _amount_ = a;
    _call_   = None;
  }

  let _mk_call (d : address) (a : tez) (n : arstring) (l : list arstring) : operation = {
    _destination_ = d;
    _amount_ = a;
    _call_ = Some { _name = n; _args = l };
  }

  type contract = {
    _entry_name : arstring;
    _entry_dest : address;
  }

  let function entrypoint (n : arstring) (d : address) : option contract = Some {
    _entry_name = n;
    _entry_dest = d;
  }

  let _mk_operation (a : tez) (e : contract) (l : list arstring) : operation = {
    _destination_ = e._entry_dest;
    _amount_ = a;
    _call_ = Some { _name = e._entry_name; _args = l };
  }

end

(* source : http://toccata.lri.fr/gallery/insertion_sort_list.fr.html *)
module InsertionSort

  type elt
  val predicate le elt elt

  clone relations.TotalPreOrder with
    type t = elt, predicate rel = le, axiom .
  clone export list.Sorted with
    type t = elt, predicate le  = le, goal Transitive.Trans

  use list.List
  use list.Permut

  let rec function insert (x: elt) (l: list elt) : list elt
    requires { sorted l }
    ensures  { sorted result }
    ensures  { permut (Cons x l) result }
    variant  { l }
  = match l with
    | Nil -> Cons x Nil
    | Cons y r -> if le x y then Cons x l else Cons y (insert x r)
    end

  let rec function insertion_sort (l: list elt) : list elt
    ensures { sorted result }
    ensures { permut l result }
    variant { l }
  = match l with
    | Nil -> Nil
    | Cons x r -> insert x (insertion_sort r)
    end

end

module Undup

  use list.List
  use list.Mem as M
  use list.Length as L
  use fset.Undup as U

  (* ------------------------------------------------------------------------ *)
  type t

  (* ------------------------------------------------------------------------ *)
  val function eqt t t : bool

  (* ------------------------------------------------------------------------ *)
  axiom eqP : forall x y. eqt x y <-> x = y

  (* ------------------------------------------------------------------------ *)
  let rec function mem (a : t) (l : list t) : bool
  variant { l }
  ensures { result <-> M.mem a l }
  =
    match l with
    | Nil -> false
    | Cons e tl -> eqt a e || mem a tl
    end

  (* ------------------------------------------------------------------------ *)
  let rec function undup (l : list t) : list t
  variant { l }
  ensures { result = U.undup l }
  =
    match l with
    | Nil -> Nil
    | Cons e tl ->
        if mem e tl then undup tl else Cons e (undup tl)
    end

  (* ------------------------------------------------------------------------ *)
  predicate unduped (l : list t) = undup l = l

end

module ListUtils
  use int.Int
  use list.List
  use list.Mem
  use list.Nth
  use list.Length
  use list.Reverse
  use option.Option

  (* ------------------------------------------------------------------------ *)
  let rec nth (i : int) (l : list 't) : option 't
  variant { l }
  ensures { forall k. result = Some k -> mem k l }
  ensures { not (0 <= i < length l) -> result = None }
  ensures { result = nth i l }
  =
  match l with
  | Cons k tl -> if i = 0 then Some k else nth (i - 1) tl
  | Nil -> None
  end

  (* ------------------------------------------------------------------------ *)
  lemma nth_con : forall k : int. nth 0 (Cons k Nil) = Some k

  (* ------------------------------------------------------------------------ *)
  let rec function head (n : int) (l : list 't) : list 't
  variant { l }
  ensures { forall k. mem k result -> mem k l }
  ensures { 0 <= n <= length l -> length result = n }
  ensures { n > length l -> result = l }
  ensures { n < 0 -> result = Nil }
  =
  match l with
  | Cons e tl ->
    if 0 < n then
      Cons e (head (n-1) tl)
    else Nil
  | Nil -> Nil
  end

  (* ------------------------------------------------------------------------ *)
  let rec function tail (i : int) (l : list 't) : list 't
  variant { l }
  ensures { forall k. mem k result -> mem k l }
  ensures { 0 <= i <= length l -> length result = length l - i }
  = reverse (head (length l - i) (reverse l))

  (* ------------------------------------------------------------------------ *)
  predicate subset (l1 : list 't) (l2 : list 't) =
  forall e. mem e l1 -> mem e l2

end

(* Collection Set is a fset with get, add and remove ------------------------ *)
module CollectionSet
  use int.Int
  use list.List
  use list.Mem as M
  use option.Option
  use ListUtils as I

  (* ------------------------------------------------------------------------ *)
  type t (* asset *)

  (* ------------------------------------------------------------------------ *)
  type tk (* key *)

  (* ------------------------------------------------------------------------ *)
  val function proj t : tk

  (* ------------------------------------------------------------------------ *)
  val function eqt t t : bool

  (* ------------------------------------------------------------------------ *)
  val function eqk tk tk : bool

  (* ------------------------------------------------------------------------ *)
  axiom eqP : forall x y. eqt x y <-> x = y

  (* ------------------------------------------------------------------------ *)
  axiom eqkP : forall x y. eqk x y <-> x = y

  (* ------------------------------------------------------------------------ *)
  val function norm (list t) : list t

  (* ------------------------------------------------------------------------ *)
  clone fset.FSet as F  with  type t     = t,
                              val  eqt   = eqt,
                              val  norm  = norm,
                              axiom .
  (* ------------------------------------------------------------------------ *)
  type cset = F.fset

  (* ------------------------------------------------------------------------ *)
  predicate mem (e : t) (s : cset) = F.fmem e s

  (* ------------------------------------------------------------------------ *)
  let function elts (s : cset) = F.content s

  (* ------------------------------------------------------------------------ *)
  let function mk (l : list t) = F.mk l

  (* ------------------------------------------------------------------------ *)
  let function card (s : cset) = F.fcard s

  (* GET INTERNAL ----------------------------------------------------------- *)
  let rec function internal_get (k : tk) (l : list t) : option t
  variant { l }
  ensures { forall e. result = Some e -> proj e = k }
  ensures { result = None -> forall e. M.mem e l -> proj e <> k }
  =
  match l with
  | Cons e tl ->
    if eqk (proj e) k
    then Some e
    else internal_get k tl
  | Nil -> None
  end

  (* GET -------------------------------------------------------------------- *)
  let function get (k : tk) (s : cset) : option t
  ensures { result = None -> forall e. F.fmem e s -> proj e <> k }
  ensures { forall e. result = Some e -> proj e = k }
  = internal_get k (F.content s)

  (* ADD -------------------------------------------------------------------- *)
  let function add (a : t) (s : cset) : cset
  ensures { forall k. k <> proj a -> get k result = get k s }
  ensures { get (proj a) result = Some a }
  = F.mk (Cons a (F.content s))  (* normalisation is done by F.mk *)

  (* REMOVE ----------------------------------------------------------------- *)
  let function remove (k : tk) (s : cset) : cset
  ensures { forall e. e <> k -> get e result = get e s }
  ensures { get k result = None }
  =
  let rec internal_remove (l : list t) : list t
  variant { l }
  ensures { forall e. e <> k -> internal_get e result = internal_get e l }
  ensures { internal_get k result = None }
  = match l with
  | Cons e tl ->
    if eqk (proj e) k then tl
    else Cons e (internal_remove tl)
  | Nil -> Nil
  end in
  F.mk (internal_remove (F.content s))

  (* HEAD ------------------------------------------------------------------- *)
  let function head (i : int) (s : cset) : cset
  ensures { forall e. mem e result -> mem e s }
  ensures { 0 <= i <= card s -> card result = i }
  ensures { i > card s -> result = s }
  = F.mk (I.head i (F.content s))

  (* TAIL ------------------------------------------------------------------- *)
  let function tail (i : int) (s : cset) : cset
  ensures { forall e. mem e result -> mem e s }
  ensures { 0 <= i <= card s -> card result = card s - i }
  = F.mk (I.tail i (F.content s))

  (* NTH -------------------------------------------------------------------- *)
  let function nth (i : int) (s : cset) : option t
  ensures { forall k. result = Some k -> mem k s }
  ensures { not (0 <= i < card s) -> result = None }
  (* ensures { result = nth i s } *)
  = I.nth i (F.content s)

  (* ------------------------------------------------------------------------ *)
  function union (s1 s2 : cset) : cset = F.fsetU s1 s2

  (* ------------------------------------------------------------------------ *)
  function inter (s1 s2 : cset) : cset = F.fsetI s1 s2

  (* ------------------------------------------------------------------------ *)
  function diff (s1 s2 : cset) : cset = F.fsetD s1 s2

  (* ------------------------------------------------------------------------ *)
  function singleton (a : t) : cset = F.mk (Cons a Nil)

  (* ------------------------------------------------------------------------ *)
  let function empty = F.fset0

  (* ------------------------------------------------------------------------ *)
  predicate is_empty (s : cset) = F.content s = Nil

  (* ------------------------------------------------------------------------ *)
  predicate subset (s1 s2 : cset) = F.fsubset s1 s2

  (* ------------------------------------------------------------------------ *)
  predicate (==) (s1 s2 : cset) = F.(==) s1 s2

end

(* VIEW is a unduped fset of key -------------------------------------------- *)
module View
  use int.Int
  use list.List
  use list.Mem as M
  use list.Length as L
  use list.Distinct
  use option.Option
  use Types
  use ListUtils as I

  (* ------------------------------------------------------------------------ *)
  type tk

  (* ------------------------------------------------------------------------ *)
  val function eqk tk tk : bool

  (* ------------------------------------------------------------------------ *)
  lemma eqP : forall k1 k2: tk. eqk k1 k2 <-> k1 = k2

  (* ------------------------------------------------------------------------ *)
  clone Undup as U with type t = tk,
                        val eqt = eqk

  (* ------------------------------------------------------------------------ *)
  predicate unduped (l : list tk) = l = U.undup l

  (* ------------------------------------------------------------------------ *)
  type view = {
    content : list tk
  } invariant {
    unduped content
  } by { content = Nil }

  (* ------------------------------------------------------------------------ *)
  let function elts (v : view)
  ensures { unduped result }
  = content v

  (* ------------------------------------------------------------------------ *)
  let function contains (k : tk) (v:view) : bool
  ensures { result <-> M.mem k (elts v) }
  = U.mem k (elts v)

  (* ------------------------------------------------------------------------ *)
  let function card (v : view) : int
  ensures { result = L.length (elts v) }
  =
  L.length (elts v)

  (* ------------------------------------------------------------------------ *)
  lemma undupI : forall l. U.unduped (U.undup l)

  (* ------------------------------------------------------------------------ *)
  let function mk (l: list tk)
  = { content = U.undup l }

  (* ------------------------------------------------------------------------ *)
  let function empty = mk Nil

  (* ------------------------------------------------------------------------ *)
  predicate is_empty (v : view) = v = empty

  (* ------------------------------------------------------------------------ *)
  let function nth (i : int) (v : view) : option tk
  ensures { 0 <= i < card v -> forall k. result = Some k -> contains k v }
  ensures { not (0 <= i < card v) -> result = None }
  = I.nth i (elts v)

  (* ------------------------------------------------------------------------ *)
  lemma nth_singleton: forall k. nth 0 (mk (Cons k Nil)) = Some k

  (* ------------------------------------------------------------------------ *)
  lemma undup_head : forall k l. U.unduped l -> U.unduped (I.head k l)

  (* ------------------------------------------------------------------------ *)
  lemma eqview : forall v1 v2. content v1 = content v2 -> v1 = v2

  (* KEEP first i elements -------------------------------------------------- *)
  let function head (i : int) (v : view) : view
  ensures { forall k. contains k result -> contains k v }
  ensures { 0 <= i <= card v -> card result = i }
  ensures { i > card v -> result = v }
  = mk (I.head i (elts v))

  (* ------------------------------------------------------------------------ *)
  lemma keep_none: forall v. head 0 v = mk Nil

  (* ------------------------------------------------------------------------ *)
  lemma undup_tail : forall k l. U.unduped l -> U.unduped (I.tail k l)

  (* ------------------------------------------------------------------------ *)
  (* keeps last i elements *)
  let function tail (i : int) (v : view) : view
  ensures { forall k. contains k result -> contains k v }
  ensures { 0 <= i <= card v -> card result = card v - i }
  = mk (I.tail i (elts v))

  (* ------------------------------------------------------------------------ *)
  lemma tail0: forall v. tail 0 v = v

  (* ------------------------------------------------------------------------ *)
  lemma tail_empty: forall i v. i >= card v -> tail i v = empty

  (* ------------------------------------------------------------------------ *)
  lemma tail_not_contains_succ: forall i k v.
  nth i v = Some k ->
  not (contains k (tail (i+1) v))

  (* ------------------------------------------------------------------------ *)
  let function eq (v1 v2 : view) : bool
  =
  let rec function eql l1 l2 : bool
  variant { l1, l2 }
  ensures { result <-> l1 = l2 }
  =
  match l1, l2 with
  | Cons e1 tl1, Cons e2 tl2 ->
    if eqk e1 e2 then eql tl1 tl2 else false
  | Nil, Nil -> true
  | _ -> false
  end in
  eql v1.content v2.content

  (* ------------------------------------------------------------------------ *)
  lemma eqvP : forall v1 v2. eq v1 v2 <-> v1 = v2

  (* ------------------------------------------------------------------------ *)
  predicate subset (v1 : view) (v2 : view) = I.subset v1.content v2.content

  (* ------------------------------------------------------------------------ *)
  axiom empty_subset : forall v. subset empty v

end

(* FIELD is a sorted and unduped fset of key -------------------------------- *)
module Field
  use int.Int
  use list.List
  use list.Mem as M
  use option.Option
  use Types
  use View as V

  (* ------------------------------------------------------------------------ *)
  type tk

  (* ------------------------------------------------------------------------ *)
  val function eqk tk tk : bool

  (* ------------------------------------------------------------------------ *)
  axiom eqP : forall k1 k2. eqk k1 k2 <-> k1 = k2

  (* ------------------------------------------------------------------------ *)
  val function lek tk tk : bool

  (* ------------------------------------------------------------------------ *)
  let function proj (x : tk) = x

  (* ------------------------------------------------------------------------ *)
  let predicate le k1 k2 = lek k1 k2

  (* ------------------------------------------------------------------------ *)
  clone InsertionSort as S with type elt = tk,
                                val le = le

  (* ------------------------------------------------------------------------ *)
  clone Undup as U with type t = tk,
                        val eqt = eqk

  (* ------------------------------------------------------------------------ *)
  let function norm (l : list tk) = S.insertion_sort (U.undup l)

  (* ------------------------------------------------------------------------ *)
  clone CollectionSet as N with type t     = tk,
                                type tk    = tk,
                                val proj   = proj,
                                val  eqt   = eqk,
                                val  norm  = norm,
                                axiom .

  (* ------------------------------------------------------------------------ *)
  type field = N.cset

  (* ------------------------------------------------------------------------ *)
  let function mk (l : list tk) = N.mk l

  (* ------------------------------------------------------------------------ *)
  predicate mem (k : tk) (f : field) = N.mem k f

  (* ------------------------------------------------------------------------ *)
 let function contains (k : tk) (f : field) : bool
  ensures { result = true -> exists e. mem e f /\ e = k }
  ensures { result = false -> N.get k f = None }
  (* TODO is this valid ? result <-> mem e f *)
  =
  match N.get k f with
  | Some _ -> true
  | None -> false
  end

  (* ------------------------------------------------------------------------ *)
  let function elts (f : field) = N.elts f

  (* ------------------------------------------------------------------------ *)
  let function empty = N.empty

  (* ------------------------------------------------------------------------ *)
  predicate is_empty (f : field) = N.is_empty f

  (* ------------------------------------------------------------------------ *)
  let function eq (f1 f2 : field) : bool
  =
  let rec internal_eq (l1 l2 : list tk) : bool
  variant { l1, l2 }
  = match l1,l2 with
  | Cons k1 tl1, Cons k2 tl2 ->
    if eqk k1 k2 then
      internal_eq tl1 tl2
    else false
  | Nil,Nil -> true
  | _ -> false
  end in
  internal_eq (N.elts f1) (N.elts f2)

  (* ------------------------------------------------------------------------ *)
  lemma eqfP : forall f1 f2. eq f1 f2 <-> f1 = f2

  (* ------------------------------------------------------------------------ *)
  let function add (k : tk) (f : field)
  (* TODO add precondition ? get k f = None *)
  ensures { forall i. i <> k -> N.get i result = N.get i f }
  ensures { N.get k result = Some k }
  = N.add k f

  (* ------------------------------------------------------------------------ *)
  let function remove (k : tk) (f : field)
  ensures { forall i. i  <> k -> N.get i result = N.get i f }
  ensures { N.get k result = None }
  = N.remove k f

  (* ------------------------------------------------------------------------ *)
  type view

  (* ------------------------------------------------------------------------ *)
  val function vmk (list tk) : view

  (* ------------------------------------------------------------------------ *)
  val function velts view : list tk

  (* ------------------------------------------------------------------------ *)
  val function vcontains tk view : bool

  (* ------------------------------------------------------------------------ *)
  let function to_view (f : field) : view
  (* TODO shall there be a dedicated sort predicate ?*)
  ensures { S.sorted (velts result) }
  ensures { forall k. vcontains k result <-> contains k f }
  = vmk (N.elts f)

end

module Aggregate
  use list.List
  use list.Append
  use option.Option
  use Types

  (* ------------------------------------------------------------------------ *)
  type t

  (* ------------------------------------------------------------------------ *)
  type tk

  (* ------------------------------------------------------------------------ *)
  type collection

  (* ------------------------------------------------------------------------ *)
  val function elts collection : list t

  (* ------------------------------------------------------------------------ *)
  val function get tk collection : option t

  (* ------------------------------------------------------------------------ *)
  val function set tk t collection : collection

  (* ------------------------------------------------------------------------ *)
  type field

  (* ------------------------------------------------------------------------ *)
  val function setF field t : t

  (* ------------------------------------------------------------------------ *)
  val function aggregate t : field

  (* ------------------------------------------------------------------------ *)
  type tkF

  (* ------------------------------------------------------------------------ *)
  val function containsF tkF field : bool

  (* ------------------------------------------------------------------------ *)
  val function mkF (list tkF) : field

  (* ------------------------------------------------------------------------ *)
  val function eltsF field : list tkF

  (* ------------------------------------------------------------------------ *)
  val function addF tkF field : field

  (* ------------------------------------------------------------------------ *)
  val function removeF tkF field : field

  (* ------------------------------------------------------------------------ *)
  val function emptyF : field

  (* ------------------------------------------------------------------------ *)
  type tO

  (* ------------------------------------------------------------------------ *)
  type collectionO

  (* ------------------------------------------------------------------------ *)
  val function getO tkF collectionO : option tO

  (* ------------------------------------------------------------------------ *)
  let function add (ka : tk) (kb : tkF) (c : collection) : collection
  (* TODO preconditions ? *)
  ensures { forall k. k <> ka -> get k result = get k c }
  ensures { forall ta oldta.
    get ka result = Some ta ->
    get ka c = Some oldta ->
    (* TODO add this premise ? not (containsF kb (aggregate oldta)) -> *)
    ta = setF (addF kb (aggregate oldta)) oldta
  }
  ensures { forall ta oldta.
    get ka result = Some ta ->
    get ka c = Some oldta ->
    containsF kb (aggregate oldta) ->
    ta = oldta
  }
  =
  match get ka c with
  | Some a ->
    let f = addF kb (aggregate a) in
    set ka (setF f a) c
  | None -> c
  end

  (* ------------------------------------------------------------------------ *)
  let function remove (ka : tk) (kb : tkF) (c : collection) : collection
  ensures { forall k. k <> ka -> get k result = get k c }
  ensures { forall ta oldta.
    get ka result = Some ta ->
    get ka c = Some oldta ->
    containsF kb (aggregate oldta) ->
    ta = setF (removeF kb (aggregate oldta)) oldta
  }
  ensures { forall ta oldta.
    get ka result = Some ta ->
    get ka c = Some oldta ->
    not (containsF kb (aggregate oldta)) ->
    ta = oldta
  }
  =
  match get ka c with
  | Some a ->
    let f = removeF kb (aggregate a) in
    set ka (setF f a) c
  | None -> c
  end

  (* ------------------------------------------------------------------------ *)
  let function removeall (ka : tk) (c : collection) : collection
  ensures { forall k. k <> ka -> get k result = get k c }
  ensures { forall ta oldta.
    get ka result = Some ta ->
    get ka c = Some oldta ->
    ta = setF emptyF oldta
  }
  (* TODO shall we rather express setF postconditions ?
     no because we can't express them on abstract type t *)
  =
  match get ka c with
  | Some a -> set ka (setF emptyF a) c
  | None -> c
  end

  (* ------------------------------------------------------------------------ *)
  let function removeif (ka : tk) (p : tO -> bool)
    (cO : collectionO) (c : collection) : collection
  ensures { forall k. k <> ka -> get k result = get k c }
  ensures { forall ta oldta.
    get ka result = Some ta ->
    get ka c = Some oldta ->
    forall i o.
      getO i cO = Some o ->
      p o ->
      containsF i (aggregate oldta) ->
      not (containsF i (aggregate ta))
  }
  ensures { forall ta oldta.
    get ka result = Some ta ->
    get ka c = Some oldta ->
    forall i o.
      getO i cO = Some o ->
      not (p o) ->
      containsF i (aggregate oldta) <->
      containsF i (aggregate ta)
  }
  =
  let rec internal_removeif (l : list tkF)
  variant { l }
  =
  match l with
  | Cons k tl ->
    match getO k cO with
    | Some e ->
      if p e then (Cons k (internal_removeif tl))
      else internal_removeif tl
    | None -> internal_removeif tl
    end
  | Nil -> Nil
  end in
  match get ka c with
  | Some a ->
    let f = mkF (internal_removeif (eltsF (aggregate a))) in
    set ka (setF f a) c
  | None -> c
  end

  (* ------------------------------------------------------------------------ *)
  let function union_with_pred (p : t -> bool) (c : collection) : field
  ensures {
    forall k.
    containsF k result ->
    exists i a. get i c = Some a /\ p a /\ containsF k (aggregate a)
  }
  ensures {
    forall k i a.
    get i c = Some a ->
    containsF k (aggregate a) ->
    containsF k result
  }
  =
  let rec internal_union (l : list t) : list tkF =
  variant { l }
  match l with
  | Nil -> Nil
  | Cons e tl ->
    if p e then
      let f = aggregate e in
      (eltsF f) ++ (internal_union tl)
    else
      internal_union tl
  end in
  mkF (internal_union (elts c))

  (* ------------------------------------------------------------------------ *)
  let function union (c : collection) : field
  ensures { forall k.
    containsF k result ->
    exists i a. get i c = Some a /\ containsF k (aggregate a)
  }
  ensures { forall i a k.
    get i c = Some a ->
    containsF k (aggregate a) ->
    containsF k result
  }
  =
  union_with_pred (fun _ -> true) c

end

(* COLLECTION is an unduped fset of asset
   plus an invariant on key injectivity ------------------------------------- *)
module Collection
  use Types
  use int.Int
  use list.List
  use list.Mem as M
  use option.Option
  use View as V
  use fset.ListFilter as F
  (* ------------------------------------------------------------------------ *)
  type tk

  (* ------------------------------------------------------------------------ *)
  val function eqk tk tk : bool

  (* ------------------------------------------------------------------------ *)
  axiom eqkP : forall k1 k2. eqk k1 k2 <-> k1 = k2

  (* ------------------------------------------------------------------------ *)
  val function lek tk tk : bool

  (* ------------------------------------------------------------------------ *)
  type t

  (* ------------------------------------------------------------------------ *)
  val function keyt t : tk

  (* ------------------------------------------------------------------------ *)
  val function eqt t t : bool

  (* ------------------------------------------------------------------------ *)
  axiom eqtP : forall t1 t2. eqt t1 t2 <-> t1 = t2

  (* ------------------------------------------------------------------------ *)
  let predicate le t1 t2 = lek (keyt t1) (keyt t2)

  (* ------------------------------------------------------------------------ *)
  clone InsertionSort as S with type elt = t,
                                val le = le

  (* ------------------------------------------------------------------------ *)
  clone Undup as U with type t = t,
                        val eqt = eqt

  (* ------------------------------------------------------------------------ *)
  let function norm (l : list t) = S.insertion_sort (U.undup l)

  (* ------------------------------------------------------------------------ *)
  clone CollectionSet as N with type tk    = tk,
                                type t     = t,
                                val proj   = keyt,
                                val eqt    = eqt,
                                val eqk    = eqk,
                                val norm   = norm,
                                axiom .

  (* ------------------------------------------------------------------------ *)
  predicate key_injective (l : list t) = forall a1 a2.
    M.mem a1 l -> M.mem a2 l -> keyt a1 = keyt a2 -> eqt a1 a2

  (* ------------------------------------------------------------------------ *)
  type collection = {
    content : N.cset
  } invariant {
    key_injective (N.elts content)
  } by {
    content = N.empty;
  }

  (* ------------------------------------------------------------------------ *)
  predicate mem (a : t) (c : collection) = N.mem a c.content

  (* ------------------------------------------------------------------------ *)
  let function mk (s : N.cset) : collection
  requires { key_injective (N.elts s) }
  (* TODO postconditions *)
  = { content = s }

  (* ------------------------------------------------------------------------ *)
  function union (c1 c2 : collection) : collection
  = mk (N.union c1.content c2.content)

  (* ------------------------------------------------------------------------ *)
  function inter (c1 c2 : collection) : collection
  = mk (N.inter c1.content c2.content)

  (* ------------------------------------------------------------------------ *)
  function diff (c1 c2 : collection) : collection
  = mk (N.diff c1.content c2.content)

  (* ------------------------------------------------------------------------ *)
  function singleton (a : t) : collection = mk (N.singleton a)

   (* ------------------------------------------------------------------------ *)
  let function empty = mk N.empty

  (* ------------------------------------------------------------------------ *)
  predicate is_empty (c : collection) = N.is_empty c.content

  (* ------------------------------------------------------------------------ *)
  predicate subset (c1 c2 : collection) = N.subset c1.content c2.content

  (* ------------------------------------------------------------------------ *)
  predicate (==) (c1 c2 : collection) = N.(==) c1.content c2.content

  (* ------------------------------------------------------------------------ *)
  let function card (c : collection) = N.card c.content

  (* ------------------------------------------------------------------------ *)
  let function elts (c : collection) : list t
  ensures { norm result = result }
  ensures { key_injective result }
  =  N.elts c.content

  (* ------------------------------------------------------------------------ *)
  let function get (k : tk) (c : collection) : option t
  ensures { result = None -> forall e. mem e c -> keyt e <> k }
  ensures { forall e. result = Some e -> keyt e = k }
  ensures { forall e. result = Some e -> mem e c }
  = N.get k c.content

  (* ------------------------------------------------------------------------ *)
  axiom mem_get_key : forall a c. mem a c -> get (keyt a) c = Some a

  (* ------------------------------------------------------------------------ *)
  predicate eq (c1 c2 : collection) = forall k. get k c1 = get k c2

  (* ------------------------------------------------------------------------ *)
  let function from_list (l : list t) : collection
  requires { key_injective l }
  = { content = N.mk l }

  (* ------------------------------------------------------------------------ *)
  axiom get_from_cons_hd : forall k a l.
  key_injective (Cons a l) ->
  keyt a = k ->
  get k (from_list (Cons a l)) = Some a

  (* ------------------------------------------------------------------------ *)
  axiom get_from_cons_tl : forall k a l.
  key_injective (Cons a l) ->
  keyt a <> k ->
  get k (from_list (Cons a l)) = get k (from_list l)

  (* ------------------------------------------------------------------------ *)
  axiom get_from_nil : forall k.
  get k (from_list Nil) = None

  (* ------------------------------------------------------------------------ *)
  let function contains (k : tk) (c : collection) : bool
  ensures { result = true -> exists e. mem e c /\ keyt e = k }
  ensures { result = false -> get k c = None }
  =
  match get k c with
  | Some _ -> true
  | None -> false
  end

  (* ------------------------------------------------------------------------ *)
  lemma cont_mk [@rewrite] : forall l. N.elts (N.mk l) = norm l

  (* ------------------------------------------------------------------------ *)
  lemma intget_cons [@rewrite] : forall l [@induction].
    forall e k. keyt e <> k -> N.internal_get k (Cons e l) = N.internal_get k l

  (* ------------------------------------------------------------------------ *)
  lemma cons_key_injective : forall a l.
  key_injective l -> (forall e. M.mem e l -> keyt e <> keyt a) ->
  key_injective (Cons a l)

  (* ------------------------------------------------------------------------ *)
  let function add (a : t) (c : collection) : collection
  requires { not (contains (keyt a) c) }
  ensures { mem a result }
  ensures { forall r. mem r result <-> r = a \/ mem r c }
  ensures { forall k. k <> keyt a -> get k c = get k result }
  ensures { get (keyt a) result = Some a }
  ensures { card result = card c + 1 }
  = mk (N.add a c.content)

  (* ------------------------------------------------------------------------ *)
  let function remove (k : tk) (c : collection) : collection
  ensures { forall i. i <> k -> get i c = get i result }
  ensures { forall a. mem a result <-> mem a c /\ keyt a <> k }
  ensures { get k result = None }
  =
  mk (N.remove k c.content)

  (* ------------------------------------------------------------------------ *)
  axiom card_remove : forall k c.
  not (contains k c) ->
  card (remove k c) = card c - 1

  (* ------------------------------------------------------------------------ *)
  let function set (k : tk) (a : t) (c : collection) : collection
  requires { keyt a = k }
  requires { contains k c }
  ensures { get k result = Some a }
  ensures { forall i. i <> k -> get i result = get i c }
  ensures { forall x. mem x result -> x = a \/ (a <> x /\ mem x c) }
  ensures { card result = card c }
  =
  let rec internal_set (l : list t) : list t
  requires { key_injective l }
  variant { l }
  ensures { key_injective result }
  ensures { N.internal_get k result = Some a }
  ensures { forall i. i <> k -> N.internal_get i result = N.internal_get i l }
  =
  match l with
  | Cons e tl ->
    if eqk (keyt e) k
    then Cons a (internal_set tl)
    else Cons e (internal_set tl)
  | Nil -> Nil
  end in
  mk (N.mk (internal_set (N.elts c.content)))

  (* ------------------------------------------------------------------------ *)
  axiom remove_set: forall a k c.
  keyt a = k -> contains k c -> remove k (set k a c) = remove k c

  (* ------------------------------------------------------------------------ *)
  type view

  (* ------------------------------------------------------------------------ *)
  val function vmk (list tk) : view

  (* ------------------------------------------------------------------------ *)
  val function velts view : list tk

  (* ------------------------------------------------------------------------ *)
  val function vcontains tk view : bool

  (* ------------------------------------------------------------------------ *)
  val function vcard view : int

  (* ------------------------------------------------------------------------ *)
  let function list_to_view (l : list t) : view
  (* TODO postconditions *)
  =
  let rec function internal_list_to_view (il : list t) : list tk
  variant { l }
  ensures { forall k. M.mem k result <-> forall e. M.mem e l -> keyt e = k }
    =
  match il with
  | Cons e tl -> Cons (keyt e) (internal_list_to_view tl)
  | Nil -> Nil
  end in
  vmk (internal_list_to_view l)

  (* ----------------------------------------------------------------------- *)
  let function view_to_list (v : view) (c : collection) : list t
  (* TODO postconditions *)
  =
  let rec internal_view_to_list (l : list tk) : list t
  variant { l }
  =
  match l with
  | Cons k tl ->
    match get k c with
    | Some e -> Cons e (internal_view_to_list tl)
    | None -> internal_view_to_list tl
    end
  | Nil -> Nil
  end in
  internal_view_to_list (velts v)

  (* ----------------------------------------------------------------------- *)
  let function from_view (v : view) (c : collection) : collection
  ensures { forall e. mem e result -> mem e c }
  ensures { forall e. mem e result <-> vcontains (keyt e) v }
  = mk (N.mk (view_to_list v c))

  (* ----------------------------------------------------------------------- *)
  let predicate le_key k1 k2 = lek k1 k2

  (* ----------------------------------------------------------------------- *)
  clone InsertionSort as K with type elt = tk,
                                val le = le_key

  (* ----------------------------------------------------------------------- *)
  let rec function to_view (c : collection) : view
  ensures { forall k. vcontains k result -> exists e. get k c = Some e }
  ensures { forall e. mem e c -> vcontains (keyt e) result }
  ensures { K.sorted (velts result) }
  ensures { vcard result = card c }
  (* TODO dedicated sort predicate that does not use velts ? *)
  =
  list_to_view (N.elts c.content)

  (* ------------------------------------------------------------------------ *)
  lemma get_to_view_contains_false : forall k c.
  not (vcontains k (to_view c)) <-> get k c = None

  (* ------------------------------------------------------------------------ *)
  axiom empty_to_view : forall c. is_empty c -> to_view c = vmk Nil

  (* ------------------------------------------------------------------------ *)
  let function select_to_coll (p : t -> bool) (c : collection) : collection
  ensures { forall e. mem e result <-> p e /\ mem e c }
  =
  let rec internal_select (l : list t) : list t
  variant { l }
  =
  match l with
  | Nil       -> Nil
  | Cons e tl -> if p e then Cons e (internal_select tl) else (internal_select tl)
  end in
  mk (N.mk (internal_select ((N.elts (content c)))))

  (* ------------------------------------------------------------------------ *)
  let function select (p : t -> bool) (c : collection) : view
  ensures { forall e k. get k c = Some e -> p e -> vcontains k result }
  ensures { forall e. vcontains (keyt e) result -> p e }
  ensures { forall e k. get k c = Some e -> not (p e) -> not (vcontains k result) }
  =
  to_view (select_to_coll p c)

  (* ------------------------------------------------------------------------ *)
  let function select_view (p : t -> bool) (v : view) (c : collection) : view
  ensures { forall e k. vcontains k v -> get k c = Some e -> p e -> vcontains k result }
  ensures { forall e. vcontains (keyt e) result -> p e }
  ensures { forall e k. vcontains k v -> get k c = Some e -> not (p e) -> not (vcontains k result) }
  =
  select (fun x -> p x && vcontains (keyt x) v) c

  (* ------------------------------------------------------------------------ *)
  lemma mem_select : forall e c p.
  mem e (select_to_coll p c) <-> mem e c /\ p e

  (* ------------------------------------------------------------------------ *)
  let function head (i : int) (c : collection) : collection
  ensures { forall e. mem e result -> mem e c }
  ensures { 0 <= i <= card c -> card result = i }
  ensures { i > card c -> result = c }
  = mk (N.head i c.content)

  (* ------------------------------------------------------------------------ *)
  let function tail (i : int) (c : collection) : collection
  ensures { forall e. mem e result -> mem e c }
  ensures { 0 <= i <= card c -> card result = card c - i }
  = mk (N.tail i c.content)

  (* ------------------------------------------------------------------------ *)
  let function nth (i : int) (c : collection) : option t
  (* TODO postconditions *)
  = N.nth i c.content

  (* ------------------------------------------------------------------------ *)
  let function removeif (p : t -> bool) (c : collection) : collection
  ensures { forall k e. get k c = Some e -> not (p e) -> get k result = None }
  ensures { forall k e. get k c = Some e -> p e -> get k result = Some e }
  ensures { forall k. get k c = None -> get k result = None }
  =
  let rec internal_removeif (l : list t) : list t
  variant { l }
  = match l with
  | Nil -> Nil
  | Cons e tl -> if p e then internal_removeif tl else Cons e (internal_removeif tl)
  end in
  mk (N.mk (internal_removeif (N.elts c.content)))

  let function removeif_in_view (v : view) (c : collection) : collection
  ensures { forall e. mem e result <-> vcontains (keyt e) v /\ mem e c }
  = removeif (fun x -> contains (keyt x) (from_view v c)) c

  (* ------------------------------------------------------------------------ *)
  type field

  (* ------------------------------------------------------------------------ *)
  val function felts field : list tk

  (* ------------------------------------------------------------------------ *)
  val function fcontains tk field : bool

  (* ------------------------------------------------------------------------ *)
  let function from_field (f : field) (c : collection) : collection
  ensures { forall e. mem e result <-> mem e c /\ fcontains (keyt e) f }
  =
  let rec internal_from_field (l : list tk) : list t
  variant { l }
  =
  match l with
  | Cons k tl ->
    match get k c with
    | Some a -> Cons a (internal_from_field tl)
    | None -> internal_from_field tl
    end
  | Nil -> Nil
  end in
  mk (N.mk (internal_from_field (felts f)))

  (* ------------------------------------------------------------------------ *)
  let function removeif_in_field (f : field) (c : collection) : collection
  ensures { forall e. mem e result <-> not (fcontains (keyt e) f) /\ mem e c }
  = removeif (fun x -> contains (keyt x) (from_field f c)) c

  (* ------------------------------------------------------------------------ *)
  let function removeif_in_field_and_pred (p : t -> bool) (f : field) (c : collection) : collection
  ensures { forall e.
    mem e result <-> (not (p e) \/ not (fcontains (keyt e) f)) /\ mem e c
  }
  = removeif (fun x -> p x && contains (keyt x) (from_field f c)) c

  (* ------------------------------------------------------------------------ *)
  let function is_in_view (v : view) (e : t) : bool
  ensures { result = vcontains (keyt e) v }
  = vcontains (keyt e) v

end

module Set
  use list.List
  use list.Mem

  (* ------------------------------------------------------------------------ *)
  type t

  (* ------------------------------------------------------------------------ *)
  val function eqt t t : bool

  (* ------------------------------------------------------------------------ *)
  val function le_t t t : bool

  (* ------------------------------------------------------------------------ *)
  axiom eqP : forall x y. eqt x y <-> x = y

  (* ------------------------------------------------------------------------ *)
  let predicate le t1 t2 = le_t t1 t2

  (* ------------------------------------------------------------------------ *)
  clone InsertionSort as S with type elt = t,
                                val le = le

  (* ------------------------------------------------------------------------ *)
  clone Undup as U with type t = t,
                        val eqt = eqt

  (* ------------------------------------------------------------------------ *)
  let function norm (l : list t) = S.insertion_sort (U.undup l)

  (* ------------------------------------------------------------------------ *)
  clone fset.FSet as F with type t     = t,
                            val eqt    = eqt,
                            val norm   = norm,
                            axiom .

  (* ------------------------------------------------------------------------ *)
  type set = F.fset

  (* ------------------------------------------------------------------------ *)
  let function contains (e : t) (s : set) : bool
  ensures { result <-> F.fmem e s }
  =
  let rec function internal_contains (l : list t) : bool
  variant { l }
  = match l with
  | Cons x tl ->
    if eqt e x then true else internal_contains tl
  | Nil -> false
  end in
  internal_contains (F.content s)

  (* ------------------------------------------------------------------------ *)
  let function add (e : t) (s : set) : set
  ensures { forall x. x <> e -> contains x result = contains x s}
  ensures { contains e result }
  = F.mk (Cons e (F.content s))

  (* ------------------------------------------------------------------------ *)
  let function remove (e : t) (s : set) : set
  ensures { forall x. x <> e -> contains x result = contains x s}
  ensures { not (contains e s) -> not (contains e result) }
  =
  let rec function internal_remove (l : list t) : list t
  variant { l }
  = match l with
  | Cons x tl ->
    if eqt e x then tl else internal_remove tl
  | Nil -> Nil
  end in
  F.mk (internal_remove (F.content s))

  (* ------------------------------------------------------------------------ *)
  let function card (s : set) : int
  (* TODO postconditions ? *)
  = F.fcard s

  (* ------------------------------------------------------------------------ *)
  let function empty = F.fset0

  (* ------------------------------------------------------------------------ *)
  let function elts (s : set) : list t
  ensures { U.undup result = result }
  (* ensures { } TODO : result is sorted *)
  ensures { forall e. mem e result <-> contains e s }
  = F.content s

  (* ------------------------------------------------------------------------ *)
  let function from_list (l : list t) : set
  ensures { forall e. contains e result <-> mem e l }
  = F.mk l

end

module List
  use list.List
  use list.Length as L
  use list.Nth as N
  use option.Option
  use Types

  (* ------------------------------------------------------------------------ *)
  type t

  (* ------------------------------------------------------------------------ *)
  val function eqt t t : bool

  (* ------------------------------------------------------------------------ *)
  axiom eqP : forall x y. eqt x y <-> x = y

  (* ------------------------------------------------------------------------ *)
  let function card l = L.length l

  (* ------------------------------------------------------------------------ *)
  let function nth n l : option t
  = N.nth l n

  (* ------------------------------------------------------------------------ *)
  let rec function contains a l
  (* TODO postcondition *)
  =
  match l with
  | Nil -> false
  | Cons e tl -> eqt a e || contains a tl
  end

  (* ------------------------------------------------------------------------ *)
  let function prepend (a : t) (l : list t) : list t
  (* TODO postconditions *)
  = Cons a l

  (* ------------------------------------------------------------------------ *)
  let rec function eq_list (l1 : list t) (l2 : list t) : bool
  variant { l1, l2 }
  =
  match l1, l2 with
  | Cons e1 tl1, Cons e2 tl2 ->
    if eqt e1 e2 then true else eq_list tl1 tl2
  | _ -> false
  end

  (* ------------------------------------------------------------------------ *)
  lemma eq_list_spec : forall l1 l2. eq_list l1 l2 <-> l1 = l2

end

module Sort
  use list.List
  use int.Int
  use Types
  use View as V

  (* ------------------------------------------------------------------------ *)
  type t
  (* ------------------------------------------------------------------------ *)
  type view
  (* ------------------------------------------------------------------------ *)
  type collection
  (* ------------------------------------------------------------------------ *)
  val function cmp t t : bool
  (* ------------------------------------------------------------------------ *)
  val function view_to_list view collection : list t
  (* ------------------------------------------------------------------------ *)
  val function list_to_view (list t) : view

  (* ------------------------------------------------------------------------ *)
  let predicate ple (a b : t) = cmp a b

  (* ------------------------------------------------------------------------ *)
  clone InsertionSort as IS with type elt = t,
                                 val le = ple

  let function sort (v : view) (c : collection)
  (* TODO postconditions *)
  =
  list_to_view (IS.insertion_sort (view_to_list v c))

end

module Sum

  use  int.Int
  use  list.List
  use  option.Option
  use  View as V

  (* ------------------------------------------------------------------------ *)
  type t

  (* ------------------------------------------------------------------------ *)
  type tk

  (* ------------------------------------------------------------------------ *)
  type collection

  (* ------------------------------------------------------------------------ *)
  type view

  (* ------------------------------------------------------------------------ *)
  val function field t : int

  (* ------------------------------------------------------------------------ *)
  val function view_to_list view collection : list t

  (* ------------------------------------------------------------------------ *)
  val function to_view collection : view

  (* ------------------------------------------------------------------------ *)
  val function empty : view

  (* ------------------------------------------------------------------------ *)
  val function contains tk view : bool

  (* ------------------------------------------------------------------------ *)
  val function nth int view : option tk

  (* ------------------------------------------------------------------------ *)
  val function head int view : view

  (* ------------------------------------------------------------------------ *)
  val function tail int view : view

  (* ------------------------------------------------------------------------ *)
  val function card view : int

  (* ------------------------------------------------------------------------ *)
  val function add t collection : collection

  (* ------------------------------------------------------------------------ *)
  val function remove tk collection : collection

  (* ------------------------------------------------------------------------ *)
  val function set tk t collection : collection

  (* ------------------------------------------------------------------------ *)
  val function get tk collection : option t

  (* ------------------------------------------------------------------------ *)
  val function keyt t : tk

  (* ------------------------------------------------------------------------ *)
  let function sum (v : view) (c : collection) : int
  =
  let rec function internal_sum (l : list t) : int
  variant { l }
  =
    match l with
     | Nil -> 0
     | Cons e tl -> field e + internal_sum tl
    end
  in
  internal_sum (view_to_list v c)

  (* ------------------------------------------------------------------------ *)
  lemma sum_empty : forall c. sum empty c = 0

  (* ------------------------------------------------------------------------ *)
  axiom effect_add : forall a c.
  get (keyt a) c = None ->
  sum (to_view (add a c)) (add a c) = sum (to_view c) c + field a

  (* ------------------------------------------------------------------------ *)
  axiom effect_remove : forall a c.
  get (keyt a) c = Some a ->
  sum (to_view (remove (keyt a) c)) (remove (keyt a) c) = sum (to_view c) c - field a

  (* ------------------------------------------------------------------------ *)
  axiom effect_set : forall k a c.
  keyt a = k ->
  sum (to_view (set k a c)) (set k a c) = sum (to_view c) c +
  match get k c with | Some r -> field a - field r | None -> 0 end

  (* ------------------------------------------------------------------------ *)
  axiom effect_gt0 : forall v c.
  (forall e. get (keyt e) c = Some e -> field e >= 0) ->
  sum v c >= 0

  (* ------------------------------------------------------------------------ *)
  axiom effect_tail_succ : forall i v c.
  sum (tail (i+1) v) c = sum (tail i v) c -
  match nth i v with
  | Some k -> match get k c with | Some a -> field a | None -> 0 end
  | None -> 0
  end

  (* ------------------------------------------------------------------------ *)
  axiom effect_head_succ : forall i v c.
  sum (head (i+1) v) c = sum (head i v) c +
  match nth (i+1) v with
  | Some k -> match get k c with | Some a -> field a | None -> 0 end
  | None -> 0
  end

  (* ------------------------------------------------------------------------ *)
  axiom effect_remove_not_in_view : forall k v c.
  not (contains k v) ->
  sum v (remove k c) = sum v c

end

theory Lib

  use export int.Int
  use export option.Option
  use export Utils
  use export Types
  use export Operation
  use export Trace

end