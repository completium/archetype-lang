{
    "smart-contract" : {
        "name" :"Fizzy";
        "url" : "https://github.com/edukera/cml-lang/blob/master/contracts/fizzy.cml";
        "property": {
            "id":"fizzy_p1";
            "desc":"Only contract owner can interact with the Fizzy smart contract ";
            "formula": {
                "lang":"cml"
                "code":"anyaction may only be performed by [creator]"
            };
            "proof": {
                "type" : "why3";
                "version" : "3.1.1.1";
                "cmd" : "why3 solve -L ~/cml/wh3/lib/ -D cml -T Fizzy -a split_vc -o ."
                "mlw" : "theory Task
                         (* use why3.BuiltIn.BuiltIn *)

                         type bool =
                           | True
                           | False

                         (* use why3.Bool.Bool *)

                         type tuple0 =
                           | Tuple0

                         (* use why3.Tuple0.Tuple01 *)

                         type unit = tuple0

                         (* use why3.Unit.Unit *)

                         function zero : int = 0

                         function one : int = 1

                         function prefix_mn [@model_trace:prefix -] int : int

                         function infix_pl [@model_trace:infix +] int int : int

                         function infix_as [@model_trace:infix *] int int : int

                         predicate infix_ls [@model_trace:infix <] int int

                         function infix_mn (x1:int) (y:int) : int = infix_pl x1 (prefix_mn y)

                         predicate infix_gt (x1:int) (y:int) = infix_ls y x1

                         predicate infix_lseq (x1:int) (y:int) = infix_ls x1 y \/ (x1 = y)

                         predicate infix_gteq (x1:int) (y:int) = infix_lseq y x1

                         axiom Assoc : forall x1:int, y:int, z:int. (infix_pl (infix_pl x1 y)
                           z = infix_pl x1 (infix_pl y z))

                         (* clone algebra.Assoc with type t = int, function op = infix_pl,
                           prop Assoc1 = Assoc,  *)axiom Unit_def_l : forall x1:int. (infix_pl zero x1 = x1)

                         axiom Unit_def_r : forall x1:int. (infix_pl x1 zero = x1)

                         (* clone algebra.Monoid with type t1 = int, function unit = zero,
                           function op1 = infix_pl, prop Unit_def_r1 = Unit_def_r,
                           prop Unit_def_l1 = Unit_def_l, prop Assoc2 = Assoc,  *)axiom Inv_def_l : forall x1:int. (infix_pl (prefix_mn x1) x1 = zero)

                         axiom Inv_def_r : forall x1:int. (infix_pl x1 (prefix_mn x1) = zero)

                         (* clone algebra.Group with type t2 = int, function inv = prefix_mn,
                           function unit1 = zero, function op2 = infix_pl,
                           prop Inv_def_r1 = Inv_def_r, prop Inv_def_l1 = Inv_def_l,
                           prop Unit_def_r2 = Unit_def_r, prop Unit_def_l2 = Unit_def_l,
                           prop Assoc3 = Assoc,  *)axiom Comm : forall x1:int, y:int. (infix_pl x1 y = infix_pl y x1)

                         (* clone algebra.Comm with type t3 = int, function op3 = infix_pl,
                           prop Comm1 = Comm,  *)(* meta AC function infix_pl *)

                         (* clone algebra.CommutativeGroup with type t4 = int,
                           function inv1 = prefix_mn, function unit2 = zero, function op4 = infix_pl,
                           prop Comm2 = Comm, prop Inv_def_r2 = Inv_def_r,
                           prop Inv_def_l2 = Inv_def_l, prop Unit_def_r3 = Unit_def_r,
                           prop Unit_def_l3 = Unit_def_l, prop Assoc4 = Assoc,  *)axiom Assoc5 : forall x1:int, y:int, z:int. (infix_as (infix_as x1 y)
                           z = infix_as x1 (infix_as y z))

                         (* clone algebra.Assoc with type t = int, function op = infix_as,
                           prop Assoc1 = Assoc5,  *)axiom Mul_distr_l : forall x1:int, y:int, z:int. (infix_as x1 (infix_pl y
                           z) = infix_pl (infix_as x1 y) (infix_as x1 z))

                         axiom Mul_distr_r : forall x1:int, y:int, z:int. (infix_as (infix_pl y z)
                           x1 = infix_pl (infix_as y x1) (infix_as z x1))

                         (* clone algebra.Ring with type t5 = int, function infix_as1 = infix_as,
                           function prefix_mn1 = prefix_mn, function infix_pl1 = infix_pl,
                           function zero1 = zero, prop Mul_distr_r1 = Mul_distr_r,
                           prop Mul_distr_l1 = Mul_distr_l, prop Assoc6 = Assoc5, prop Comm3 = Comm,
                           prop Inv_def_r3 = Inv_def_r, prop Inv_def_l3 = Inv_def_l,
                           prop Unit_def_r4 = Unit_def_r, prop Unit_def_l4 = Unit_def_l,
                           prop Assoc7 = Assoc,  *)axiom Comm4 : forall x1:int, y:int. (infix_as x1 y = infix_as y x1)

                         (* clone algebra.Comm with type t3 = int, function op3 = infix_as,
                           prop Comm1 = Comm4,  *)(* meta AC function infix_as *)

                         (* clone algebra.CommutativeRing with type t6 = int,
                           function infix_as2 = infix_as, function prefix_mn2 = prefix_mn,
                           function infix_pl2 = infix_pl, function zero2 = zero, prop Comm5 = Comm4,
                           prop Mul_distr_r2 = Mul_distr_r, prop Mul_distr_l2 = Mul_distr_l,
                           prop Assoc8 = Assoc5, prop Comm6 = Comm, prop Inv_def_r4 = Inv_def_r,
                           prop Inv_def_l4 = Inv_def_l, prop Unit_def_r5 = Unit_def_r,
                           prop Unit_def_l5 = Unit_def_l, prop Assoc9 = Assoc,  *)axiom Unitary : forall x1:int. (infix_as one x1 = x1)

                         axiom NonTrivialRing : not (zero = one)

                         (* clone algebra.UnitaryCommutativeRing with type t7 = int,
                           function one1 = one, function infix_as3 = infix_as,
                           function prefix_mn3 = prefix_mn, function infix_pl3 = infix_pl,
                           function zero3 = zero, prop NonTrivialRing1 = NonTrivialRing,
                           prop Unitary1 = Unitary, prop Comm7 = Comm4,
                           prop Mul_distr_r3 = Mul_distr_r, prop Mul_distr_l3 = Mul_distr_l,
                           prop Assoc10 = Assoc5, prop Comm8 = Comm, prop Inv_def_r5 = Inv_def_r,
                           prop Inv_def_l5 = Inv_def_l, prop Unit_def_r6 = Unit_def_r,
                           prop Unit_def_l6 = Unit_def_l, prop Assoc11 = Assoc,  *)(* clone relations.EndoRelation with type t8 = int,
                           predicate rel = infix_lseq,  *)axiom Refl : forall x1:int. infix_lseq x1 x1

                         (* clone relations.Reflexive with type t9 = int, predicate rel1 = infix_lseq,
                           prop Refl1 = Refl,  *)(* clone relations.EndoRelation with type t8 = int,
                           predicate rel = infix_lseq,  *)axiom Trans : forall x1:int, y:int, z:int. infix_lseq x1 y -> infix_lseq y
                           z -> infix_lseq x1 z

                         (* clone relations.Transitive with type t10 = int,
                           predicate rel2 = infix_lseq, prop Trans1 = Trans,  *)(* clone relations.PreOrder with type t11 = int, predicate rel3 = infix_lseq,
                           prop Trans2 = Trans, prop Refl2 = Refl,  *)(* clone relations.EndoRelation with type t8 = int,
                           predicate rel = infix_lseq,  *)axiom Antisymm : forall x1:int, y:int. infix_lseq x1 y -> infix_lseq y x1 ->
                           (x1 = y)

                         (* clone relations.Antisymmetric with type t12 = int,
                           predicate rel4 = infix_lseq, prop Antisymm1 = Antisymm,  *)(* clone relations.PartialOrder with type t13 = int,
                           predicate rel5 = infix_lseq, prop Antisymm2 = Antisymm,
                           prop Trans3 = Trans, prop Refl3 = Refl,  *)(* clone relations.EndoRelation with type t8 = int,
                           predicate rel = infix_lseq,  *)axiom Total : forall x1:int, y:int. infix_lseq x1 y \/ infix_lseq y x1

                         (* clone relations.Total with type t14 = int, predicate rel6 = infix_lseq,
                           prop Total1 = Total,  *)(* clone relations.TotalOrder with type t15 = int,
                           predicate rel7 = infix_lseq, prop Total2 = Total,
                           prop Antisymm3 = Antisymm, prop Trans4 = Trans, prop Refl4 = Refl,  *)axiom ZeroLessOne : infix_lseq zero one

                         axiom CompatOrderAdd : forall x1:int, y:int, z:int. infix_lseq x1 y ->
                           infix_lseq (infix_pl x1 z) (infix_pl y z)

                         axiom CompatOrderMult : forall x1:int, y:int, z:int. infix_lseq x1 y ->
                           infix_lseq zero z -> infix_lseq (infix_as x1 z) (infix_as y z)

                         (* clone algebra.OrderedUnitaryCommutativeRing with type t16 = int,
                           predicate infix_lseq1 = infix_lseq, function one2 = one,
                           function infix_as4 = infix_as, function prefix_mn4 = prefix_mn,
                           function infix_pl4 = infix_pl, function zero4 = zero,
                           prop CompatOrderMult1 = CompatOrderMult,
                           prop CompatOrderAdd1 = CompatOrderAdd, prop ZeroLessOne1 = ZeroLessOne,
                           prop Total3 = Total, prop Antisymm4 = Antisymm, prop Trans5 = Trans,
                           prop Refl5 = Refl, prop NonTrivialRing2 = NonTrivialRing,
                           prop Unitary2 = Unitary, prop Comm9 = Comm4,
                           prop Mul_distr_r4 = Mul_distr_r, prop Mul_distr_l4 = Mul_distr_l,
                           prop Assoc12 = Assoc5, prop Comm10 = Comm, prop Inv_def_r6 = Inv_def_r,
                           prop Inv_def_l6 = Inv_def_l, prop Unit_def_r7 = Unit_def_r,
                           prop Unit_def_l7 = Unit_def_l, prop Assoc13 = Assoc,  *)(* use int.Int *)

                         type uint32 = <range ...>

                         function uint32qtint uint32 : int

                         function uint32qtmaxInt : int = 4294967295

                         function uint32qtminInt : int = 0

                         (* meta range_type type uint32, function uint32qtint *)

                         function max_uint32 : int = 0xffffffff

                         function length : int = 32

                         function radix : int = infix_pl max_uint32 1

                         function to_int (x1:uint32) : int = uint32qtint x1

                         (* use mach.int.UInt32Gen *)

                         function min_unsigned : int = 0

                         (* meta coercion function uint32qtint *)

                         (* meta model_projection function uint32qtint *)

                         predicate in_bounds (n:int) = infix_lseq min_unsigned n /\ infix_lseq n
                           uint32qtmaxInt

                         axiom to_int_in_bounds : forall n:uint32. in_bounds ([@coercion] uint32qtint
                           n)

                         axiom extensionality : forall x1:uint32, y:uint32. (uint32qtint
                           x1 = uint32qtint y) -> (x1 = y)

                         function abs (x1:int) : int = if infix_gteq x1 0 then x1 else prefix_mn x1

                         axiom Abs_le : forall x1:int, y:int. infix_lseq (abs x1) y <-> infix_lseq
                           (prefix_mn y) x1 /\ infix_lseq x1 y

                         axiom Abs_pos : forall x1:int. infix_gteq (abs x1) 0

                         (* use int.Abs *)

                         function div int int : int

                         function mod int int : int

                         axiom Div_mod : forall x1:int, y:int. not (y = 0) -> (x1 = infix_pl (infix_as
                           y (div x1 y)) (mod x1 y))

                         axiom Div_bound : forall x1:int, y:int. infix_gteq x1 0 /\ infix_gt y 0 ->
                           infix_lseq 0 (div x1 y) /\ infix_lseq (div x1 y) x1

                         axiom Mod_bound : forall x1:int, y:int. not (y = 0) -> infix_ls (prefix_mn
                           (abs y)) (mod x1 y) /\ infix_ls (mod x1 y) (abs y)

                         axiom Div_sign_pos : forall x1:int, y:int. infix_gteq x1 0 /\ infix_gt y 0 ->
                           infix_gteq (div x1 y) 0

                         axiom Div_sign_neg : forall x1:int, y:int. infix_lseq x1 0 /\ infix_gt y 0 ->
                           infix_lseq (div x1 y) 0

                         axiom Mod_sign_pos : forall x1:int, y:int. infix_gteq x1 0 /\ not (y = 0) ->
                           infix_gteq (mod x1 y) 0

                         axiom Mod_sign_neg : forall x1:int, y:int. infix_lseq x1 0 /\ not (y = 0) ->
                           infix_lseq (mod x1 y) 0

                         axiom Rounds_toward_zero : forall x1:int, y:int. not (y = 0) -> infix_lseq
                           (abs (infix_as (div x1 y) y)) (abs x1)

                         axiom Div_1 : forall x1:int. (div x1 1 = x1)

                         axiom Mod_1 : forall x1:int. (mod x1 1 = 0)

                         axiom Div_inf : forall x1:int, y:int. infix_lseq 0 x1 /\ infix_ls x1 y ->
                           (div x1 y = 0)

                         axiom Mod_inf : forall x1:int, y:int. infix_lseq 0 x1 /\ infix_ls x1 y ->
                           (mod x1 y = x1)

                         axiom Div_mult : forall x1:int, y:int, z:int [div (infix_pl (infix_as x1 y)
                           z) x1]. infix_gt x1 0 /\ infix_gteq y 0 /\ infix_gteq z 0 -> (div (infix_pl
                           (infix_as x1 y) z) x1 = infix_pl y (div z x1))

                         axiom Mod_mult : forall x1:int, y:int, z:int [mod (infix_pl (infix_as x1 y)
                           z) x1]. infix_gt x1 0 /\ infix_gteq y 0 /\ infix_gteq z 0 -> (mod (infix_pl
                           (infix_as x1 y) z) x1 = mod z x1)

                         (* use int.ComputerDivision *)

                         (* clone mach.int.Bounded_int with type t17 = uint32,
                           predicate in_bounds1 = in_bounds, function to_int1 = uint32qtint,
                           function max = uint32qtmaxInt, function min = min_unsigned,
                           prop extensionality1 = extensionality,
                           prop to_int_in_bounds1 = to_int_in_bounds,  *)function zero_unsigned [@model_trace:zero_unsigned] : uint32

                         axiom zero_unsigned_is_zero : (uint32qtint zero_unsigned = 0)

                         (* clone mach.int.Unsigned with type t18 = uint32, function radix1 = radix,
                           function zero_unsigned1 = zero_unsigned, predicate in_bounds2 = in_bounds,
                           function to_int2 = uint32qtint, function max1 = uint32qtmaxInt,
                           function min_unsigned1 = min_unsigned, prop radix_def = radix_def1,
                           prop zero_unsigned_is_zero1 = zero_unsigned_is_zero,
                           prop extensionality2 = extensionality,
                           prop to_int_in_bounds2 = to_int_in_bounds,  *)(* use mach.int.UInt32 *)

                         type key = int

                         type role = int

                         type address = int

                         type uint = uint32

                         type tez = int

                         type date = int

                         type string = int

                         function max_uint [@model_trace:max_uint] : int = max_uint32

                         (* use cml3.Types *)

                         type list 'a =
                           | Nil
                           | Cons 'a (list 'a)

                         predicate is_nil (l:list 'a) =
                           match l with
                           | Nil -> true
                           | Cons _ _ -> false
                           end

                         axiom is_nil_spec [@W:non_conservative_extension:N] : forall l:list 'a.
                           is_nil l <-> (l = Nil:list 'a)

                         (* use list.List *)

                         function infix_plpl (l1:list 'a) (l2:list 'a) : list 'a =
                           match l1 with
                           | Nil -> l2
                           | Cons x1 r1 -> Cons x1 (infix_plpl r1 l2)
                           end

                         axiom Append_assoc : forall l1:list 'a, l2:list 'a, l3:list 'a. (infix_plpl
                           l1 (infix_plpl l2 l3) = infix_plpl (infix_plpl l1 l2) l3)

                         axiom Append_l_nil : forall l:list 'a. (infix_plpl l (Nil:list 'a) = l)

                         function length1 (l:list 'a) : int =
                           match l with
                           | Nil -> 0
                           | Cons _ r -> infix_pl 1 (length1 r)
                           end

                         axiom Length_nonnegative : forall l:list 'a. infix_gteq (length1 l) 0

                         axiom Length_nil : forall l:list 'a. (length1 l = 0) <-> (l = Nil:list 'a)

                         (* use list.Length *)

                         axiom Append_length : forall l1:list 'a, l2:list 'a. (length1 (infix_plpl l1
                           l2) = infix_pl (length1 l1) (length1 l2))

                         predicate mem (x1:'a) (l:list 'a) =
                           match l with
                           | Nil -> false
                           | Cons y r -> (x1 = y) \/ mem x1 r
                           end

                         (* use list.Mem *)

                         axiom mem_append : forall x1:'a, l1:list 'a, l2:list 'a. mem x1 (infix_plpl
                           l1 l2) <-> mem x1 l1 \/ mem x1 l2

                         axiom mem_decomp : forall x1:'a, l:list 'a. mem x1 l -> (exists l1:list 'a,
                           l2:list 'a. (l = infix_plpl l1 (Cons x1 l2)))

                         (* use list.Append *)

                         type set 'a

                         (* meta material_type_arg type set, 0 *)

                         predicate mem1 [@model_trace:mem] 'a (set 'a)

                         predicate infix_eqeq [@model_trace:infix ==] (set 'a) (set 'a)

                         axiom infix_eqeq_spec [@W:non_conservative_extension:N]
                           [@model_trace:infix ==] : forall s1:set 'a, s2:set 'a. infix_eqeq s1 s2 <->
                           (forall x1:'a. mem1 x1 s1 <-> mem1 x1 s2)

                         axiom extensionality3 : forall s1:set 'a, s2:set 'a. infix_eqeq s1 s2 ->
                           (s1 = s2)

                         predicate subset [@model_trace:subset] (set 'a) (set 'a)

                         axiom subset_spec [@W:non_conservative_extension:N]
                           [@model_trace:subset] : forall s1:set 'a, s2:set 'a. subset s1 s2 <->
                           (forall x1:'a. mem1 x1 s1 -> mem1 x1 s2)

                         axiom subset_refl : forall s:set 'a. subset s s

                         axiom subset_trans : forall s1:set 'a, s2:set 'a, s3:set 'a. subset s1 s2 ->
                           subset s2 s3 -> subset s1 s3

                         predicate is_empty [@model_trace:is_empty] (set 'a)

                         axiom is_empty_spec [@W:non_conservative_extension:N]
                           [@model_trace:is_empty] : forall s:set 'a. is_empty s <-> (forall x1:'a.
                           not mem1 x1 s)

                         function empty [@model_trace:empty] : set 'a

                         axiom empty_def [@W:non_conservative_extension:N]
                           [@model_trace:empty] : is_empty (empty:set 'a)

                         function add [@model_trace:add] 'a (set 'a) : set 'a

                         axiom add_spec [@W:non_conservative_extension:N]
                           [@model_trace:add] : forall x1:'a, s:set 'a. forall y:'a. mem1 y (add x1
                           s) <-> (y = x1) \/ mem1 y s

                         function singleton (x1:'a) : set 'a = add x1 (empty:set 'a)

                         function remove [@model_trace:remove] 'a (set 'a) : set 'a

                         axiom remove_spec [@W:non_conservative_extension:N]
                           [@model_trace:remove] : forall x1:'a, s:set 'a. forall y:'a. mem1 y (remove
                           x1 s) <-> not (y = x1) /\ mem1 y s

                         axiom add_remove : forall x1:'a, s:set 'a. mem1 x1 s -> (add x1 (remove x1
                           s) = s)

                         axiom remove_add : forall x1:'a, s:set 'a. (remove x1 (add x1 s) = remove x1
                           s)

                         axiom subset_remove : forall x1:'a, s:set 'a. subset (remove x1 s) s

                         function union [@model_trace:union] (set 'a) (set 'a) : set 'a

                         axiom union_spec [@W:non_conservative_extension:N]
                           [@model_trace:union] : forall s1:set 'a, s2:set 'a. forall x1:'a. mem1 x1
                           (union s1 s2) <-> mem1 x1 s1 \/ mem1 x1 s2

                         function inter [@model_trace:inter] (set 'a) (set 'a) : set 'a

                         axiom inter_spec [@W:non_conservative_extension:N]
                           [@model_trace:inter] : forall s1:set 'a, s2:set 'a. forall x1:'a. mem1 x1
                           (inter s1 s2) <-> mem1 x1 s1 /\ mem1 x1 s2

                         function diff [@model_trace:diff] (set 'a) (set 'a) : set 'a

                         axiom diff_spec [@W:non_conservative_extension:N]
                           [@model_trace:diff] : forall s1:set 'a, s2:set 'a. forall x1:'a. mem1 x1
                           (diff s1 s2) <-> mem1 x1 s1 /\ not mem1 x1 s2

                         axiom subset_diff : forall s1:set 'a, s2:set 'a. subset (diff s1 s2) s1

                         function choose [@model_trace:choose] (set 'a) : 'a

                         axiom choose_spec [@W:non_conservative_extension:N]
                           [@model_trace:choose] : forall s:set 'a. not is_empty s -> mem1 (choose s)
                           s

                         function cardinal [@model_trace:cardinal] (set 'a) : int

                         axiom cardinal_nonneg : forall s:set 'a. infix_gteq (cardinal s) 0

                         axiom cardinal_empty : forall s:set 'a. (cardinal s = 0) <-> is_empty s

                         axiom cardinal_add : forall x1:'a. forall s:set 'a. not mem1 x1 s ->
                           (cardinal (add x1 s) = infix_pl 1 (cardinal s))

                         axiom cardinal_remove : forall x1:'a. forall s:set 'a. mem1 x1 s -> (cardinal
                           s = infix_pl 1 (cardinal (remove x1 s)))

                         axiom cardinal_subset : forall s1:set 'a, s2:set 'a. subset s1 s2 ->
                           infix_lseq (cardinal s1) (cardinal s2)

                         axiom subset_eq : forall s1:set 'a, s2:set 'a. subset s1 s2 -> (cardinal
                           s1 = cardinal s2) -> infix_eqeq s1 s2

                         axiom cardinal1 : forall s:set 'a. (cardinal s = 1) -> (forall x1:'a. mem1 x1
                           s -> (x1 = choose s))

                         (* use set.Fset *)

                         function nth int (set 'a) : 'a

                         axiom nth_injective : forall s:set 'a, i:int, j:int. infix_lseq 0 i /\
                           infix_ls i (cardinal s) -> infix_lseq 0 j /\ infix_ls j (cardinal s) ->
                           (nth i s = nth j s) -> (i = j)

                         axiom nth_surjective : forall s:set 'a, x1:'a. mem1 x1 s -> (exists i:int.
                           (infix_lseq 0 i /\ infix_ls i (cardinal s)) /\ (x1 = nth i s))

                         (* use set.FsetNth *)

                         type infix_mngt 'a 'b

                         function infix_at (infix_mngt 'a 'b) 'a : 'b

                         (* use why3.HighOrd.HighOrd *)

                         function sum (set 'a) (infix_mngt 'a int) : int

                         axiom Sum_def_empty : forall f:infix_mngt 'a int. (sum (empty:set 'a) f = 0)

                         axiom Sum_add : forall s:set 'a. forall f:infix_mngt 'a int, x1:'a. not mem1
                           x1 s -> (sum (add x1 s) f = infix_pl (sum s f) (infix_at f x1))

                         axiom Sum_remove : forall s:set 'a. forall f:infix_mngt 'a int, x1:'a. mem1
                           x1 s -> (sum (remove x1 s) f = infix_mn (sum s f) (infix_at f x1))

                         axiom Sum_def_choose : forall s:set 'a. forall f:infix_mngt 'a int.
                           not is_empty s -> (let x1 = choose s in (sum s f = infix_pl (infix_at f x1)
                           (sum (remove x1 s) f)))

                         axiom Sum_transitivity : forall s1:set 'a, s2:set 'a. forall f:infix_mngt 'a
                           int. (sum (union s1 s2) f = infix_mn (infix_pl (sum s1 f) (sum s2 f)) (sum
                           (inter s1 s2) f))

                         axiom Sum_eq : forall s:set 'a. forall f:infix_mngt 'a int, g:infix_mngt 'a
                           int. (forall x1:'a. mem1 x1 s -> (infix_at f x1 = infix_at g x1)) -> (sum s
                           f = sum s g)

                         (* use set.FsetSum *)

                         type map 'a 'b = infix_mngt 'a 'b

                         function get (f:infix_mngt 'a 'b) (x1:'a) : 'b = infix_at f x1

                         function set (f:infix_mngt 'a 'b) (x1:'a) (v:'b) : infix_mngt 'a 'b = fun y:
                           'a -> if (y = x1) then v else infix_at f y

                         function mixfix_lbrb (f:infix_mngt 'a 'b) (x1:'a) : 'b = infix_at f x1

                         function mixfix_lblsmnrb (f:infix_mngt 'a 'b) (x1:'a) (v:'b) : infix_mngt 'a
                           'b = set f x1 v

                         (* use map.Map *)

                         type array 'a

                         function elts (array 'a) : infix_mngt int 'a

                         function length2 (array 'a) : int

                         axiom arrayqtinvariant : forall self:array 'a [length2 self]. infix_lseq 0
                           (length2 self)

                         function mixfix_lbrb1 (a1:array 'a) (i:int) : 'a = infix_at (elts a1) i

                         function mixfix_lblsmnrb1 [@model_trace:mixfix [<-]] (array 'a) int 'a :
                           array 'a

                         axiom mixfix_lblsmnrb_spec [@W:non_conservative_extension:N]
                           [@model_trace:mixfix [<-]] : forall a1:array 'a, i:int, v:'a. (length2
                           (mixfix_lblsmnrb1 a1 i v) = length2 a1) /\ (elts (mixfix_lblsmnrb1 a1 i
                           v) = set (elts a1) i v)

                         function make [@model_trace:make] int 'a : array 'a

                         axiom make_spec [@W:non_conservative_extension:N]
                           [@model_trace:make] : forall n:int, v:'a.
                           ([@expl:array creation size] infix_gteq n 0) -> (forall i:int. infix_lseq 0
                           i /\ infix_ls i n -> (mixfix_lbrb1 (make n v) i = v)) /\ (length2 (make n
                           v) = n)

                         (* use array.Array *)

                         type transfer =
                           | Mk_transfer (destination:int) (amount:int)

                         type transfers = list transfer

                         type env =
                           | Mk_env (balance_:int) (transferred_:int) (caller_:int) (now_:int)

                         function balance (e:env) : int = balance_ e

                         function transferred (e:env) : int = transferred_ e

                         function caller (e:env) : int = caller_ e

                         function now (e:env) : int = now_ e

                         (* use cml3.Contract *)

                         type map1 'value = infix_mngt int 'value

                         function get1 (f:infix_mngt int 'value) (x1:int) : 'value = infix_at f x1

                         function set1 (f:infix_mngt int 'value) (x1:int) (v:'value) : infix_mngt int
                           'value = fun y:int -> if (y = x1) then v else infix_at f y

                         function const (v:'value) : infix_mngt int 'value = fun us:int -> v

                         (* use cml3.Map1 *)

                         function elements (l:list 'a) : set 'a =
                           match l with
                           | Nil -> empty:set 'a
                           | Cons x1 r -> add x1 (elements r)
                           end

                         axiom elements_mem : forall x1:'a, l:list 'a. mem x1 l <-> mem1 x1 (elements
                           l)

                         (* use list.Elements *)

                         type option 'a =
                           | None
                           | Some 'a

                         predicate is_none (o:option 'a) =
                           match o with
                           | None -> true
                           | Some _ -> false
                           end

                         axiom is_none_spec [@W:non_conservative_extension:N] : forall o:option 'a.
                           is_none o <-> (o = None:option 'a)

                         (* use option.Option *)

                         function nth1 (n:int) (l:list 'a) : option 'a =
                           match l with
                           | Nil -> None:option 'a
                           | Cons x1 r -> if (n = 0) then Some x1 else nth1 (infix_mn n 1) r
                           end

                         (* use list.Nth *)

                         predicate mem2 (k:int) (a1:list int) =
                           match a1 with
                           | Cons e tl -> (e = k) \/ mem2 k tl
                           | Nil -> false
                           end

                         function length3 (c:list 'a) : int = length1 c

                         function add1 (a1:'a) (c:list 'a) : list 'a = infix_plpl c (Cons a1 (Nil:list
                           'a))

                         function remove1 (a1:'a) (eq:infix_mngt 'a (infix_mngt 'a bool)) (c:list
                           'a) : list 'a =
                           match c with
                           | Nil -> Nil:list 'a
                           | Cons e tl -> if (infix_at (infix_at eq e) a1 = True) then remove1 a1 eq
                               tl else Cons e (remove1 a1 eq tl)
                           end

                         function diff1 (c1:list 'a) (c2:list 'a) : set 'a = diff (elements c1)
                           (elements c2)

                         function subset1 (c1:list 'a) (c2:list 'a) : bool =
                           if subset (elements c1) (elements c2) then True else False

                         predicate is_empty1 (c:list int) = forall m:int. not mem2 m c

                         function sum1 (c:list 'a) (f:infix_mngt 'a int) : int = sum (elements c) f

                         axiom split_mem : forall l:list 'a, x1:'a, y:'a. mem x1 l \/ (x1 = y) <-> mem
                           x1 (infix_plpl l (Cons y (Nil:list 'a)))

                         (* use cml3.Asset *)

                         type entry =
                           | Addflightinsurance
                           | Updatestatus
                           | Manual

                         type asset =
                           | Insurance int
                           | Flight int

                         type field =
                           | Limit
                           | Premium
                           | Indemnity
                           | Stat
                           | Product
                           | Insurances

                         type action =
                           | Add
                           | Rm
                           | Get
                           | Update field
                           | Loop

                         type trace =
                           | Mk_trace (entry:entry) (asset:asset) (action:action)

                         type traces = list trace

                         predicate performed_by_role (tr:list trace) (e:env) (a1:list action) (r:list
                           int) = forall x1:trace. mem (action x1) a1 -> mem x1 tr -> mem (caller e) r

                         predicate performed_by_tx (tr:list trace) (tx2:option entry) (tx1:entry) (a1:
                           action) (l:list entry) = forall x1:trace. mem x1 tr -> (Some tx1 = tx2) ->
                           (action x1 = a1) -> mem tx1 l

                         predicate is_empty2 (l:list 'a) = (l = Nil:list 'a)

                         type status =
                           | Created
                           | Before
                           | After
                           | Cancelled
                           | FlightCancelled
                           | Redirected
                           | Diverted

                         type storage

                         function owner storage : int

                         function ikey storage : int

                         function insurances storage : list int

                         function flights storage : list int

                         function limit storage : infix_mngt int int

                         function premium storage : infix_mngt int int

                         function indemnity storage : infix_mngt int int

                         function stat storage : infix_mngt int status

                         function productid storage : infix_mngt int int

                         function finsurances storage : infix_mngt int (list int)

                         function e storage : env

                         function ops storage : list transfer

                         function tr storage : list trace

                         function ename storage : option entry

                         axiom storageqtinvariant : forall self:storage [ename self| tr self| ops
                           self| e self| owner self]. (forall a1:action. performed_by_role (tr self)
                           (e self) (Cons a1 (Nil:list action)) (Cons (owner self) (Nil:list int))) /\
                           (forall tx1:entry. (ename self = Some tx1) -> is_empty2 (ops self)) /\
                           (forall tx1:entry, x1:trace. mem x1 (tr self) -> (Some tx1 = ename self) ->
                           mem (action x1) (Cons (Update Stat) (Nil:list action)) -> mem tx1 (Cons
                           Updatestatus (Nil:list entry)))

                         function get_transfer_amount (s:storage) (l:list transfer) (i:int) : int =
                           match nth1 i l with
                           | Some t -> amount t
                           | None -> 0
                           end

                         function sum2 (list transfer) int int : int

                         axiom Sum_def_empty1 : forall c:list transfer, i:int, j:int. infix_lseq j
                           i -> (sum2 c i j = 0)

                         axiom Sum_def_non_empty : forall s:storage, c:list transfer, i:int, j:int.
                           infix_ls i j -> (sum2 c i j = infix_pl (get_transfer_amount s c i) (sum2 c
                           (infix_pl i 1) j))

                         axiom Sum_right_extension : forall s:storage, c:list transfer, i:int, j:int.
                           infix_ls i j -> (sum2 c i j = infix_pl (sum2 c i (infix_mn j 1))
                           (get_transfer_amount s c (infix_mn j 1)))

                         axiom Sum_transitivity1 : forall c:list transfer, i:int, k:int, j:int.
                           infix_lseq i k /\ infix_lseq k j -> (sum2 c i j = infix_pl (sum2 c i k)
                           (sum2 c k j))

                         axiom Sum_eq1 : forall s:storage, c1:list transfer, c2:list transfer, i:int,
                           j:int. (forall k:int. infix_lseq i k /\ infix_ls k j ->
                           (get_transfer_amount s c1 k = get_transfer_amount s c2 k)) -> (sum2 c1 i
                           j = sum2 c2 i j)

                         (* clone cml3.Sum with type t19 = transfer, type storage1 = storage,
                           function sum3 = sum2, function f = get_transfer_amount,
                           prop Sum_eq2 = Sum_eq1, prop Sum_transitivity2 = Sum_transitivity1,
                           prop Sum_right_extension1 = Sum_right_extension,
                           prop Sum_def_non_empty1 = Sum_def_non_empty,
                           prop Sum_def_empty2 = Sum_def_empty1,  *)function s [@introduced] [@model_trace:s] : storage

                         function s_ename [@introduced] : option entry

                         function s_tr [@introduced] : list trace

                         function s_ops [@introduced] : list transfer

                         function s_e [@introduced] : env

                         function s_finsurances [@introduced] : infix_mngt int (list int)

                         function s_productid [@introduced] : infix_mngt int int

                         function s_stat [@introduced] : infix_mngt int status

                         function s_indemnity [@introduced] : infix_mngt int int

                         function s_premium [@introduced] : infix_mngt int int

                         function s_limit [@introduced] : infix_mngt int int

                         function s_flights [@introduced] : list int

                         function s_insurances [@introduced] : list int

                         function s_ikey [@introduced] : int

                         function s_owner [@introduced] : int

                         function fi [@introduced] [@model_trace:fi] : int

                         function li [@introduced] [@model_trace:li] : int

                         function pre [@introduced] [@model_trace:pre] : int

                         function ind [@introduced] [@model_trace:ind] : int

                         function pro [@introduced] [@model_trace:pro] : int

                         function fk [@introduced] [@model_trace:fk] : int

                         function arrival [@introduced] [@model_trace:arrival] : int

                         function st [@introduced] [@model_trace:st] : status

                         axiom H7 [@introduced] : [@model_vc] [@vc:annotation]
                           [@expl:type invariant] (s_ename = ename s) /\ (s_tr = tr s) /\ (s_ops = ops
                           s) /\ (s_e = e s) /\ (s_finsurances = finsurances s) /\
                           (s_productid = productid s) /\ (s_stat = stat s) /\
                           (s_indemnity = indemnity s) /\ (s_premium = premium s) /\ (s_limit = limit
                           s) /\ (s_flights = flights s) /\ (s_insurances = insurances s) /\
                           (s_ikey = ikey s) /\ (s_owner = owner s)

                         axiom H8 [@introduced] : (ename s = Some Addflightinsurance)

                         axiom H9 [@introduced] : (caller (e s) = owner s)

                         function a1 [@introduced] [@model_trace:a] : action

                         (* meta syntax_type type int, "int", 0 *)

                         (* meta syntax_type type real, "real", 0 *)

                         (* meta syntax_logic predicate infix_eq, "(%1 = %2)", 0 *)

                         (* meta encoding:ignore_polymorphism_ls predicate infix_eq *)

                         goal VC_all_entries [@expl:VC for all_entries] : [@model_vc] [@asym_split]
                           [@vc:annotation] [@expl:type invariant] performed_by_role (infix_plpl
                           (infix_plpl (tr s) (Cons (Mk_trace Addflightinsurance (Insurance (infix_mn
                           (infix_pl (ikey s) 1) 1)) Add) (Nil:list trace))) (Cons (Mk_trace
                           Addflightinsurance (Flight fi) Add) (Nil:list trace))) (e s) (Cons a1
                           (Nil:list action)) (Cons (owner s) (Nil:list int))

                         end
                         "
            }

        }
    }
}
