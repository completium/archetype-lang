module Miles_with_expiration_storage

    use archetype.Lib

    (* TRACES *)

    type asset =
    | Mile
    | Owner

    type entry =
    | Add
    | Consume
    | ClearExpired

    type field =
    | Amount
    | Expiration
    | Miles

    clone archetype.Trace as Tr with type asset = asset,
                                     type entry = entry,
                                     type field = field 
    
    (* ASSETS *)
     type mile = {
        id         : int;
        amount     : int;
        expiration : date;
    } 
    
    let mk_default_mile () = { id = 0; amount = 0; expiration = 0; } : mile

    type owner = {
        addr   : address;
        miles  : acol;
    } 

    let mk_default_owner () : owner = { addr = 0; miles = empty; } : owner

    type storage = {
        mutable admin            : role;
        mutable mile_keys        : acol;
        mutable mile_assets      : map mile;
        mutable owner_keys       : acol;
        mutable owner_assets     : map owner;
         (* contract env *)
        mutable ops_             : transfers;
        (* transaction env *)
        mutable get_balance_     : tez;
        (* transaction env *)
        get_transferred_         : tez;
        get_caller_              : address;
        get_now_                 : date;
        (* diff sets *)
        mutable added_miles      : acol;
        mutable removed_miles    : acol;
        mutable added_owner      : acol;
        mutable removed_owner    : acol;
        (* traces *)
        mutable tr_              : Tr.log;
        mutable ename_           : option entry; 
    } invariant { 
        forall k : key. mem k mile_keys -> amount (get mile_assets k) > 0
    } invariant {
        Mem.mem get_caller_ (Cons admin Nil)
    } invariant { 
        (* only Consume and Clear expired may remove mile ie. if x is remove mile then x.entry is one of them *)
        forall x : Tr.trace.
        Mem.mem x tr_ ->
        Mem.mem (Tr.action x) (Cons (Tr.Rm Mile) Nil) ->
        Mem.mem (Tr.entry x) (Cons (Some Consume) (Cons (Some ClearExpired) Nil))
    } by {
        admin                    = 0;
        mile_keys                = empty;
        mile_assets              = const (mk_default_mile ());
        owner_keys               = empty;
        owner_assets             = const (mk_default_owner ());
        ops_                     = Nil;
        get_balance_             = 0;
        get_transferred_         = 0;
        get_caller_              = 0;
        get_now_                 = 0;
        added_miles              = empty;
        removed_miles            = empty;
        added_owner              = empty;
        removed_owner            = empty;
        tr_                      = Nil;
        ename_                   = None;
    }

    axiom miles_partition:
        forall s : storage, k1 k2 : key. 
        mem k1 s.owner_keys ->
        mem k2 (miles (get s.owner_assets k1)) ->
        mem k2 s.mile_keys

    axiom eq_owner_add_key:
        forall s : storage, k : key.
        mem k s.owner_keys ->
        addr (get s.owner_assets k) = k

    (* Getters ----------------------------------------------------------------*)

    let function get_amount  (s : storage) (k : key) : int = amount (get s.mile_assets k)

    let function get_expiration  (s : storage) (k : key) : int = expiration (get s.mile_assets k)

    let function get_miles (s : storage) (k : key) : acol = miles (get s.owner_assets k)

    let get_mile (s : storage) (k : key) : key 
    raises { NotFound }
    ensures { mem k s.mile_keys }
    = 
    if not (mem k s.mile_keys) then
        raise NotFound
    else k 

    let get_owner (s : storage) (k : key) : key 
    raises { NotFound }
    ensures { mem k s.owner_keys }
    = 
    if not (mem k s.owner_keys) then
        raise NotFound
    else k  

    (* Operations -------------------------------------------------------------*)

    clone archetype.Sum as Amounts with type     storage = storage,
                                        val      f       = get_amount

    let function filter_consume (s : storage) (c : acol) : acol
    ensures { forall k : key. mem k result -> get_expiration s k > get_now_ s }
    ensures { subset result c }
    =
    let rec rec_filter (l : list key) : list key
    variant { l }
    ensures { forall k : key. lmem k result -> get_expiration s k > get_now_ s }
    ensures { forall k : key. lmem k result -> lmem k l }
    =   match l with
        | Nil -> Nil
        | Cons a tl ->
          if get_expiration s a > get_now_ s
          then Cons a (rec_filter tl)
          else (rec_filter tl)
        end in
    mkacol (rec_filter c.content)

    let rec function filter_clear_expired (s : storage) (c : acol) : acol
    ensures { forall k : key. mem k result -> get_expiration s k < get_now_ s }
    ensures { subset result c }
    =
    let rec rec_filter (l : list key) : list key
    variant { l }
    ensures { forall k : key. lmem k result -> get_expiration s k < get_now_ s }
    ensures { forall k : key. lmem k result -> lmem k l }
    =   match l with
        | Nil -> Nil
        | Cons a tl ->
          if get_expiration s a < get_now_ s
          then Cons a (rec_filter tl)
          else (rec_filter tl)
        end in
    mkacol (rec_filter c.content)

    (* Setters --------------------------------------------------------------*)

    let update_mile (s : storage) (k : key) (new_mile : mile) : unit
    raises { NotFound }
    requires { amount new_mile > 0 }
    ensures { get_amount s k = amount new_mile }
    ensures { get_expiration s k = expiration new_mile }
    ensures { Amounts.sum (old s) (old s).mile_keys = Amounts.sum s s.mile_keys - (amount new_mile) + get_amount (old s) k }
    = 
    if not (mem k s.mile_keys) then
        raise NotFound
    else 
        let asset = get s.mile_assets k in
        let updated_asset = { asset with 
            amount = amount new_mile;
            expiration = expiration new_mile;
         } in
        s.mile_assets <- set s.mile_assets k updated_asset
 
    (* Adders ---------------------------------------------------------------*)

    (* is not called by actions because it is partitioned *)
    let add_mile (s : storage) (new_mile : mile) : unit
    raises { KeyExist }
    requires { amount new_mile > 0 }
    (* requires { lmem (get_caller_ s) (Cons (admin s) Nil) } *)
    ensures { mem (id new_mile) s.mile_keys }
    (* set operations *)
    ensures { s.mile_keys == union (old s).mile_keys (singleton (id new_mile)) }
    ensures { s.added_miles == union (old s).added_miles (singleton (id new_mile)) }
    ensures { is_empty (inter (old s).mile_keys (singleton (id new_mile))) }
    (* operations *)
    ensures { Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys + amount new_mile }
    ensures { forall k : key. mem k (old s).mile_keys -> get_amount s k = get_amount (old s) k }
    ensures { card s.mile_keys = card (old s).mile_keys + 1 }
    =
    if mem (id new_mile) s.mile_keys then
        raise KeyExist
    else
        s.mile_assets <- set s.mile_assets (id new_mile) new_mile;
        s.mile_keys <- add (id new_mile) s.mile_keys;
        s.added_miles <- add (id new_mile) s.added_miles;
        s.tr_ <- s.tr_ ++ Tr.mk_trace s.ename_ (Tr.Add Mile)        

    (* add a mile through an owner *)
    let add_owner_miles (s : storage) (owner : owner) (new_mile : mile) : unit
    raises { NotFound, KeyExist }
    requires { mem (addr owner) s.owner_keys }
    requires { amount new_mile > 0 }
    requires { lmem (get_caller_ s) (Cons (admin s) Nil) }
    ensures { mem (id new_mile)s.mile_keys }
    (* set operations *)
    ensures { s.mile_keys == union (old s).mile_keys (singleton (id new_mile)) }
    ensures { s.added_miles == union (old s).added_miles (singleton (id new_mile)) }
    ensures { is_empty (inter (old s).mile_keys (singleton (id new_mile))) }
    (* operations *)
    ensures { Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys + amount new_mile }
    ensures { forall k : key. mem k (old s).mile_keys -> get_amount s k = get_amount (old s) k }
    ensures { card s.mile_keys = card (old s).mile_keys + 1 }
    =
    if not (mem (addr owner) s.owner_keys) then
        raise NotFound
    else
        (add_mile s new_mile;
         (* update miles *)
         let owner_miles = miles owner in
         let new_owner_miles = add (id new_mile) owner_miles in
         let new_owner = { owner with 
            miles = new_owner_miles;
         } in
         s.owner_assets <- set s.owner_assets (addr owner) new_owner)
    
    let add_owner (s : storage) (new_owner : owner) (assets : list mile) : unit
    raises { KeyExist, NotFound }
    (* input consistency *)
    requires { let asset_keys = miles new_owner in card asset_keys = length assets }
    requires { let asset_keys = miles new_owner in 
        forall i : int. 0 <= i < card asset_keys -> nth i asset_keys = id (gen_nth i assets) 
    }
    (* mile invariant *)
    requires {  forall a : mile, i : int. 0 <= i < length assets -> a = gen_nth i assets -> amount a > 0 }
    requires { lmem (get_caller_ s) (Cons (admin s) Nil) }
    ensures { mem (addr new_owner) s.owner_keys }
    (* basic set operation *)
    ensures { s.owner_keys == union (old s).owner_keys (singleton (addr new_owner)) }
    ensures { inter (old s).owner_keys (singleton (addr new_owner)) == empty }
    ensures { 
        let asset_keys = miles new_owner in
        s.mile_keys == union (old s).mile_keys asset_keys /\ (inter (old s).mile_keys asset_keys == empty)
    }
    ensures { let asset_keys = miles new_owner in s.added_miles == union (old s).added_miles asset_keys }
    (* count operation *)
    ensures { card s.owner_keys = card (old s).owner_keys + 1 }
    ensures { 
        let  asset_keys = miles new_owner in 
        card s.mile_keys = card (old s).mile_keys + card asset_keys 
    }
    (* sum operation *)
    ensures { forall k : key. mem k (old s).mile_keys -> get_amount s k = get_amount (old s) k }
    ensures { 
        let asset_keys = miles new_owner in 
        (* let astorage = set_miles_to_storage asset_keys assets s in *)
        Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys + Amounts.sum s asset_keys 
    }
    =
    if mem (addr new_owner) s.owner_keys then
        raise KeyExist
    else
        s.owner_keys <- add (addr new_owner) s.owner_keys;
        s.owner_assets <- set s.owner_assets (addr new_owner) new_owner;
        s.tr_ <- s.tr_ ++ Tr.mk_trace s.ename_ (Tr.Add Owner);
        let asset_keys = miles new_owner in
        for i = 0 to (card asset_keys) - 1 do
        invariant { s.mile_keys == union (old s).mile_keys (head i asset_keys) }
        invariant { s.added_miles == union (old s).added_miles (head i asset_keys) }
        invariant { is_empty (inter (old s).mile_keys (head i asset_keys)) }
        invariant { forall k : key. mem k s.mile_keys -> amount (get s.mile_assets k) > 0  }
        invariant { forall k : key. mem k (old s).mile_keys -> get_amount s k = get_amount (old s) k }
            let asset = gen_nth i assets in
            add_owner_miles s new_owner asset
        done

    (* Removers ---------------------------------------------------------------*)

    let remove_mile (s : storage) (k : key) : unit
    raises { NotFound, KeyExist }
    ensures { not (mem k s.mile_keys) }
    (* preconditions for type invariants *)
    (* requires { lmem (get_caller_ s) (Cons (admin s) Nil) } *)
    requires { 
        not (not (mem k s.mile_keys)) -> forall x : Tr.trace.
        Mem.mem x (s.tr_ ++ Tr.mk_trace s.ename_ (Tr.Rm Mile)) ->
        Mem.mem (Tr.action x) (Cons (Tr.Rm Mile) Nil) ->
        Mem.mem (Tr.entry x) (Cons (Some Consume) (Cons (Some ClearExpired) Nil)) }
    (* set effect *)
    ensures { s.mile_keys == diff (old s).mile_keys (singleton k) }
    ensures { s.removed_miles == union (old s).removed_miles (singleton k) }
    (* operations *)
    ensures {  Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys - (get_amount (old s) k) }
    ensures { card s.mile_keys = card (old s).mile_keys - 1 }
    =
    if not (mem k s.mile_keys) then
        raise NotFound
    else
        s.mile_keys <- remove k s.mile_keys;
        s.removed_miles <- add k s.removed_miles;
        s.tr_ <- s.tr_ ++ Tr.mk_trace s.ename_ (Tr.Rm Mile)

    (* remove a mile through an owner *)
    let remove_owner_miles (s : storage) (k : key) (mile_k : key) : unit
    raises { NotFound, KeyExist }
    (* preconditions for type invariants *)
    requires { lmem (get_caller_ s) (Cons (admin s) Nil) }
    requires {
     not (not (mem k s.owner_keys)) ->
     not (not (mem mile_k s.mile_keys)) -> forall x : Tr.trace.
        Mem.mem x (s.tr_ ++ Tr.mk_trace s.ename_ (Tr.Rm Mile)) ->
        Mem.mem (Tr.action x) (Cons (Tr.Rm Mile) Nil) ->
        Mem.mem (Tr.entry x) (Cons (Some Consume) (Cons (Some ClearExpired) Nil)) }
    (* post conditions *)
    ensures { not (mem mile_k s.mile_keys) }
    (* set effect *)
    ensures { s.mile_keys == diff (old s).mile_keys (singleton mile_k) }
    ensures { s.removed_miles == union (old s).removed_miles (singleton mile_k) }
    (* operations *)
    ensures { Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys - (get_amount (old s) mile_k) }
    ensures { card s.mile_keys = card (old s).mile_keys - 1 }
    =
    if not (mem k s.owner_keys) then
        raise NotFound
    else
        ((* update miles *)
         let owner_asset = get s.owner_assets k in
         let owner_miles = miles owner_asset in
         let new_owner_miles = remove mile_k owner_miles in
         let new_owner_asset = { owner_asset with 
            miles = new_owner_miles;
         } in
         s.owner_assets <- set s.owner_assets k new_owner_asset;
         remove_mile s mile_k)
    
    let remove_owner (s : storage) (k : key) : unit
    raises { NotFound, KeyExist }
    (* partition property *)
    requires { mem k s.owner_keys -> subset (miles (get s.owner_assets k)) s.mile_keys }
    (* preconditions for type invariants *)
    requires { lmem (get_caller_ s) (Cons (admin s) Nil) }
    requires {
     not (not (mem k s.owner_keys)) -> forall x : Tr.trace.
        Mem.mem x (s.tr_ ++ Tr.mk_trace s.ename_ (Tr.Rm Mile) ++ Tr.mk_trace s.ename_ (Tr.Rm Owner)) ->
        Mem.mem (Tr.action x) (Cons (Tr.Rm Mile) Nil) ->
        Mem.mem (Tr.entry x) (Cons (Some Consume) (Cons (Some ClearExpired) Nil)) }
    (* post conditions *)
    ensures { not (mem k s.owner_keys) }
    (* set effect *)
    ensures { s.owner_keys == diff (old s).owner_keys (singleton k) }
    ensures { s.mile_keys == diff (old s).mile_keys (get_miles (old s) k) }
    ensures { s.removed_miles == union (old s).removed_miles (get_miles (old s) k) }
    (* count operation *)
    ensures { card s.owner_keys = card (old s).owner_keys - 1 }
    ensures { card s.mile_keys = card (old s).mile_keys - card (get_miles (old s) k) }
    (* sum operation *)
    ensures { 
        let asset_keys = get_miles (old s) k in 
        Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys - Amounts.sum (old s) asset_keys 
    }
    =
    if not (mem k s.owner_keys) then
        raise NotFound
    else
        s.owner_keys <- remove k s.owner_keys;
        s.tr_ <- s.tr_ ++ Tr.mk_trace s.ename_ (Tr.Rm Owner);
        let assets = get_miles s k in
        for i = 0 to (card assets) - 1 do
        invariant { s.mile_keys == diff (old s).mile_keys (head i assets)}
        invariant { s.removed_miles == union (old s).removed_miles (head i assets) }
        (* just repeat storage invariants *)
        invariant { forall k : key. mem k s.mile_keys -> amount (get s.mile_assets k) > 0  }
        invariant { 
        (* for remove mile pre-condition *)
            mem (nth i assets) s.mile_keys -> forall x : Tr.trace.
            Mem.mem x (s.tr_ ++ Tr.mk_trace s.ename_ (Tr.Rm Mile)) ->
            Mem.mem (Tr.action x) (Cons (Tr.Rm Mile) Nil) ->
            Mem.mem (Tr.entry x) (Cons (Some Consume) (Cons (Some ClearExpired) Nil))
        }
        invariant { 
        (* repeat invariant ? *)
            forall x : Tr.trace.
            Mem.mem x s.tr_ ->
            Mem.mem (Tr.action x) (Cons (Tr.Rm Mile) Nil) ->
            Mem.mem (Tr.entry x) (Cons (Some Consume) (Cons (Some ClearExpired) Nil))
        }
            let ak = nth i assets in
            remove_mile s ak
        done
    
end

module Miles_with_expiration

    use archetype.Lib
    use Miles_with_expiration_storage
    
    let add (s : storage) (ow : key) (newmile : mile) : transfers
    raises { NotFound, InvalidCaller, InvalidCondition, KeyExist }
    requires { s.ename_ = Some Add }
    =
      if not (lmem (get_caller_ s) (Cons s.admin Nil)) then raise InvalidCaller;
      if not (amount newmile > 0) then raise InvalidCondition;
      (if mem ow s.owner_keys then
        let owner = get s.owner_assets ow in
        add_owner_miles s owner newmile
      else
        let new_owner = { addr = ow; miles = mkacol (Cons (id newmile) Nil); } in
        let assets = Cons newmile Nil in
        add_owner s new_owner assets);
      no_transfer

    let consume (s : storage) (ow : address) (nbmiles : int) : transfers
    raises { NotFound, KeyExist, InvalidCaller, InvalidCondition }
    requires { s.ename_ = Some Consume }
    requires { is_empty s.removed_miles }
    requires { is_empty s.added_miles }
    (* forall m : removed miles, m.expiration > now *)
    ensures { forall m : key.
       (* note that expiration of *removed* asset is done on old storage ! *)
       mem m s.removed_miles ->  get_expiration (old s) m > (get_now_ s)
    }
    (* mile.sum(quantity) = before miles.sum(quantity) - nbmiles *)
    ensures { Amounts.sum (old s) (old s).mile_keys = Amounts.sum s s.mile_keys + nbmiles }
    (* is_emtpy add.miles *)
    ensures { is_empty s.added_miles }
    = if not (lmem (get_caller_ s) (Cons s.admin Nil)) then raise InvalidCaller;
      if nbmiles <= 0 then raise InvalidCondition;
      let o = get_owner s ow in
      let miles = get_miles s o in
      let l = filter_consume s miles in
      (*let l = FConsume.filter e s miles in*)
      if not (nbmiles <= Amounts.sum s l) then raise InvalidCondition;
      let remainder = ref nbmiles in
      try
        for i = 0 to (card l) - 1 do  
        (* removed miles are in l: *)
        invariant { subset s.removed_miles l }
        (* remainder bounds: *)
        invariant { 0 <= !remainder <= Amounts.sum s (tail i l) }
        (* right amount spent invariant *)
        invariant { Amounts.sum (old s) (old s).mile_keys = Amounts.sum s s.mile_keys + nbmiles - !remainder }
          let m = nth i l in
          if get_amount s m > !remainder
          then
            (let new_mile = { (get s.mile_assets m) with
                amount = get_amount s m - !remainder; 
             } in
             update_mile s m new_mile;
             remainder := 0;
             raise Break)
          else if get_amount s m = !remainder
          then
            (remainder := 0;
             remove_owner_miles s o m;
             raise Break)
          else
            (remainder := !remainder - get_amount s m;
             remove_owner_miles s o m)
        done;
      with Break -> assert { !remainder = 0 }; ()
      end;
      assert { !remainder = 0 };
      no_transfer

    let clear_expired (s : storage) : transfers
    raises { NotFound, KeyExist, InvalidCaller }
    requires { s.ename_ = Some ClearExpired }
    requires { is_empty s.added_miles }
    requires { is_empty s.removed_owner }
    requires { is_empty s.removed_miles }
    ensures { forall m : key. mem m s.removed_miles -> get_expiration s m < get_now_ s }
    = if not (lmem (get_caller_ s) (Cons s.admin Nil)) then raise InvalidCaller;
      for i = 0 to (card s.owner_keys)-1 do
      invariant { forall m : key. mem m s.removed_miles -> get_expiration s m < get_now_ s }
        let o = nth i s.owner_keys in
        let miles = get_miles s o in
        let l = filter_clear_expired s miles in
        label Internal_loop in
        for j = 0 to (card l) - 1 do
        (* repeat storage invariants *)
        invariant { forall k : key. mem k s.mile_keys -> amount (get s.mile_assets k) > 0 }
        invariant { 
            forall x : Tr.trace.
            Mem.mem x s.tr_ ->
            Mem.mem (Tr.action x) (Cons (Tr.Rm Mile) Nil) ->
            Mem.mem (Tr.entry x) (Cons (Some Consume) (Cons (Some ClearExpired) Nil))
        }
        invariant { s.removed_miles == union (s at Internal_loop).removed_miles (head j l) }
          let m = nth j l in
          remove_owner_miles s o m;
        done;
      done;
      no_transfer

end