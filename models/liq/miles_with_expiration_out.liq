(* Liquidity output generated by archetype *)

(* contract: miles_with_expiration *)

type mile = {
  id : string;
  amount : int;
  expiration : timestamp;
}

type owner = {
  addr : key_hash;
  miles : string list;
}

type storage = {
  admin : address;
  mile_keys: string list;
  mile_assets: (string, mile) map;
  owner_keys: key_hash list;
  owner_assets: (key_hash, owner) map;
}

let%init initialize = {
  admin = (tz1aazS5ms5cbGkb6FN1wvWmN7yrMTTcr6wB : address);
  mile_keys = [];
  mile_assets = (Map : (string, mile) map);
  owner_keys = [];
  owner_assets = (Map : (key_hash, owner) map);
}

(* Utils *)

let add_list elt l = elt::l

let remove_list elt l =
  List.fold (fun (x, accu) ->
      if x = elt
      then accu
      else add_list elt accu
    ) [] l


(* API function *)
let[@inline] get_mile (s, key : storage * string) : mile =
  match Map.find key s.mile_assets with
  | Some v -> v
  | _ -> failwith "not_found"

let[@inline] set_mile (s, key, asset : storage * string * mile) : storage =
  s.mile_assets <- Map.update key (Some asset) s.mile_assets

let[@inline] add_mile (s, asset : storage * mile) : storage =
  let key = asset.id in
  let s = s.mile_keys <- add_list key s.mile_keys in
  s.mile_assets <- Map.update key (Some asset) s.mile_assets

let[@inline] remove_mile (s, key : storage * string) : storage =
  let s = s.mile_keys <- remove_list key s.mile_keys in
  s.mile_assets <- Map.update key None s.mile_assets

let[@inline] select_mile (s, c, p : storage * string list * (mile -> bool)) : mile list =
  List.fold (fun (x, accu) ->
      let a = get_mile (s, x) in
      if p a
      then add_list a accu
      else accu
    ) c []

let[@inline] sum_mile_amount (s : storage) : int =
  Map.fold (fun (x, accu) ->
      accu + x.(1).amount
    ) s.mile_assets 0

let[@inline] get_owner (s, key : storage * key_hash) : owner =
  match Map.find key s.owner_assets with
  | Some v -> v
  | _ -> failwith "not_found"

let[@inline] add_owner (s, asset : storage * owner) : storage =
  let key = asset.addr in
  let s = s.owner_keys <- add_list key s.owner_keys in
  s.owner_assets <- Map.update key (Some asset) s.owner_assets

let[@inline] add_owner_miles (s, a, b : storage * owner * mile) : storage =
  let asset = a.miles <- add_list b.id a.miles in
  s.owner_assets <- Map.update a.addr (Some asset) s.owner_assets

let[@inline] remove_owner_miles (s, a, key : storage * owner * string) : storage =
  let asset = a.miles <- remove_list key a.miles in
  s.owner_assets <- Map.update a.addr (Some asset) s.owner_assets

let[@inline] contains_owner ((l, key) : key_hash list * key_hash) : bool =
  List.fold (fun (x, accu) ->
      accu || x = key
    ) l false



let add_shallow_owner (_s, owner, owner_miles : storage * owner * mile list) : storage =
  let _s : storage = add_owner (_s, owner) in
  List.fold (fun (mile, (_s)) ->
      add_mile (_s, mile)) owner_miles (_s)


let%entry add (ow, newmile : key_hash * mile) (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  let _s : storage = if not (Current.sender() = _s.admin)
    then Current.failwith "not_authorized_fun";
    if not (Current.amount() = 0tz)
    then Current.failwith "not_accept_transfer";
    if not (newmile.amount > 0)
    then Current.failwith "require c1 failed";
    if contains_owner (_s.owner_keys, ow)
    then add_owner_miles (_s, get_owner (_s, ow), newmile)
    else add_shallow_owner (_s, {addr = ow; miles = [newmile.id]}, [newmile]) in
  (_ops, _s)

let%entry consume (a, quantity : key_hash * int) (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  let (_s, remainder) : storage * int = if not (Current.sender() = _s.admin)
    then Current.failwith "not_authorized_fun";
    if not (Current.amount() = 0tz)
    then Current.failwith "not_accept_transfer";
    let ow : owner = get_owner (_s, a) in
    let by_expiration : mile list = select_mile (_s, ow.miles, fun the -> the.expiration > Current.time()) in
    if not (sum_mile_amount (_s) >= quantity)
    then Current.failwith "required";
    let remainder : int = quantity in
    List.fold (fun (m, (_s, remainder)) ->
        let (_s, remainder) : storage * int = if remainder > 0
          then let (_s, remainder) : storage * int = if m.amount > remainder
                 then let _s : storage = let remainder : int = 0 in
                        let _k = m.id in
                        let _mile : mile = get_mile (_s, _k) in
                        let _mile : mile = {id = _mile.id; amount = _mile.amount - remainder; expiration = _mile.expiration} in
                        set_mile (_s, _k, _mile) in
                   (_s, remainder)
                 else let (_s, remainder) : storage * int = if m.amount = remainder
                        then let (_s, remainder) : storage * int =
                               let remainder : int = 0 in
                               let _s : storage = remove_owner_miles (_s, ow, m.id) in
                               (_s, remainder) in
                          (_s, remainder)
                        else let (_s, remainder) : storage * int =
                               let remainder : int = m.amount in
                               let _s : storage = remove_owner_miles (_s, ow, m.id) in
                               (_s, remainder)
                          in
                          (_s, remainder) in
                   (_s, remainder) in
            (_s, remainder)
          else (_s, remainder) in
        (_s, remainder)) by_expiration (_s, remainder)
  in
  (_ops, _s)

let%entry clear_expired () (_s : storage) : operation list * storage =
  let _ops : operation list = [] in
  let _s : storage = if not (Current.sender() = _s.admin)
    then Current.failwith "not_authorized_fun";
    if not (Current.amount() = 0tz)
    then Current.failwith "not_accept_transfer";
    List.fold (fun (o, (_s)) ->
        let o : owner = get_owner (_s, o) in
        let _assets : mile list = select_mile (_s, o.miles, fun the -> the.expiration < Current.time()) in
        List.fold (fun (_mile, (_s)) ->
            remove_mile (_s, _mile.id)) _assets (_s)
      ) _s.owner_keys (_s)
  in
  (_ops, _s)
