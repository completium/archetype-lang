theory Int

  use export int.Int

  val int_eq int int : bool
  val int_nq int int : bool
  val int_ge int int : bool
  val int_le int int : bool
  val int_gt int int : bool
  val int_lt int int : bool

  val toint int : int

end

theory Nat

  use int.Int

  type nat

  val nat_eq nat nat : bool
  val nat_nq nat nat : bool

  val nat_ge nat nat : bool
  val nat_le nat nat : bool
  val nat_gt nat nat : bool
  val nat_lt nat nat : bool

  val nat_plus  nat nat : nat
  val nat_sub (nat, nat) : nat

  val nat_zero () : nat
  val nat_one  () : nat

  val tonat Int.int : nat

end

theory Address

  type address

  val toaddress address : address
  val mkaddress unit : address

  val add_eq address address : bool
  val add_nq address address : bool

  val default_address : address

end

theory Timestamp

  type timestamp

  val mktimestamp unit : timestamp

  val tim_eq timestamp timestamp : bool
  val tim_nq timestamp timestamp : bool

  val tim_ge timestamp timestamp : bool
  val tim_le timestamp timestamp : bool
  val tim_gt timestamp timestamp : bool
  val tim_lt timestamp timestamp : bool

end

theory Tez

  use int.Int

  type tez

  val totez int : tez

end

theory String

  type string

  val str_eq string string : bool

end

theory Utils

  use int.Int
  use list.List

  val sort ((('a , 'a) -> int) , list 'a) : list 'a

  (* tuple *)
  let get_0_2 (v : ('a , 'b)) : 'a = let (a,_) = v in a
  let get_1_2 (v : ('a , 'b)) : 'b = let (_,b) = v in b

  let get_0_3 (v : ('a , 'b , 'c)) : 'a = let (a,_,_) = v in a
  let get_1_3 (v : ('a , 'b , 'c)) : 'b = let (_,b,_) = v in b
  let get_2_3 (v : ('a , 'b , 'c)) : 'c = let (_,_,c) = v in c

  let get_0_4 (v : ('a , 'b , 'c , 'd)) : 'a = let (a,_,_,_) = v in a
  let get_1_4 (v : ('a , 'b , 'c , 'd)) : 'b = let (_,b,_,_) = v in b
  let get_2_4 (v : ('a , 'b , 'c , 'd)) : 'c = let (_,_,c,_) = v in c
  let get_3_4 (v : ('a , 'b , 'c , 'd)) : 'd = let (_,_,_,d) = v in d

  let get_0_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'a = let (a,_,_,_,_) = v in a
  let get_1_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'b = let (_,b,_,_,_) = v in b
  let get_2_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'c = let (_,_,c,_,_) = v in c
  let get_3_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'd = let (_,_,_,d,_) = v in d
  let get_4_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'e = let (_,_,_,_,e) = v in e

  let get_0_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'a = let (a,_,_,_,_,_) = v in a
  let get_1_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'b = let (_,b,_,_,_,_) = v in b
  let get_2_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'c = let (_,_,c,_,_,_) = v in c
  let get_3_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'd = let (_,_,_,d,_,_) = v in d
  let get_4_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'e = let (_,_,_,_,e,_) = v in e
  let get_5_6 (v : ('a , 'b , 'c , 'd , 'e, 'f)) : 'f = let (_,_,_,_,_,f) = v in f

  let get_0_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'a = let (a,_,_,_,_,_,_) = v in a
  let get_1_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'b = let (_,b,_,_,_,_,_) = v in b
  let get_2_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'c = let (_,_,c,_,_,_,_) = v in c
  let get_3_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'd = let (_,_,_,d,_,_,_) = v in d
  let get_4_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'e = let (_,_,_,_,e,_,_) = v in e
  let get_5_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'f = let (_,_,_,_,_,f,_) = v in f
  let get_6_7 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g)) : 'g = let (_,_,_,_,_,_,g) = v in g

  let get_0_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'a = let (a,_,_,_,_,_,_,_) = v in a
  let get_1_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'b = let (_,b,_,_,_,_,_,_) = v in b
  let get_2_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'c = let (_,_,c,_,_,_,_,_) = v in c
  let get_3_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'd = let (_,_,_,d,_,_,_,_) = v in d
  let get_4_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'e = let (_,_,_,_,e,_,_,_) = v in e
  let get_5_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'f = let (_,_,_,_,_,f,_,_) = v in f
  let get_6_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'g = let (_,_,_,_,_,_,g,_) = v in g
  let get_7_8 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h)) : 'h = let (_,_,_,_,_,_,_,h) = v in h

  let get_0_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'a = let (a,_,_,_,_,_,_,_,_) = v in a
  let get_1_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'b = let (_,b,_,_,_,_,_,_,_) = v in b
  let get_2_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'c = let (_,_,c,_,_,_,_,_,_) = v in c
  let get_3_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'd = let (_,_,_,d,_,_,_,_,_) = v in d
  let get_4_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'e = let (_,_,_,_,e,_,_,_,_) = v in e
  let get_5_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'f = let (_,_,_,_,_,f,_,_,_) = v in f
  let get_6_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'g = let (_,_,_,_,_,_,g,_,_) = v in g
  let get_7_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'h = let (_,_,_,_,_,_,_,h,_) = v in h
  let get_8_9 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i)) : 'i = let (_,_,_,_,_,_,_,_,i) = v in i

  let get_0_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'a = let (a,_,_,_,_,_,_,_,_,_) = v in a
  let get_1_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'b = let (_,b,_,_,_,_,_,_,_,_) = v in b
  let get_2_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'c = let (_,_,c,_,_,_,_,_,_,_) = v in c
  let get_3_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'd = let (_,_,_,d,_,_,_,_,_,_) = v in d
  let get_4_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'e = let (_,_,_,_,e,_,_,_,_,_) = v in e
  let get_5_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'f = let (_,_,_,_,_,f,_,_,_,_) = v in f
  let get_6_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'g = let (_,_,_,_,_,_,g,_,_,_) = v in g
  let get_7_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'h = let (_,_,_,_,_,_,_,h,_,_) = v in h
  let get_8_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'i = let (_,_,_,_,_,_,_,_,i,_) = v in i
  let get_9_10 (v : ('a , 'b , 'c , 'd , 'e, 'f, 'g, 'h, 'i, 'j)) : 'j = let (_,_,_,_,_,_,_,_,_,j) = v in j

  (* storage update *)
  val update_storage 's 'a 'a : 's
  val update_simple 's 'a : 's

end

theory Msg

  type msg

  val not_found          unit : msg
  val not_supported_yet  unit : msg
  val already_exists     unit : msg
  val not_authorized_fun unit : msg

end

theory Current

  use Address
  use Timestamp
  use Msg

  val sender   unit   : address
  val time     unit   : timestamp

  exception Side

  val failwith msg  : 'a raises { Side }

  let get_caller = sender

  let now = time

end

theory List

  use export list.List
  use option.Option

  use Nat

  val mem ('a, list 'a) : option 'a

  val add ('a, list 'a) : list 'a

  val remove ('a, list 'a) : list 'a

  val append (list 'a, list 'a) : list 'a

  val fold (('e, 'acc) -> 'acc) (list 'e) 'acc : 'acc

  val list_when ('s, ('s , 'a) -> bool, list 'a) : list 'a

  val sum_nat ('s, ('s , 'a) -> nat, list 'a) : nat

end

module Types

  use export Int
  use export Nat
  use export String
  use export Timestamp
  use export Tez
  use export Address
  use export List

end

theory Map

  use option.Option

  use Types

  type map 'a 'b

  val find 'a (map 'a 'b) : option 'b

  val mem 'a (map 'a 'b) : bool

  val add 'a 'b (map 'a 'b) : map 'a 'b

  val remove 'a (map 'a 'b) : map 'a 'b

  val update 'a (option 'b) (map 'a 'b) : map 'a 'b

  val empty_map unit : map 'a 'b

end

theory Set

  use Types

  type set 'a

  val mem 'a (set 'a) : bool

  val add 'a (set 'a) : set 'a

  val remove 'a (set 'a) : set 'a

  val empty_set unit : set 'a

end


theory Contract

  use list.List

  use Address
  use Tez

  type operation = {
     destination : address;
     amount      : tez;
 }

 let empty_ops : list operation = Nil

end
