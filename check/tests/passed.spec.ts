/* DO NOT EDIT, GENERATED FILE */
import { expect_to_fail, get_account, get_chain_id, get_mockup_level, get_mockup_now, pack, register_global_constant, set_mockup, set_mockup_now, set_quiet } from '@completium/experiment-ts';
import { Address, Bytes, Chain_id, Chest, Chest_key, Duration, Int, Key_hash, Micheline, MichelineType, Nat, Option, Or, Rational, Sapling_state, Sapling_transaction, Tez, Ticket, Unit } from '@completium/archetype-ts-types';

import assert from 'assert'
import { BigNumber } from 'bignumber.js'

import * as add_update_record from '../bindings/passed/add_update_record'
import * as addupdate_partition from '../bindings/passed/addupdate_partition'
import * as addupdate_partition2 from '../bindings/passed/addupdate_partition2'
import * as addupdate_partition_with_no_effect_on_default_value from '../bindings/passed/addupdate_partition_with_no_effect_on_default_value'
import * as addupdate_with_no_effect_on_default_value from '../bindings/passed/addupdate_with_no_effect_on_default_value'
import * as annot_enum from '../bindings/passed/annot_enum'
import * as apply_lambda from '../bindings/passed/apply_lambda'
import * as arg_fun_constant from '../bindings/passed/arg_fun_constant'
import * as arith_bls from '../bindings/passed/arith_bls'
import * as arith_tez from '../bindings/passed/arith_tez'
import * as ascii_string from '../bindings/passed/ascii_string'
import * as asset_access from '../bindings/passed/asset_access'
import * as asset_access_basic from '../bindings/passed/asset_access_basic'
import * as asset_access_option_found from '../bindings/passed/asset_access_option_found'
import * as asset_access_option_not_found from '../bindings/passed/asset_access_option_not_found'
import * as asset_access_value from '../bindings/passed/asset_access_value'
import * as asset_addupdate from '../bindings/passed/asset_addupdate'
import * as asset_big_map from '../bindings/passed/asset_big_map'
import * as asset_big_map_unit_effect_add from '../bindings/passed/asset_big_map_unit_effect_add'
import * as asset_big_map_unit_effect_addupdate from '../bindings/passed/asset_big_map_unit_effect_addupdate'
import * as asset_big_map_unit_effect_remove from '../bindings/passed/asset_big_map_unit_effect_remove'
import * as asset_big_map_unit_effect_removeall from '../bindings/passed/asset_big_map_unit_effect_removeall'
import * as asset_big_map_unit_effect_update from '../bindings/passed/asset_big_map_unit_effect_update'
import * as asset_big_map_unit_expression_contains from '../bindings/passed/asset_big_map_unit_expression_contains'
import * as asset_big_map_unit_storage from '../bindings/passed/asset_big_map_unit_storage'
import * as asset_for from '../bindings/passed/asset_for'
import * as asset_init_by_const_key from '../bindings/passed/asset_init_by_const_key'
import * as asset_init_by_const_key_parameter from '../bindings/passed/asset_init_by_const_key_parameter'
import * as asset_initializedby_aggregate_empty from '../bindings/passed/asset_initializedby_aggregate_empty'
import * as asset_initializedby_aggregate_filled from '../bindings/passed/asset_initializedby_aggregate_filled'
import * as asset_instructions from '../bindings/passed/asset_instructions'
import * as asset_iterable_big_map from '../bindings/passed/asset_iterable_big_map'
import * as asset_iterable_big_map_effect_add from '../bindings/passed/asset_iterable_big_map_effect_add'
import * as asset_iterable_big_map_effect_addupdate from '../bindings/passed/asset_iterable_big_map_effect_addupdate'
import * as asset_iterable_big_map_effect_remove from '../bindings/passed/asset_iterable_big_map_effect_remove'
import * as asset_iterable_big_map_effect_removeall from '../bindings/passed/asset_iterable_big_map_effect_removeall'
import * as asset_iterable_big_map_effect_removeif from '../bindings/passed/asset_iterable_big_map_effect_removeif'
import * as asset_iterable_big_map_effect_update from '../bindings/passed/asset_iterable_big_map_effect_update'
import * as asset_iterable_big_map_expression_contains from '../bindings/passed/asset_iterable_big_map_expression_contains'
import * as asset_iterable_big_map_expression_count from '../bindings/passed/asset_iterable_big_map_expression_count'
import * as asset_iterable_big_map_expression_get from '../bindings/passed/asset_iterable_big_map_expression_get'
import * as asset_iterable_big_map_expression_head from '../bindings/passed/asset_iterable_big_map_expression_head'
import * as asset_iterable_big_map_expression_nth from '../bindings/passed/asset_iterable_big_map_expression_nth'
import * as asset_iterable_big_map_expression_select from '../bindings/passed/asset_iterable_big_map_expression_select'
import * as asset_iterable_big_map_expression_sort from '../bindings/passed/asset_iterable_big_map_expression_sort'
import * as asset_iterable_big_map_expression_sum from '../bindings/passed/asset_iterable_big_map_expression_sum'
import * as asset_iterable_big_map_expression_tail from '../bindings/passed/asset_iterable_big_map_expression_tail'
import * as asset_iterable_big_map_instruction_for from '../bindings/passed/asset_iterable_big_map_instruction_for'
import * as asset_iterable_big_map_multi_effect_add from '../bindings/passed/asset_iterable_big_map_multi_effect_add'
import * as asset_iterable_big_map_multi_effect_addupdate from '../bindings/passed/asset_iterable_big_map_multi_effect_addupdate'
import * as asset_iterable_big_map_multi_effect_remove from '../bindings/passed/asset_iterable_big_map_multi_effect_remove'
import * as asset_iterable_big_map_multi_effect_removeall from '../bindings/passed/asset_iterable_big_map_multi_effect_removeall'
import * as asset_iterable_big_map_multi_effect_removeif from '../bindings/passed/asset_iterable_big_map_multi_effect_removeif'
import * as asset_iterable_big_map_multi_effect_update from '../bindings/passed/asset_iterable_big_map_multi_effect_update'
import * as asset_iterable_big_map_multi_expression_contains from '../bindings/passed/asset_iterable_big_map_multi_expression_contains'
import * as asset_iterable_big_map_multi_expression_count from '../bindings/passed/asset_iterable_big_map_multi_expression_count'
import * as asset_iterable_big_map_multi_expression_get from '../bindings/passed/asset_iterable_big_map_multi_expression_get'
import * as asset_iterable_big_map_multi_expression_head from '../bindings/passed/asset_iterable_big_map_multi_expression_head'
import * as asset_iterable_big_map_multi_expression_nth from '../bindings/passed/asset_iterable_big_map_multi_expression_nth'
import * as asset_iterable_big_map_multi_expression_select from '../bindings/passed/asset_iterable_big_map_multi_expression_select'
import * as asset_iterable_big_map_multi_expression_sort from '../bindings/passed/asset_iterable_big_map_multi_expression_sort'
import * as asset_iterable_big_map_multi_expression_sum from '../bindings/passed/asset_iterable_big_map_multi_expression_sum'
import * as asset_iterable_big_map_multi_expression_tail from '../bindings/passed/asset_iterable_big_map_multi_expression_tail'
import * as asset_iterable_big_map_multi_instruction_for from '../bindings/passed/asset_iterable_big_map_multi_instruction_for'
import * as asset_iterable_big_map_multi_storage from '../bindings/passed/asset_iterable_big_map_multi_storage'
import * as asset_iterable_big_map_storage from '../bindings/passed/asset_iterable_big_map_storage'
import * as asset_iterable_big_map_unit from '../bindings/passed/asset_iterable_big_map_unit'
import * as asset_iterable_big_map_unit_effect_add from '../bindings/passed/asset_iterable_big_map_unit_effect_add'
import * as asset_iterable_big_map_unit_effect_addupdate from '../bindings/passed/asset_iterable_big_map_unit_effect_addupdate'
import * as asset_iterable_big_map_unit_effect_remove from '../bindings/passed/asset_iterable_big_map_unit_effect_remove'
import * as asset_iterable_big_map_unit_effect_removeall from '../bindings/passed/asset_iterable_big_map_unit_effect_removeall'
import * as asset_iterable_big_map_unit_effect_removeif from '../bindings/passed/asset_iterable_big_map_unit_effect_removeif'
import * as asset_iterable_big_map_unit_effect_update from '../bindings/passed/asset_iterable_big_map_unit_effect_update'
import * as asset_iterable_big_map_unit_expression_contains from '../bindings/passed/asset_iterable_big_map_unit_expression_contains'
import * as asset_iterable_big_map_unit_expression_count from '../bindings/passed/asset_iterable_big_map_unit_expression_count'
import * as asset_iterable_big_map_unit_expression_head from '../bindings/passed/asset_iterable_big_map_unit_expression_head'
import * as asset_iterable_big_map_unit_expression_nth from '../bindings/passed/asset_iterable_big_map_unit_expression_nth'
import * as asset_iterable_big_map_unit_expression_select from '../bindings/passed/asset_iterable_big_map_unit_expression_select'
import * as asset_iterable_big_map_unit_expression_sort from '../bindings/passed/asset_iterable_big_map_unit_expression_sort'
import * as asset_iterable_big_map_unit_expression_sum from '../bindings/passed/asset_iterable_big_map_unit_expression_sum'
import * as asset_iterable_big_map_unit_expression_tail from '../bindings/passed/asset_iterable_big_map_unit_expression_tail'
import * as asset_iterable_big_map_unit_instruction_for from '../bindings/passed/asset_iterable_big_map_unit_instruction_for'
import * as asset_iterable_big_map_unit_storage from '../bindings/passed/asset_iterable_big_map_unit_storage'
import * as asset_key_in_record from '../bindings/passed/asset_key_in_record'
import * as asset_key_tuple from '../bindings/passed/asset_key_tuple'
import * as asset_not_found from '../bindings/passed/asset_not_found'
import * as asset_nth from '../bindings/passed/asset_nth'
import * as asset_put_single from '../bindings/passed/asset_put_single'
import * as asset_simple from '../bindings/passed/asset_simple'
import * as asset_simple_to_big_map from '../bindings/passed/asset_simple_to_big_map'
import * as asset_simple_to_iterable_big_map from '../bindings/passed/asset_simple_to_iterable_big_map'
import * as asset_tern_opt from '../bindings/passed/asset_tern_opt'
import * as asset_ternary_expr_found from '../bindings/passed/asset_ternary_expr_found'
import * as asset_ternary_expr_notfound from '../bindings/passed/asset_ternary_expr_notfound'
import * as asset_types_get from '../bindings/passed/asset_types_get'
import * as asset_update_with_basic_container_map_lit_add from '../bindings/passed/asset_update_with_basic_container_map_lit_add'
import * as asset_update_with_basic_container_map_lit_remove from '../bindings/passed/asset_update_with_basic_container_map_lit_remove'
import * as asset_update_with_basic_container_map_var_list_add from '../bindings/passed/asset_update_with_basic_container_map_var_list_add'
import * as asset_update_with_basic_container_map_var_list_remove from '../bindings/passed/asset_update_with_basic_container_map_var_list_remove'
import * as asset_update_with_basic_container_map_var_set_add from '../bindings/passed/asset_update_with_basic_container_map_var_set_add'
import * as asset_update_with_basic_container_map_var_set_remove from '../bindings/passed/asset_update_with_basic_container_map_var_set_remove'
import * as asset_update_with_basic_container_set_lit_add from '../bindings/passed/asset_update_with_basic_container_set_lit_add'
import * as asset_update_with_basic_container_set_lit_remove from '../bindings/passed/asset_update_with_basic_container_set_lit_remove'
import * as asset_update_with_basic_container_set_var_list_add from '../bindings/passed/asset_update_with_basic_container_set_var_list_add'
import * as asset_update_with_basic_container_set_var_list_remove from '../bindings/passed/asset_update_with_basic_container_set_var_list_remove'
import * as asset_update_with_basic_container_set_var_set_add from '../bindings/passed/asset_update_with_basic_container_set_var_set_add'
import * as asset_update_with_basic_container_set_var_set_remove from '../bindings/passed/asset_update_with_basic_container_set_var_set_remove'
import * as assign_add_record from '../bindings/passed/assign_add_record'
import * as assign_add_tuple from '../bindings/passed/assign_add_tuple'
import * as assign_field from '../bindings/passed/assign_field'
import * as assign_minus_nat from '../bindings/passed/assign_minus_nat'
import * as assign_opt from '../bindings/passed/assign_opt'
import * as assign_var_rat_int from '../bindings/passed/assign_var_rat_int'
import * as assign_vardecl_rat_int from '../bindings/passed/assign_vardecl_rat_int'
import * as assign_vardecl_rat_nat from '../bindings/passed/assign_vardecl_rat_nat'
import * as before_asset_api from '../bindings/passed/before_asset_api'
import * as before_var from '../bindings/passed/before_var'
import * as bls_lit from '../bindings/passed/bls_lit'
import * as builtin_in_function from '../bindings/passed/builtin_in_function'
import * as called_by_an_asset from '../bindings/passed/called_by_an_asset'
import * as cast from '../bindings/passed/cast'
import * as cast_dur_int from '../bindings/passed/cast_dur_int'
import * as cast_nat_int from '../bindings/passed/cast_nat_int'
import * as cast_nat_int_lit from '../bindings/passed/cast_nat_int_lit'
import * as cast_return from '../bindings/passed/cast_return'
import * as cast_view_pklist from '../bindings/passed/cast_view_pklist'
import * as col_iter_direct_storage from '../bindings/passed/col_iter_direct_storage'
import * as col_iter_filter_storage from '../bindings/passed/col_iter_filter_storage'
import * as compare_enum from '../bindings/passed/compare_enum'
import * as const_decl from '../bindings/passed/const_decl'
import * as containers_of_tuple from '../bindings/passed/containers_of_tuple'
import * as contract_called from '../bindings/passed/contract_called'
import * as contract_caller from '../bindings/passed/contract_caller'
import * as contract_empty from '../bindings/passed/contract_empty'
import * as contract_to_address from '../bindings/passed/contract_to_address'
import * as contract_transition from '../bindings/passed/contract_transition'
import * as counter from '../bindings/passed/counter'
import * as counter_proxy from '../bindings/passed/counter_proxy'
import * as custom_args_with_record from '../bindings/passed/custom_args_with_record'
import * as custom_storage from '../bindings/passed/custom_storage'
import * as custom_storage10 from '../bindings/passed/custom_storage10'
import * as custom_storage2 from '../bindings/passed/custom_storage2'
import * as custom_storage3 from '../bindings/passed/custom_storage3'
import * as custom_storage4 from '../bindings/passed/custom_storage4'
import * as custom_storage5 from '../bindings/passed/custom_storage5'
import * as custom_storage6 from '../bindings/passed/custom_storage6'
import * as custom_storage7 from '../bindings/passed/custom_storage7'
import * as custom_storage8 from '../bindings/passed/custom_storage8'
import * as custom_storage9 from '../bindings/passed/custom_storage9'
import * as dangling_else from '../bindings/passed/dangling_else'
import * as debug_assign from '../bindings/passed/debug_assign'
import * as dec_lit from '../bindings/passed/dec_lit'
import * as decl_var_opt from '../bindings/passed/decl_var_opt'
import * as decl_var_opt_default from '../bindings/passed/decl_var_opt_default'
import * as decomp_if from '../bindings/passed/decomp_if'
import * as decomp_if2 from '../bindings/passed/decomp_if2'
import * as decomp_if3 from '../bindings/passed/decomp_if3'
import * as decomp_if4 from '../bindings/passed/decomp_if4'
import * as decomp_ifexpr from '../bindings/passed/decomp_ifexpr'
import * as decomp_map from '../bindings/passed/decomp_map'
import * as decomp_test from '../bindings/passed/decomp_test'
import * as decomp_test2 from '../bindings/passed/decomp_test2'
import * as decomp_while from '../bindings/passed/decomp_while'
import * as decomp_while1 from '../bindings/passed/decomp_while1'
import * as decomp_while2 from '../bindings/passed/decomp_while2'
import * as detach_big_map_string from '../bindings/passed/detach_big_map_string'
import * as detach_big_map_unit from '../bindings/passed/detach_big_map_unit'
import * as detach_map_string from '../bindings/passed/detach_map_string'
import * as detach_option_string from '../bindings/passed/detach_option_string'
import * as duration_to_int from '../bindings/passed/duration_to_int'
import * as effect_add_asset_with_complex_partition from '../bindings/passed/effect_add_asset_with_complex_partition'
import * as effect_control_for_aggregate from '../bindings/passed/effect_control_for_aggregate'
import * as effect_control_for_collection from '../bindings/passed/effect_control_for_collection'
import * as effect_control_for_collection_one_field from '../bindings/passed/effect_control_for_collection_one_field'
import * as effect_control_for_list from '../bindings/passed/effect_control_for_list'
import * as effect_control_for_map from '../bindings/passed/effect_control_for_map'
import * as effect_control_for_partition from '../bindings/passed/effect_control_for_partition'
import * as effect_control_for_set from '../bindings/passed/effect_control_for_set'
import * as effect_control_for_view from '../bindings/passed/effect_control_for_view'
import * as effect_control_if from '../bindings/passed/effect_control_if'
import * as effect_control_if_else from '../bindings/passed/effect_control_if_else'
import * as effect_control_iter from '../bindings/passed/effect_control_iter'
import * as effect_control_iter_init from '../bindings/passed/effect_control_iter_init'
import * as effect_control_match_enum from '../bindings/passed/effect_control_match_enum'
import * as effect_control_match_list from '../bindings/passed/effect_control_match_list'
import * as effect_control_match_option from '../bindings/passed/effect_control_match_option'
import * as effect_control_match_option_2 from '../bindings/passed/effect_control_match_option_2'
import * as effect_control_match_or from '../bindings/passed/effect_control_match_or'
import * as effect_control_matchwith from '../bindings/passed/effect_control_matchwith'
import * as effect_control_sequence from '../bindings/passed/effect_control_sequence'
import * as effect_control_while from '../bindings/passed/effect_control_while'
import * as effect_dofailif from '../bindings/passed/effect_dofailif'
import * as effect_dorequire from '../bindings/passed/effect_dorequire'
import * as effect_dorequire_not from '../bindings/passed/effect_dorequire_not'
import * as effect_fail from '../bindings/passed/effect_fail'
import * as effect_fail_complex from '../bindings/passed/effect_fail_complex'
import * as effect_instruction_put_in_asset from '../bindings/passed/effect_instruction_put_in_asset'
import * as effect_method_asset_add_aggregate from '../bindings/passed/effect_method_asset_add_aggregate'
import * as effect_method_asset_add_asset from '../bindings/passed/effect_method_asset_add_asset'
import * as effect_method_asset_add_asset2 from '../bindings/passed/effect_method_asset_add_asset2'
import * as effect_method_asset_add_asset_one_field from '../bindings/passed/effect_method_asset_add_asset_one_field'
import * as effect_method_asset_add_asset_with_aggregate from '../bindings/passed/effect_method_asset_add_asset_with_aggregate'
import * as effect_method_asset_add_asset_with_partition from '../bindings/passed/effect_method_asset_add_asset_with_partition'
import * as effect_method_asset_add_asset_with_partition_2 from '../bindings/passed/effect_method_asset_add_asset_with_partition_2'
import * as effect_method_asset_add_partition from '../bindings/passed/effect_method_asset_add_partition'
import * as effect_method_asset_add_partition_one_field from '../bindings/passed/effect_method_asset_add_partition_one_field'
import * as effect_method_asset_addupdate from '../bindings/passed/effect_method_asset_addupdate'
import * as effect_method_asset_addupdate_partition from '../bindings/passed/effect_method_asset_addupdate_partition'
import * as effect_method_asset_addupdate_with_add_aggregate from '../bindings/passed/effect_method_asset_addupdate_with_add_aggregate'
import * as effect_method_asset_addupdate_with_add_map from '../bindings/passed/effect_method_asset_addupdate_with_add_map'
import * as effect_method_asset_addupdate_with_add_map_var from '../bindings/passed/effect_method_asset_addupdate_with_add_map_var'
import * as effect_method_asset_addupdate_with_add_partition from '../bindings/passed/effect_method_asset_addupdate_with_add_partition'
import * as effect_method_asset_addupdate_with_add_set from '../bindings/passed/effect_method_asset_addupdate_with_add_set'
import * as effect_method_asset_addupdate_with_remove_map from '../bindings/passed/effect_method_asset_addupdate_with_remove_map'
import * as effect_method_asset_addupdate_with_remove_set from '../bindings/passed/effect_method_asset_addupdate_with_remove_set'
import * as effect_method_asset_addupdate_with_replace_aggregate from '../bindings/passed/effect_method_asset_addupdate_with_replace_aggregate'
import * as effect_method_asset_addupdate_with_replace_partition from '../bindings/passed/effect_method_asset_addupdate_with_replace_partition'
import * as effect_method_asset_big_map_0_put_remove_put from '../bindings/passed/effect_method_asset_big_map_0_put_remove_put'
import * as effect_method_asset_big_map_0_put_remove_remove from '../bindings/passed/effect_method_asset_big_map_0_put_remove_remove'
import * as effect_method_asset_big_map_1_put_remove_put from '../bindings/passed/effect_method_asset_big_map_1_put_remove_put'
import * as effect_method_asset_big_map_1_put_remove_remove from '../bindings/passed/effect_method_asset_big_map_1_put_remove_remove'
import * as effect_method_asset_big_map_2_put_remove_put from '../bindings/passed/effect_method_asset_big_map_2_put_remove_put'
import * as effect_method_asset_big_map_2_put_remove_remove from '../bindings/passed/effect_method_asset_big_map_2_put_remove_remove'
import * as effect_method_asset_clear_view from '../bindings/passed/effect_method_asset_clear_view'
import * as effect_method_asset_clear_view_with_aggregate from '../bindings/passed/effect_method_asset_clear_view_with_aggregate'
import * as effect_method_asset_clear_view_with_partition from '../bindings/passed/effect_method_asset_clear_view_with_partition'
import * as effect_method_asset_map_0_put_remove_put from '../bindings/passed/effect_method_asset_map_0_put_remove_put'
import * as effect_method_asset_map_0_put_remove_remove from '../bindings/passed/effect_method_asset_map_0_put_remove_remove'
import * as effect_method_asset_map_1_put_remove_put from '../bindings/passed/effect_method_asset_map_1_put_remove_put'
import * as effect_method_asset_map_1_put_remove_remove from '../bindings/passed/effect_method_asset_map_1_put_remove_remove'
import * as effect_method_asset_map_2_put_remove_put from '../bindings/passed/effect_method_asset_map_2_put_remove_put'
import * as effect_method_asset_map_2_put_remove_remove from '../bindings/passed/effect_method_asset_map_2_put_remove_remove'
import * as effect_method_asset_remove_aggregate from '../bindings/passed/effect_method_asset_remove_aggregate'
import * as effect_method_asset_remove_all_aggregate from '../bindings/passed/effect_method_asset_remove_all_aggregate'
import * as effect_method_asset_remove_all_asset_one_field from '../bindings/passed/effect_method_asset_remove_all_asset_one_field'
import * as effect_method_asset_remove_all_asset_with_aggregate from '../bindings/passed/effect_method_asset_remove_all_asset_with_aggregate'
import * as effect_method_asset_remove_all_asset_with_partition from '../bindings/passed/effect_method_asset_remove_all_asset_with_partition'
import * as effect_method_asset_remove_all_collection from '../bindings/passed/effect_method_asset_remove_all_collection'
import * as effect_method_asset_remove_asset from '../bindings/passed/effect_method_asset_remove_asset'
import * as effect_method_asset_remove_asset2 from '../bindings/passed/effect_method_asset_remove_asset2'
import * as effect_method_asset_remove_asset_one_field from '../bindings/passed/effect_method_asset_remove_asset_one_field'
import * as effect_method_asset_remove_asset_with_aggregate from '../bindings/passed/effect_method_asset_remove_asset_with_aggregate'
import * as effect_method_asset_remove_asset_with_partition from '../bindings/passed/effect_method_asset_remove_asset_with_partition'
import * as effect_method_asset_remove_asset_with_partition_2 from '../bindings/passed/effect_method_asset_remove_asset_with_partition_2'
import * as effect_method_asset_remove_partition from '../bindings/passed/effect_method_asset_remove_partition'
import * as effect_method_asset_removeall_aggregate from '../bindings/passed/effect_method_asset_removeall_aggregate'
import * as effect_method_asset_removeall_partition from '../bindings/passed/effect_method_asset_removeall_partition'
import * as effect_method_asset_removeif_aggregate from '../bindings/passed/effect_method_asset_removeif_aggregate'
import * as effect_method_asset_removeif_collection from '../bindings/passed/effect_method_asset_removeif_collection'
import * as effect_method_asset_removeif_collection_with_aggregate from '../bindings/passed/effect_method_asset_removeif_collection_with_aggregate'
import * as effect_method_asset_removeif_collection_with_partition from '../bindings/passed/effect_method_asset_removeif_collection_with_partition'
import * as effect_method_asset_removeif_partition from '../bindings/passed/effect_method_asset_removeif_partition'
import * as effect_method_asset_update from '../bindings/passed/effect_method_asset_update'
import * as effect_method_asset_update_all_coll_1 from '../bindings/passed/effect_method_asset_update_all_coll_1'
import * as effect_method_asset_update_all_coll_2 from '../bindings/passed/effect_method_asset_update_all_coll_2'
import * as effect_method_asset_update_all_view_1 from '../bindings/passed/effect_method_asset_update_all_view_1'
import * as effect_method_asset_update_all_view_2 from '../bindings/passed/effect_method_asset_update_all_view_2'
import * as effect_method_asset_update_with_add_aggregate from '../bindings/passed/effect_method_asset_update_with_add_aggregate'
import * as effect_method_asset_update_with_add_map from '../bindings/passed/effect_method_asset_update_with_add_map'
import * as effect_method_asset_update_with_add_partition from '../bindings/passed/effect_method_asset_update_with_add_partition'
import * as effect_method_asset_update_with_add_set from '../bindings/passed/effect_method_asset_update_with_add_set'
import * as effect_method_asset_update_with_map from '../bindings/passed/effect_method_asset_update_with_map'
import * as effect_method_asset_update_with_remove_aggregate from '../bindings/passed/effect_method_asset_update_with_remove_aggregate'
import * as effect_method_asset_update_with_remove_map from '../bindings/passed/effect_method_asset_update_with_remove_map'
import * as effect_method_asset_update_with_remove_partition from '../bindings/passed/effect_method_asset_update_with_remove_partition'
import * as effect_method_asset_update_with_remove_set from '../bindings/passed/effect_method_asset_update_with_remove_set'
import * as effect_method_asset_update_with_replace_aggregate from '../bindings/passed/effect_method_asset_update_with_replace_aggregate'
import * as effect_method_asset_update_with_replace_partition from '../bindings/passed/effect_method_asset_update_with_replace_partition'
import * as effect_method_asset_update_with_set from '../bindings/passed/effect_method_asset_update_with_set'
import * as effect_transfer_contract from '../bindings/passed/effect_transfer_contract'
import * as effect_transfer_simple from '../bindings/passed/effect_transfer_simple'
import * as entry_inspector from '../bindings/passed/entry_inspector'
import * as entry_section_called_by_otherwise from '../bindings/passed/entry_section_called_by_otherwise'
import * as entry_section_no_transfer_otherwise from '../bindings/passed/entry_section_no_transfer_otherwise'
import * as entry_section_sourced_by_otherwise from '../bindings/passed/entry_section_sourced_by_otherwise'
import * as entry_section_state_is_otherwise from '../bindings/passed/entry_section_state_is_otherwise'
import * as entry_token from '../bindings/passed/entry_token'
import * as entry_without_effect from '../bindings/passed/entry_without_effect'
import * as enum_all from '../bindings/passed/enum_all'
import * as enum_key from '../bindings/passed/enum_key'
import * as enum_simple from '../bindings/passed/enum_simple'
import * as enum_with_args from '../bindings/passed/enum_with_args'
import * as enum_with_args_multi from '../bindings/passed/enum_with_args_multi'
import * as enum_without_args from '../bindings/passed/enum_without_args'
import * as event_all from '../bindings/passed/event_all'
import * as event_dup from '../bindings/passed/event_dup'
import * as event_multi from '../bindings/passed/event_multi'
import * as event_simple from '../bindings/passed/event_simple'
import * as event_single from '../bindings/passed/event_single'
import * as exec_letin from '../bindings/passed/exec_letin'
import * as expr_access_asset_field from '../bindings/passed/expr_access_asset_field'
import * as expr_arith_3wc_nat_nat from '../bindings/passed/expr_arith_3wc_nat_nat'
import * as expr_arith_and_bool_bool from '../bindings/passed/expr_arith_and_bool_bool'
import * as expr_arith_and_bytes_bytes from '../bindings/passed/expr_arith_and_bytes_bytes'
import * as expr_arith_and_int_nat from '../bindings/passed/expr_arith_and_int_nat'
import * as expr_arith_and_nat_nat from '../bindings/passed/expr_arith_and_nat_nat'
import * as expr_arith_div_dur_dur from '../bindings/passed/expr_arith_div_dur_dur'
import * as expr_arith_div_int_int from '../bindings/passed/expr_arith_div_int_int'
import * as expr_arith_div_int_nat from '../bindings/passed/expr_arith_div_int_nat'
import * as expr_arith_div_int_rat from '../bindings/passed/expr_arith_div_int_rat'
import * as expr_arith_div_nat_int from '../bindings/passed/expr_arith_div_nat_int'
import * as expr_arith_div_nat_nat from '../bindings/passed/expr_arith_div_nat_nat'
import * as expr_arith_div_nat_rat from '../bindings/passed/expr_arith_div_nat_rat'
import * as expr_arith_div_rat_int from '../bindings/passed/expr_arith_div_rat_int'
import * as expr_arith_div_rat_nat from '../bindings/passed/expr_arith_div_rat_nat'
import * as expr_arith_div_rat_rat from '../bindings/passed/expr_arith_div_rat_rat'
import * as expr_arith_div_tez_tez from '../bindings/passed/expr_arith_div_tez_tez'
import * as expr_arith_divmod_int_int from '../bindings/passed/expr_arith_divmod_int_int'
import * as expr_arith_divmod_int_nat from '../bindings/passed/expr_arith_divmod_int_nat'
import * as expr_arith_divmod_nat_int from '../bindings/passed/expr_arith_divmod_nat_int'
import * as expr_arith_divmod_nat_nat from '../bindings/passed/expr_arith_divmod_nat_nat'
import * as expr_arith_divmod_tez_nat from '../bindings/passed/expr_arith_divmod_tez_nat'
import * as expr_arith_divmod_tez_tez from '../bindings/passed/expr_arith_divmod_tez_tez'
import * as expr_arith_ediv_dur_dur from '../bindings/passed/expr_arith_ediv_dur_dur'
import * as expr_arith_ediv_dur_int from '../bindings/passed/expr_arith_ediv_dur_int'
import * as expr_arith_ediv_dur_nat from '../bindings/passed/expr_arith_ediv_dur_nat'
import * as expr_arith_ediv_int_int from '../bindings/passed/expr_arith_ediv_int_int'
import * as expr_arith_ediv_int_nat from '../bindings/passed/expr_arith_ediv_int_nat'
import * as expr_arith_ediv_nat_int from '../bindings/passed/expr_arith_ediv_nat_int'
import * as expr_arith_ediv_nat_nat from '../bindings/passed/expr_arith_ediv_nat_nat'
import * as expr_arith_ediv_tez_nat from '../bindings/passed/expr_arith_ediv_tez_nat'
import * as expr_arith_ediv_tez_tez from '../bindings/passed/expr_arith_ediv_tez_tez'
import * as expr_arith_lsl_bytes_nat from '../bindings/passed/expr_arith_lsl_bytes_nat'
import * as expr_arith_lsl_nat_nat from '../bindings/passed/expr_arith_lsl_nat_nat'
import * as expr_arith_lsr_bytes_nat from '../bindings/passed/expr_arith_lsr_bytes_nat'
import * as expr_arith_lsr_nat_nat from '../bindings/passed/expr_arith_lsr_nat_nat'
import * as expr_arith_minus_date_date from '../bindings/passed/expr_arith_minus_date_date'
import * as expr_arith_minus_date_date_neg from '../bindings/passed/expr_arith_minus_date_date_neg'
import * as expr_arith_minus_date_dur from '../bindings/passed/expr_arith_minus_date_dur'
import * as expr_arith_minus_dur_dur from '../bindings/passed/expr_arith_minus_dur_dur'
import * as expr_arith_minus_int_int from '../bindings/passed/expr_arith_minus_int_int'
import * as expr_arith_minus_int_nat from '../bindings/passed/expr_arith_minus_int_nat'
import * as expr_arith_minus_int_rat from '../bindings/passed/expr_arith_minus_int_rat'
import * as expr_arith_minus_nat_int from '../bindings/passed/expr_arith_minus_nat_int'
import * as expr_arith_minus_nat_nat from '../bindings/passed/expr_arith_minus_nat_nat'
import * as expr_arith_minus_nat_rat from '../bindings/passed/expr_arith_minus_nat_rat'
import * as expr_arith_minus_rat_int from '../bindings/passed/expr_arith_minus_rat_int'
import * as expr_arith_minus_rat_nat from '../bindings/passed/expr_arith_minus_rat_nat'
import * as expr_arith_minus_rat_rat from '../bindings/passed/expr_arith_minus_rat_rat'
import * as expr_arith_minus_tez_tez from '../bindings/passed/expr_arith_minus_tez_tez'
import * as expr_arith_mod_int_int from '../bindings/passed/expr_arith_mod_int_int'
import * as expr_arith_mod_int_nat from '../bindings/passed/expr_arith_mod_int_nat'
import * as expr_arith_mod_nat_int from '../bindings/passed/expr_arith_mod_nat_int'
import * as expr_arith_mod_nat_nat from '../bindings/passed/expr_arith_mod_nat_nat'
import * as expr_arith_mod_tez_tez from '../bindings/passed/expr_arith_mod_tez_tez'
import * as expr_arith_mult_int_dur from '../bindings/passed/expr_arith_mult_int_dur'
import * as expr_arith_mult_int_int from '../bindings/passed/expr_arith_mult_int_int'
import * as expr_arith_mult_int_nat from '../bindings/passed/expr_arith_mult_int_nat'
import * as expr_arith_mult_int_rat from '../bindings/passed/expr_arith_mult_int_rat'
import * as expr_arith_mult_int_tez from '../bindings/passed/expr_arith_mult_int_tez'
import * as expr_arith_mult_nat_dur from '../bindings/passed/expr_arith_mult_nat_dur'
import * as expr_arith_mult_nat_int from '../bindings/passed/expr_arith_mult_nat_int'
import * as expr_arith_mult_nat_nat from '../bindings/passed/expr_arith_mult_nat_nat'
import * as expr_arith_mult_nat_rat from '../bindings/passed/expr_arith_mult_nat_rat'
import * as expr_arith_mult_nat_tez from '../bindings/passed/expr_arith_mult_nat_tez'
import * as expr_arith_mult_rat_dur from '../bindings/passed/expr_arith_mult_rat_dur'
import * as expr_arith_mult_rat_int from '../bindings/passed/expr_arith_mult_rat_int'
import * as expr_arith_mult_rat_nat from '../bindings/passed/expr_arith_mult_rat_nat'
import * as expr_arith_mult_rat_rat from '../bindings/passed/expr_arith_mult_rat_rat'
import * as expr_arith_mult_rat_tez from '../bindings/passed/expr_arith_mult_rat_tez'
import * as expr_arith_mult_tez_nat from '../bindings/passed/expr_arith_mult_tez_nat'
import * as expr_arith_not_bool from '../bindings/passed/expr_arith_not_bool'
import * as expr_arith_not_bytes from '../bindings/passed/expr_arith_not_bytes'
import * as expr_arith_not_int from '../bindings/passed/expr_arith_not_int'
import * as expr_arith_not_nat from '../bindings/passed/expr_arith_not_nat'
import * as expr_arith_or_bool_bool from '../bindings/passed/expr_arith_or_bool_bool'
import * as expr_arith_or_bytes_bytes from '../bindings/passed/expr_arith_or_bytes_bytes'
import * as expr_arith_or_nat_nat from '../bindings/passed/expr_arith_or_nat_nat'
import * as expr_arith_plus_date_dur from '../bindings/passed/expr_arith_plus_date_dur'
import * as expr_arith_plus_dur_date from '../bindings/passed/expr_arith_plus_dur_date'
import * as expr_arith_plus_dur_dur from '../bindings/passed/expr_arith_plus_dur_dur'
import * as expr_arith_plus_int_int from '../bindings/passed/expr_arith_plus_int_int'
import * as expr_arith_plus_int_nat from '../bindings/passed/expr_arith_plus_int_nat'
import * as expr_arith_plus_int_rat from '../bindings/passed/expr_arith_plus_int_rat'
import * as expr_arith_plus_nat_int from '../bindings/passed/expr_arith_plus_nat_int'
import * as expr_arith_plus_nat_nat from '../bindings/passed/expr_arith_plus_nat_nat'
import * as expr_arith_plus_nat_rat from '../bindings/passed/expr_arith_plus_nat_rat'
import * as expr_arith_plus_rat_int from '../bindings/passed/expr_arith_plus_rat_int'
import * as expr_arith_plus_rat_nat from '../bindings/passed/expr_arith_plus_rat_nat'
import * as expr_arith_plus_rat_rat from '../bindings/passed/expr_arith_plus_rat_rat'
import * as expr_arith_plus_str_str from '../bindings/passed/expr_arith_plus_str_str'
import * as expr_arith_plus_tez_tez from '../bindings/passed/expr_arith_plus_tez_tez'
import * as expr_arith_uminus_int from '../bindings/passed/expr_arith_uminus_int'
import * as expr_arith_uminus_rat from '../bindings/passed/expr_arith_uminus_rat'
import * as expr_arith_xor_bool_bool from '../bindings/passed/expr_arith_xor_bool_bool'
import * as expr_arith_xor_bytes_bytes from '../bindings/passed/expr_arith_xor_bytes_bytes'
import * as expr_arith_xor_nat_nat from '../bindings/passed/expr_arith_xor_nat_nat'
import * as expr_cmp_eq_addr_addr from '../bindings/passed/expr_cmp_eq_addr_addr'
import * as expr_cmp_eq_bool_bool from '../bindings/passed/expr_cmp_eq_bool_bool'
import * as expr_cmp_eq_date_date from '../bindings/passed/expr_cmp_eq_date_date'
import * as expr_cmp_eq_dur_dur from '../bindings/passed/expr_cmp_eq_dur_dur'
import * as expr_cmp_eq_int_int from '../bindings/passed/expr_cmp_eq_int_int'
import * as expr_cmp_eq_int_nat from '../bindings/passed/expr_cmp_eq_int_nat'
import * as expr_cmp_eq_int_rat from '../bindings/passed/expr_cmp_eq_int_rat'
import * as expr_cmp_eq_nat_int from '../bindings/passed/expr_cmp_eq_nat_int'
import * as expr_cmp_eq_nat_nat from '../bindings/passed/expr_cmp_eq_nat_nat'
import * as expr_cmp_eq_nat_rat from '../bindings/passed/expr_cmp_eq_nat_rat'
import * as expr_cmp_eq_rat_int from '../bindings/passed/expr_cmp_eq_rat_int'
import * as expr_cmp_eq_rat_nat from '../bindings/passed/expr_cmp_eq_rat_nat'
import * as expr_cmp_eq_rat_rat from '../bindings/passed/expr_cmp_eq_rat_rat'
import * as expr_cmp_eq_str_str from '../bindings/passed/expr_cmp_eq_str_str'
import * as expr_cmp_eq_tez_tez from '../bindings/passed/expr_cmp_eq_tez_tez'
import * as expr_cmp_ge_addr_addr from '../bindings/passed/expr_cmp_ge_addr_addr'
import * as expr_cmp_ge_date_date from '../bindings/passed/expr_cmp_ge_date_date'
import * as expr_cmp_ge_dur_dur from '../bindings/passed/expr_cmp_ge_dur_dur'
import * as expr_cmp_ge_int_int from '../bindings/passed/expr_cmp_ge_int_int'
import * as expr_cmp_ge_int_nat from '../bindings/passed/expr_cmp_ge_int_nat'
import * as expr_cmp_ge_int_rat from '../bindings/passed/expr_cmp_ge_int_rat'
import * as expr_cmp_ge_nat_int from '../bindings/passed/expr_cmp_ge_nat_int'
import * as expr_cmp_ge_nat_nat from '../bindings/passed/expr_cmp_ge_nat_nat'
import * as expr_cmp_ge_nat_rat from '../bindings/passed/expr_cmp_ge_nat_rat'
import * as expr_cmp_ge_rat_int from '../bindings/passed/expr_cmp_ge_rat_int'
import * as expr_cmp_ge_rat_nat from '../bindings/passed/expr_cmp_ge_rat_nat'
import * as expr_cmp_ge_rat_rat from '../bindings/passed/expr_cmp_ge_rat_rat'
import * as expr_cmp_ge_str_str from '../bindings/passed/expr_cmp_ge_str_str'
import * as expr_cmp_ge_tez_tez from '../bindings/passed/expr_cmp_ge_tez_tez'
import * as expr_cmp_gt_addr_addr from '../bindings/passed/expr_cmp_gt_addr_addr'
import * as expr_cmp_gt_date_date from '../bindings/passed/expr_cmp_gt_date_date'
import * as expr_cmp_gt_dur_dur from '../bindings/passed/expr_cmp_gt_dur_dur'
import * as expr_cmp_gt_int_int from '../bindings/passed/expr_cmp_gt_int_int'
import * as expr_cmp_gt_int_nat from '../bindings/passed/expr_cmp_gt_int_nat'
import * as expr_cmp_gt_int_rat from '../bindings/passed/expr_cmp_gt_int_rat'
import * as expr_cmp_gt_nat_int from '../bindings/passed/expr_cmp_gt_nat_int'
import * as expr_cmp_gt_nat_nat from '../bindings/passed/expr_cmp_gt_nat_nat'
import * as expr_cmp_gt_nat_rat from '../bindings/passed/expr_cmp_gt_nat_rat'
import * as expr_cmp_gt_rat_int from '../bindings/passed/expr_cmp_gt_rat_int'
import * as expr_cmp_gt_rat_nat from '../bindings/passed/expr_cmp_gt_rat_nat'
import * as expr_cmp_gt_rat_rat from '../bindings/passed/expr_cmp_gt_rat_rat'
import * as expr_cmp_gt_str_str from '../bindings/passed/expr_cmp_gt_str_str'
import * as expr_cmp_gt_tez_tez from '../bindings/passed/expr_cmp_gt_tez_tez'
import * as expr_cmp_le_addr_addr from '../bindings/passed/expr_cmp_le_addr_addr'
import * as expr_cmp_le_date_date from '../bindings/passed/expr_cmp_le_date_date'
import * as expr_cmp_le_dur_dur from '../bindings/passed/expr_cmp_le_dur_dur'
import * as expr_cmp_le_int_int from '../bindings/passed/expr_cmp_le_int_int'
import * as expr_cmp_le_int_nat from '../bindings/passed/expr_cmp_le_int_nat'
import * as expr_cmp_le_int_rat from '../bindings/passed/expr_cmp_le_int_rat'
import * as expr_cmp_le_nat_int from '../bindings/passed/expr_cmp_le_nat_int'
import * as expr_cmp_le_nat_nat from '../bindings/passed/expr_cmp_le_nat_nat'
import * as expr_cmp_le_nat_rat from '../bindings/passed/expr_cmp_le_nat_rat'
import * as expr_cmp_le_rat_int from '../bindings/passed/expr_cmp_le_rat_int'
import * as expr_cmp_le_rat_nat from '../bindings/passed/expr_cmp_le_rat_nat'
import * as expr_cmp_le_rat_rat from '../bindings/passed/expr_cmp_le_rat_rat'
import * as expr_cmp_le_str_str from '../bindings/passed/expr_cmp_le_str_str'
import * as expr_cmp_le_tez_tez from '../bindings/passed/expr_cmp_le_tez_tez'
import * as expr_cmp_lt_addr_addr from '../bindings/passed/expr_cmp_lt_addr_addr'
import * as expr_cmp_lt_date_date from '../bindings/passed/expr_cmp_lt_date_date'
import * as expr_cmp_lt_dur_dur from '../bindings/passed/expr_cmp_lt_dur_dur'
import * as expr_cmp_lt_int_int from '../bindings/passed/expr_cmp_lt_int_int'
import * as expr_cmp_lt_int_nat from '../bindings/passed/expr_cmp_lt_int_nat'
import * as expr_cmp_lt_int_rat from '../bindings/passed/expr_cmp_lt_int_rat'
import * as expr_cmp_lt_nat_int from '../bindings/passed/expr_cmp_lt_nat_int'
import * as expr_cmp_lt_nat_nat from '../bindings/passed/expr_cmp_lt_nat_nat'
import * as expr_cmp_lt_nat_rat from '../bindings/passed/expr_cmp_lt_nat_rat'
import * as expr_cmp_lt_rat_int from '../bindings/passed/expr_cmp_lt_rat_int'
import * as expr_cmp_lt_rat_nat from '../bindings/passed/expr_cmp_lt_rat_nat'
import * as expr_cmp_lt_rat_rat from '../bindings/passed/expr_cmp_lt_rat_rat'
import * as expr_cmp_lt_str_str from '../bindings/passed/expr_cmp_lt_str_str'
import * as expr_cmp_lt_tez_tez from '../bindings/passed/expr_cmp_lt_tez_tez'
import * as expr_cmp_ne_addr_addr from '../bindings/passed/expr_cmp_ne_addr_addr'
import * as expr_cmp_ne_bool_bool from '../bindings/passed/expr_cmp_ne_bool_bool'
import * as expr_cmp_ne_date_date from '../bindings/passed/expr_cmp_ne_date_date'
import * as expr_cmp_ne_dur_dur from '../bindings/passed/expr_cmp_ne_dur_dur'
import * as expr_cmp_ne_int_int from '../bindings/passed/expr_cmp_ne_int_int'
import * as expr_cmp_ne_int_nat from '../bindings/passed/expr_cmp_ne_int_nat'
import * as expr_cmp_ne_int_rat from '../bindings/passed/expr_cmp_ne_int_rat'
import * as expr_cmp_ne_nat_int from '../bindings/passed/expr_cmp_ne_nat_int'
import * as expr_cmp_ne_nat_nat from '../bindings/passed/expr_cmp_ne_nat_nat'
import * as expr_cmp_ne_nat_rat from '../bindings/passed/expr_cmp_ne_nat_rat'
import * as expr_cmp_ne_rat_int from '../bindings/passed/expr_cmp_ne_rat_int'
import * as expr_cmp_ne_rat_nat from '../bindings/passed/expr_cmp_ne_rat_nat'
import * as expr_cmp_ne_rat_rat from '../bindings/passed/expr_cmp_ne_rat_rat'
import * as expr_cmp_ne_str_str from '../bindings/passed/expr_cmp_ne_str_str'
import * as expr_cmp_ne_tez_tez from '../bindings/passed/expr_cmp_ne_tez_tez'
import * as expr_control_fold from '../bindings/passed/expr_control_fold'
import * as expr_control_if_else_int_int from '../bindings/passed/expr_control_if_else_int_int'
import * as expr_control_if_else_int_nat from '../bindings/passed/expr_control_if_else_int_nat'
import * as expr_control_if_else_int_rat from '../bindings/passed/expr_control_if_else_int_rat'
import * as expr_control_if_else_nat_int from '../bindings/passed/expr_control_if_else_nat_int'
import * as expr_control_if_else_nat_nat from '../bindings/passed/expr_control_if_else_nat_nat'
import * as expr_control_if_else_nat_rat from '../bindings/passed/expr_control_if_else_nat_rat'
import * as expr_control_if_else_rat_int from '../bindings/passed/expr_control_if_else_rat_int'
import * as expr_control_if_else_rat_nat from '../bindings/passed/expr_control_if_else_rat_nat'
import * as expr_control_if_else_rat_rat from '../bindings/passed/expr_control_if_else_rat_rat'
import * as expr_control_match_list from '../bindings/passed/expr_control_match_list'
import * as expr_control_match_option from '../bindings/passed/expr_control_match_option'
import * as expr_control_match_or from '../bindings/passed/expr_control_match_or'
import * as expr_control_matchwith from '../bindings/passed/expr_control_matchwith'
import * as expr_control_matchwith_with_int_rat from '../bindings/passed/expr_control_matchwith_with_int_rat'
import * as expr_control_matchwith_with_nat_int from '../bindings/passed/expr_control_matchwith_with_nat_int'
import * as expr_control_matchwith_with_nat_rat from '../bindings/passed/expr_control_matchwith_with_nat_rat'
import * as expr_cst_balance from '../bindings/passed/expr_cst_balance'
import * as expr_cst_caller from '../bindings/passed/expr_cst_caller'
import * as expr_cst_level from '../bindings/passed/expr_cst_level'
import * as expr_cst_min_block_time from '../bindings/passed/expr_cst_min_block_time'
import * as expr_cst_now from '../bindings/passed/expr_cst_now'
import * as expr_cst_self_address from '../bindings/passed/expr_cst_self_address'
import * as expr_cst_self_chain_id from '../bindings/passed/expr_cst_self_chain_id'
import * as expr_cst_source from '../bindings/passed/expr_cst_source'
import * as expr_cst_total_voting_power from '../bindings/passed/expr_cst_total_voting_power'
import * as expr_cst_transferred from '../bindings/passed/expr_cst_transferred'
import * as expr_fail_some_none from '../bindings/passed/expr_fail_some_none'
import * as expr_fail_some_some from '../bindings/passed/expr_fail_some_some'
import * as expr_fun_abs_int from '../bindings/passed/expr_fun_abs_int'
import * as expr_fun_abs_nat from '../bindings/passed/expr_fun_abs_nat'
import * as expr_fun_abs_rat from '../bindings/passed/expr_fun_abs_rat'
import * as expr_fun_address_to_contract from '../bindings/passed/expr_fun_address_to_contract'
import * as expr_fun_address_to_contract_unit from '../bindings/passed/expr_fun_address_to_contract_unit'
import * as expr_fun_bytes_to_int from '../bindings/passed/expr_fun_bytes_to_int'
import * as expr_fun_bytes_to_nat from '../bindings/passed/expr_fun_bytes_to_nat'
import * as expr_fun_ceil from '../bindings/passed/expr_fun_ceil'
import * as expr_fun_concat_byt from '../bindings/passed/expr_fun_concat_byt'
import * as expr_fun_concat_list_byt from '../bindings/passed/expr_fun_concat_list_byt'
import * as expr_fun_concat_list_str from '../bindings/passed/expr_fun_concat_list_str'
import * as expr_fun_concat_str from '../bindings/passed/expr_fun_concat_str'
import * as expr_fun_exp_horner from '../bindings/passed/expr_fun_exp_horner'
import * as expr_fun_floor from '../bindings/passed/expr_fun_floor'
import * as expr_fun_get_denominator from '../bindings/passed/expr_fun_get_denominator'
import * as expr_fun_get_numerator from '../bindings/passed/expr_fun_get_numerator'
import * as expr_fun_int_to_bytes from '../bindings/passed/expr_fun_int_to_bytes'
import * as expr_fun_int_to_nat from '../bindings/passed/expr_fun_int_to_nat'
import * as expr_fun_key_hash_to_contract from '../bindings/passed/expr_fun_key_hash_to_contract'
import * as expr_fun_length_bytes from '../bindings/passed/expr_fun_length_bytes'
import * as expr_fun_length_str from '../bindings/passed/expr_fun_length_str'
import * as expr_fun_make_event from '../bindings/passed/expr_fun_make_event'
import * as expr_fun_make_operation from '../bindings/passed/expr_fun_make_operation'
import * as expr_fun_max_date from '../bindings/passed/expr_fun_max_date'
import * as expr_fun_max_dur from '../bindings/passed/expr_fun_max_dur'
import * as expr_fun_max_int_int from '../bindings/passed/expr_fun_max_int_int'
import * as expr_fun_max_int_nat from '../bindings/passed/expr_fun_max_int_nat'
import * as expr_fun_max_int_rat from '../bindings/passed/expr_fun_max_int_rat'
import * as expr_fun_max_nat_int from '../bindings/passed/expr_fun_max_nat_int'
import * as expr_fun_max_nat_nat from '../bindings/passed/expr_fun_max_nat_nat'
import * as expr_fun_max_nat_rat from '../bindings/passed/expr_fun_max_nat_rat'
import * as expr_fun_max_rat_int from '../bindings/passed/expr_fun_max_rat_int'
import * as expr_fun_max_rat_nat from '../bindings/passed/expr_fun_max_rat_nat'
import * as expr_fun_max_rat_rat from '../bindings/passed/expr_fun_max_rat_rat'
import * as expr_fun_max_tez from '../bindings/passed/expr_fun_max_tez'
import * as expr_fun_min_date from '../bindings/passed/expr_fun_min_date'
import * as expr_fun_min_dur from '../bindings/passed/expr_fun_min_dur'
import * as expr_fun_min_int_int from '../bindings/passed/expr_fun_min_int_int'
import * as expr_fun_min_int_nat from '../bindings/passed/expr_fun_min_int_nat'
import * as expr_fun_min_int_rat from '../bindings/passed/expr_fun_min_int_rat'
import * as expr_fun_min_nat_int from '../bindings/passed/expr_fun_min_nat_int'
import * as expr_fun_min_nat_nat from '../bindings/passed/expr_fun_min_nat_nat'
import * as expr_fun_min_nat_rat from '../bindings/passed/expr_fun_min_nat_rat'
import * as expr_fun_min_rat_int from '../bindings/passed/expr_fun_min_rat_int'
import * as expr_fun_min_rat_nat from '../bindings/passed/expr_fun_min_rat_nat'
import * as expr_fun_min_rat_rat from '../bindings/passed/expr_fun_min_rat_rat'
import * as expr_fun_min_tez from '../bindings/passed/expr_fun_min_tez'
import * as expr_fun_nat_to_bytes from '../bindings/passed/expr_fun_nat_to_bytes'
import * as expr_fun_nat_to_string from '../bindings/passed/expr_fun_nat_to_string'
import * as expr_fun_opt_get_some from '../bindings/passed/expr_fun_opt_get_some'
import * as expr_fun_opt_is_none from '../bindings/passed/expr_fun_opt_is_none'
import * as expr_fun_opt_is_some from '../bindings/passed/expr_fun_opt_is_some'
import * as expr_fun_opt_require_some from '../bindings/passed/expr_fun_opt_require_some'
import * as expr_fun_pack_complex from '../bindings/passed/expr_fun_pack_complex'
import * as expr_fun_pack_lit_tuple from '../bindings/passed/expr_fun_pack_lit_tuple'
import * as expr_fun_pack_string from '../bindings/passed/expr_fun_pack_string'
import * as expr_fun_setdelegate from '../bindings/passed/expr_fun_setdelegate'
import * as expr_fun_simplify_rational from '../bindings/passed/expr_fun_simplify_rational'
import * as expr_fun_slice_byt from '../bindings/passed/expr_fun_slice_byt'
import * as expr_fun_slice_str from '../bindings/passed/expr_fun_slice_str'
import * as expr_fun_sub_mutez from '../bindings/passed/expr_fun_sub_mutez'
import * as expr_fun_sub_nat from '../bindings/passed/expr_fun_sub_nat'
import * as expr_fun_sub_nat_zero from '../bindings/passed/expr_fun_sub_nat_zero'
import * as expr_fun_unpack_bool from '../bindings/passed/expr_fun_unpack_bool'
import * as expr_fun_unpack_complex from '../bindings/passed/expr_fun_unpack_complex'
import * as expr_fun_unpack_string from '../bindings/passed/expr_fun_unpack_string'
import * as expr_instr_rec_1_0 from '../bindings/passed/expr_instr_rec_1_0'
import * as expr_instr_rec_2_0 from '../bindings/passed/expr_instr_rec_2_0'
import * as expr_instr_rec_2_1 from '../bindings/passed/expr_instr_rec_2_1'
import * as expr_instr_rec_3_0 from '../bindings/passed/expr_instr_rec_3_0'
import * as expr_instr_rec_3_1 from '../bindings/passed/expr_instr_rec_3_1'
import * as expr_instr_rec_3_2 from '../bindings/passed/expr_instr_rec_3_2'
import * as expr_instr_rec_4_0 from '../bindings/passed/expr_instr_rec_4_0'
import * as expr_instr_rec_4_1 from '../bindings/passed/expr_instr_rec_4_1'
import * as expr_instr_rec_4_2 from '../bindings/passed/expr_instr_rec_4_2'
import * as expr_instr_rec_4_3 from '../bindings/passed/expr_instr_rec_4_3'
import * as expr_instr_rec_rollback from '../bindings/passed/expr_instr_rec_rollback'
import * as expr_lambda from '../bindings/passed/expr_lambda'
import * as expr_lambda2 from '../bindings/passed/expr_lambda2'
import * as expr_list_concat from '../bindings/passed/expr_list_concat'
import * as expr_list_contains from '../bindings/passed/expr_list_contains'
import * as expr_list_head from '../bindings/passed/expr_list_head'
import * as expr_list_length from '../bindings/passed/expr_list_length'
import * as expr_list_lit from '../bindings/passed/expr_list_lit'
import * as expr_list_map from '../bindings/passed/expr_list_map'
import * as expr_list_map_string_nat from '../bindings/passed/expr_list_map_string_nat'
import * as expr_list_nth from '../bindings/passed/expr_list_nth'
import * as expr_list_prepend from '../bindings/passed/expr_list_prepend'
import * as expr_list_reverse from '../bindings/passed/expr_list_reverse'
import * as expr_list_tail from '../bindings/passed/expr_list_tail'
import * as expr_lit_addr from '../bindings/passed/expr_lit_addr'
import * as expr_lit_bytes from '../bindings/passed/expr_lit_bytes'
import * as expr_lit_cur_mtz from '../bindings/passed/expr_lit_cur_mtz'
import * as expr_lit_cur_tz from '../bindings/passed/expr_lit_cur_tz'
import * as expr_lit_cur_utz from '../bindings/passed/expr_lit_cur_utz'
import * as expr_lit_date_0 from '../bindings/passed/expr_lit_date_0'
import * as expr_lit_date_1 from '../bindings/passed/expr_lit_date_1'
import * as expr_lit_date_2 from '../bindings/passed/expr_lit_date_2'
import * as expr_lit_date_3 from '../bindings/passed/expr_lit_date_3'
import * as expr_lit_date_4 from '../bindings/passed/expr_lit_date_4'
import * as expr_lit_dur from '../bindings/passed/expr_lit_dur'
import * as expr_lit_int from '../bindings/passed/expr_lit_int'
import * as expr_lit_int_neg from '../bindings/passed/expr_lit_int_neg'
import * as expr_lit_nat from '../bindings/passed/expr_lit_nat'
import * as expr_lit_opt_none from '../bindings/passed/expr_lit_opt_none'
import * as expr_lit_opt_some from '../bindings/passed/expr_lit_opt_some'
import * as expr_lit_or_left from '../bindings/passed/expr_lit_or_left'
import * as expr_lit_or_right from '../bindings/passed/expr_lit_or_right'
import * as expr_lit_rat_dec from '../bindings/passed/expr_lit_rat_dec'
import * as expr_lit_rat_dec_neg from '../bindings/passed/expr_lit_rat_dec_neg'
import * as expr_lit_rat_div from '../bindings/passed/expr_lit_rat_div'
import * as expr_lit_rat_div_neg from '../bindings/passed/expr_lit_rat_div_neg'
import * as expr_lit_str from '../bindings/passed/expr_lit_str'
import * as expr_lit_tuple from '../bindings/passed/expr_lit_tuple'
import * as expr_lit_unit from '../bindings/passed/expr_lit_unit'
import * as expr_make_big_map from '../bindings/passed/expr_make_big_map'
import * as expr_make_big_map_empty from '../bindings/passed/expr_make_big_map_empty'
import * as expr_make_list from '../bindings/passed/expr_make_list'
import * as expr_make_list_empty from '../bindings/passed/expr_make_list_empty'
import * as expr_make_map from '../bindings/passed/expr_make_map'
import * as expr_make_map_empty from '../bindings/passed/expr_make_map_empty'
import * as expr_make_set from '../bindings/passed/expr_make_set'
import * as expr_make_set_empty from '../bindings/passed/expr_make_set_empty'
import * as expr_map_contains from '../bindings/passed/expr_map_contains'
import * as expr_map_get from '../bindings/passed/expr_map_get'
import * as expr_map_length from '../bindings/passed/expr_map_length'
import * as expr_map_lit from '../bindings/passed/expr_map_lit'
import * as expr_map_map from '../bindings/passed/expr_map_map'
import * as expr_map_put from '../bindings/passed/expr_map_put'
import * as expr_map_remove from '../bindings/passed/expr_map_remove'
import * as expr_map_update from '../bindings/passed/expr_map_update'
import * as expr_method_asset_contains from '../bindings/passed/expr_method_asset_contains'
import * as expr_method_asset_contains_aggregate from '../bindings/passed/expr_method_asset_contains_aggregate'
import * as expr_method_asset_contains_one_field from '../bindings/passed/expr_method_asset_contains_one_field'
import * as expr_method_asset_contains_partition from '../bindings/passed/expr_method_asset_contains_partition'
import * as expr_method_asset_contains_view from '../bindings/passed/expr_method_asset_contains_view'
import * as expr_method_asset_count from '../bindings/passed/expr_method_asset_count'
import * as expr_method_asset_count_aggregate from '../bindings/passed/expr_method_asset_count_aggregate'
import * as expr_method_asset_count_one_field from '../bindings/passed/expr_method_asset_count_one_field'
import * as expr_method_asset_count_partition from '../bindings/passed/expr_method_asset_count_partition'
import * as expr_method_asset_count_view from '../bindings/passed/expr_method_asset_count_view'
import * as expr_method_asset_get from '../bindings/passed/expr_method_asset_get'
import * as expr_method_asset_head from '../bindings/passed/expr_method_asset_head'
import * as expr_method_asset_head_aggregate from '../bindings/passed/expr_method_asset_head_aggregate'
import * as expr_method_asset_head_one_field from '../bindings/passed/expr_method_asset_head_one_field'
import * as expr_method_asset_head_partition from '../bindings/passed/expr_method_asset_head_partition'
import * as expr_method_asset_head_view from '../bindings/passed/expr_method_asset_head_view'
import * as expr_method_asset_nth from '../bindings/passed/expr_method_asset_nth'
import * as expr_method_asset_nth_aggregate from '../bindings/passed/expr_method_asset_nth_aggregate'
import * as expr_method_asset_nth_one_field from '../bindings/passed/expr_method_asset_nth_one_field'
import * as expr_method_asset_nth_partition from '../bindings/passed/expr_method_asset_nth_partition'
import * as expr_method_asset_nth_view from '../bindings/passed/expr_method_asset_nth_view'
import * as expr_method_asset_select from '../bindings/passed/expr_method_asset_select'
import * as expr_method_asset_select_aggregate from '../bindings/passed/expr_method_asset_select_aggregate'
import * as expr_method_asset_select_one_field from '../bindings/passed/expr_method_asset_select_one_field'
import * as expr_method_asset_select_partition from '../bindings/passed/expr_method_asset_select_partition'
import * as expr_method_asset_select_view from '../bindings/passed/expr_method_asset_select_view'
import * as expr_method_asset_sort from '../bindings/passed/expr_method_asset_sort'
import * as expr_method_asset_sort_aggregate from '../bindings/passed/expr_method_asset_sort_aggregate'
import * as expr_method_asset_sort_one_field from '../bindings/passed/expr_method_asset_sort_one_field'
import * as expr_method_asset_sort_partition from '../bindings/passed/expr_method_asset_sort_partition'
import * as expr_method_asset_sort_view from '../bindings/passed/expr_method_asset_sort_view'
import * as expr_method_asset_sum from '../bindings/passed/expr_method_asset_sum'
import * as expr_method_asset_sum_aggregate from '../bindings/passed/expr_method_asset_sum_aggregate'
import * as expr_method_asset_sum_one_field from '../bindings/passed/expr_method_asset_sum_one_field'
import * as expr_method_asset_sum_partition from '../bindings/passed/expr_method_asset_sum_partition'
import * as expr_method_asset_sum_rational from '../bindings/passed/expr_method_asset_sum_rational'
import * as expr_method_asset_sum_view from '../bindings/passed/expr_method_asset_sum_view'
import * as expr_method_asset_tail from '../bindings/passed/expr_method_asset_tail'
import * as expr_method_asset_tail_aggregate from '../bindings/passed/expr_method_asset_tail_aggregate'
import * as expr_method_asset_tail_one_field from '../bindings/passed/expr_method_asset_tail_one_field'
import * as expr_method_asset_tail_partition from '../bindings/passed/expr_method_asset_tail_partition'
import * as expr_method_asset_tail_view from '../bindings/passed/expr_method_asset_tail_view'
import * as expr_multicmp from '../bindings/passed/expr_multicmp'
import * as expr_option_map from '../bindings/passed/expr_option_map'
import * as expr_record_lit from '../bindings/passed/expr_record_lit'
import * as expr_record_update_record_in_exec from '../bindings/passed/expr_record_update_record_in_exec'
import * as expr_set_add from '../bindings/passed/expr_set_add'
import * as expr_set_contains from '../bindings/passed/expr_set_contains'
import * as expr_set_length from '../bindings/passed/expr_set_length'
import * as expr_set_lit from '../bindings/passed/expr_set_lit'
import * as expr_set_remove from '../bindings/passed/expr_set_remove'
import * as expr_set_update from '../bindings/passed/expr_set_update'
import * as expr_tuple_access from '../bindings/passed/expr_tuple_access'
import * as expr_tuple_access_simple from '../bindings/passed/expr_tuple_access_simple'
import * as expr_var_match_list_empty from '../bindings/passed/expr_var_match_list_empty'
import * as expr_var_match_list_head from '../bindings/passed/expr_var_match_list_head'
import * as expr_var_match_option_none from '../bindings/passed/expr_var_match_option_none'
import * as expr_var_match_option_some from '../bindings/passed/expr_var_match_option_some'
import * as expr_var_match_or_left from '../bindings/passed/expr_var_match_or_left'
import * as expr_var_match_or_right from '../bindings/passed/expr_var_match_or_right'
import * as fa12_false from '../bindings/passed/fa12_false'
import * as fa12_simple from '../bindings/passed/fa12_simple'
import * as fail_ from '../bindings/passed/fail_'
import * as fail_for from '../bindings/passed/fail_for'
import * as fail_if from '../bindings/passed/fail_if'
import * as fail_match_list from '../bindings/passed/fail_match_list'
import * as fail_match_option from '../bindings/passed/fail_match_option'
import * as fail_while from '../bindings/passed/fail_while'
import * as fail_with_tuple_lit from '../bindings/passed/fail_with_tuple_lit'
import * as fold_reverse from '../bindings/passed/fold_reverse'
import * as fun from '../bindings/passed/fun'
import * as fun_entry_pure from '../bindings/passed/fun_entry_pure'
import * as fun_entry_read from '../bindings/passed/fun_entry_read'
import * as fun_entry_write from '../bindings/passed/fun_entry_write'
import * as fun_entry_write_with_transfer from '../bindings/passed/fun_entry_write_with_transfer'
import * as fun_instr_unit from '../bindings/passed/fun_instr_unit'
import * as fun_instr_unit_arg from '../bindings/passed/fun_instr_unit_arg'
import * as fun_instr_unit_arg_side_effect from '../bindings/passed/fun_instr_unit_arg_side_effect'
import * as fun_unit from '../bindings/passed/fun_unit'
import * as fun_view_instr_pure from '../bindings/passed/fun_view_instr_pure'
import * as fun_view_pure from '../bindings/passed/fun_view_pure'
import * as fun_view_read from '../bindings/passed/fun_view_read'
import * as fun_view_read_asset from '../bindings/passed/fun_view_read_asset'
import * as function_with_nat_to_string from '../bindings/passed/function_with_nat_to_string'
import * as function_with_simplify_rational from '../bindings/passed/function_with_simplify_rational'
import * as get_in_require_failif from '../bindings/passed/get_in_require_failif'
import * as get_some_with_msg from '../bindings/passed/get_some_with_msg'
import * as getter_called_by from '../bindings/passed/getter_called_by'
import * as greedy_and from '../bindings/passed/greedy_and'
import * as greedy_or from '../bindings/passed/greedy_or'
import * as implicit_cast_to_view from '../bindings/passed/implicit_cast_to_view'
import * as implicit_the from '../bindings/passed/implicit_the'
import * as import_arl_all_def from '../bindings/passed/import_arl_all_def'
import * as import_arl_asset_container_use_arg from '../bindings/passed/import_arl_asset_container_use_arg'
import * as import_arl_asset_container_use_arg_collide from '../bindings/passed/import_arl_asset_container_use_arg_collide'
import * as import_arl_asset_def from '../bindings/passed/import_arl_asset_def'
import * as import_arl_asset_key_use_arg from '../bindings/passed/import_arl_asset_key_use_arg'
import * as import_arl_asset_key_use_arg_collide from '../bindings/passed/import_arl_asset_key_use_arg_collide'
import * as import_arl_asset_use_all from '../bindings/passed/import_arl_asset_use_all'
import * as import_arl_asset_value_use_arg from '../bindings/passed/import_arl_asset_value_use_arg'
import * as import_arl_asset_value_use_arg_collide from '../bindings/passed/import_arl_asset_value_use_arg_collide'
import * as import_arl_asset_view_use_arg from '../bindings/passed/import_arl_asset_view_use_arg'
import * as import_arl_asset_view_use_arg_collide from '../bindings/passed/import_arl_asset_view_use_arg_collide'
import * as import_arl_constant_def from '../bindings/passed/import_arl_constant_def'
import * as import_arl_constant_use from '../bindings/passed/import_arl_constant_use'
import * as import_arl_constant_use_all from '../bindings/passed/import_arl_constant_use_all'
import * as import_arl_constant_use_collide from '../bindings/passed/import_arl_constant_use_collide'
import * as import_arl_entry_record_use_all from '../bindings/passed/import_arl_entry_record_use_all'
import * as import_arl_entrypoint_def from '../bindings/passed/import_arl_entrypoint_def'
import * as import_arl_entrypoint_use from '../bindings/passed/import_arl_entrypoint_use'
import * as import_arl_entrypoint_use_collide from '../bindings/passed/import_arl_entrypoint_use_collide'
import * as import_arl_enum_def from '../bindings/passed/import_arl_enum_def'
import * as import_arl_enum_use from '../bindings/passed/import_arl_enum_use'
import * as import_arl_enum_use_all from '../bindings/passed/import_arl_enum_use_all'
import * as import_arl_enum_use_collide from '../bindings/passed/import_arl_enum_use_collide'
import * as import_arl_enum_use_complete from '../bindings/passed/import_arl_enum_use_complete'
import * as import_arl_enum_with_args_def from '../bindings/passed/import_arl_enum_with_args_def'
import * as import_arl_enum_with_args_use from '../bindings/passed/import_arl_enum_with_args_use'
import * as import_arl_enum_with_args_use_collide from '../bindings/passed/import_arl_enum_with_args_use_collide'
import * as import_arl_enum_with_args_use_complete from '../bindings/passed/import_arl_enum_with_args_use_complete'
import * as import_arl_event_def from '../bindings/passed/import_arl_event_def'
import * as import_arl_event_use from '../bindings/passed/import_arl_event_use'
import * as import_arl_event_use_collide from '../bindings/passed/import_arl_event_use_collide'
import * as import_arl_fun_2_pure_use from '../bindings/passed/import_arl_fun_2_pure_use'
import * as import_arl_fun_def from '../bindings/passed/import_arl_fun_def'
import * as import_arl_fun_def_pure from '../bindings/passed/import_arl_fun_def_pure'
import * as import_arl_fun_instr_pure_use from '../bindings/passed/import_arl_fun_instr_pure_use'
import * as import_arl_fun_pure_use from '../bindings/passed/import_arl_fun_pure_use'
import * as import_arl_record_complex_0 from '../bindings/passed/import_arl_record_complex_0'
import * as import_arl_record_complex_1 from '../bindings/passed/import_arl_record_complex_1'
import * as import_arl_record_complex_2 from '../bindings/passed/import_arl_record_complex_2'
import * as import_arl_record_def from '../bindings/passed/import_arl_record_def'
import * as import_arl_record_use from '../bindings/passed/import_arl_record_use'
import * as import_arl_record_use_all from '../bindings/passed/import_arl_record_use_all'
import * as import_arl_record_use_collide from '../bindings/passed/import_arl_record_use_collide'
import * as import_arl_record_use_complete from '../bindings/passed/import_arl_record_use_complete'
import * as import_arl_transfer_use from '../bindings/passed/import_arl_transfer_use'
import * as import_arl_view_def from '../bindings/passed/import_arl_view_def'
import * as import_arl_view_use from '../bindings/passed/import_arl_view_use'
import * as import_arl_view_use_all from '../bindings/passed/import_arl_view_use_all'
import * as import_arl_view_use_collide from '../bindings/passed/import_arl_view_use_collide'
import * as import_tz_entry_use from '../bindings/passed/import_tz_entry_use'
import * as import_tz_view_use from '../bindings/passed/import_tz_view_use'
import * as init_asset_with_const from '../bindings/passed/init_asset_with_const'
import * as init_lambda from '../bindings/passed/init_lambda'
import * as instr_list_prepend from '../bindings/passed/instr_list_prepend'
import * as instr_map_put from '../bindings/passed/instr_map_put'
import * as instr_map_remove from '../bindings/passed/instr_map_remove'
import * as instr_map_update_local_record from '../bindings/passed/instr_map_update_local_record'
import * as instr_map_update_local_var from '../bindings/passed/instr_map_update_local_var'
import * as instr_map_update_storage_record from '../bindings/passed/instr_map_update_storage_record'
import * as instr_map_update_storage_var from '../bindings/passed/instr_map_update_storage_var'
import * as instr_set_add from '../bindings/passed/instr_set_add'
import * as instr_set_remove from '../bindings/passed/instr_set_remove'
import * as instr_set_update_add from '../bindings/passed/instr_set_update_add'
import * as instr_set_update_remove from '../bindings/passed/instr_set_update_remove'
import * as int_to_date from '../bindings/passed/int_to_date'
import * as invariants_on_states from '../bindings/passed/invariants_on_states'
import * as invariants_on_variable from '../bindings/passed/invariants_on_variable'
import * as iter_list_ticket from '../bindings/passed/iter_list_ticket'
import * as iterable_big_map_assign from '../bindings/passed/iterable_big_map_assign'
import * as iterable_big_map_contains from '../bindings/passed/iterable_big_map_contains'
import * as iterable_big_map_for from '../bindings/passed/iterable_big_map_for'
import * as iterable_big_map_get from '../bindings/passed/iterable_big_map_get'
import * as iterable_big_map_length from '../bindings/passed/iterable_big_map_length'
import * as iterable_big_map_put from '../bindings/passed/iterable_big_map_put'
import * as iterable_big_map_remove from '../bindings/passed/iterable_big_map_remove'
import * as iterable_big_map_storage_decl from '../bindings/passed/iterable_big_map_storage_decl'
import * as iterable_big_map_test from '../bindings/passed/iterable_big_map_test'
import * as key_to_address from '../bindings/passed/key_to_address'
import * as lang_arith from '../bindings/passed/lang_arith'
import * as lang_asset from '../bindings/passed/lang_asset'
import * as lang_assign from '../bindings/passed/lang_assign'
import * as lang_big_map from '../bindings/passed/lang_big_map'
import * as lang_cast from '../bindings/passed/lang_cast'
import * as lang_cmp from '../bindings/passed/lang_cmp'
import * as lang_contract from '../bindings/passed/lang_contract'
import * as lang_crypto from '../bindings/passed/lang_crypto'
import * as lang_cst from '../bindings/passed/lang_cst'
import * as lang_entry from '../bindings/passed/lang_entry'
import * as lang_enum from '../bindings/passed/lang_enum'
import * as lang_funs from '../bindings/passed/lang_funs'
import * as lang_list from '../bindings/passed/lang_list'
import * as lang_literals from '../bindings/passed/lang_literals'
import * as lang_map from '../bindings/passed/lang_map'
import * as lang_methods_asset from '../bindings/passed/lang_methods_asset'
import * as lang_set from '../bindings/passed/lang_set'
import * as large_if from '../bindings/passed/large_if'
import * as list_list from '../bindings/passed/list_list'
import * as list_nth_out_of_bound from '../bindings/passed/list_nth_out_of_bound'
import * as list_option from '../bindings/passed/list_option'
import * as list_or from '../bindings/passed/list_or'
import * as lit_list from '../bindings/passed/lit_list'
import * as lit_map from '../bindings/passed/lit_map'
import * as lit_set from '../bindings/passed/lit_set'
import * as lit_tez_underscore from '../bindings/passed/lit_tez_underscore'
import * as literal_in_argument from '../bindings/passed/literal_in_argument'
import * as map_asset from '../bindings/passed/map_asset'
import * as match_detach_big_map from '../bindings/passed/match_detach_big_map'
import * as match_detach_map from '../bindings/passed/match_detach_map'
import * as match_detach_option from '../bindings/passed/match_detach_option'
import * as match_entrypoint from '../bindings/passed/match_entrypoint'
import * as max_tez from '../bindings/passed/max_tez'
import * as method_in_dorequire_or_dofailif from '../bindings/passed/method_in_dorequire_or_dofailif'
import * as michelson_expression from '../bindings/passed/michelson_expression'
import * as michelson_instruction from '../bindings/passed/michelson_instruction'
import * as michelson_lambda from '../bindings/passed/michelson_lambda'
import * as miles_with_expiration_spec from '../bindings/passed/miles_with_expiration_spec'
import * as mod_rat from '../bindings/passed/mod_rat'
import * as multi_e from '../bindings/passed/multi_e'
import * as multi_ident_match_option from '../bindings/passed/multi_ident_match_option'
import * as multi_ident_match_option_3 from '../bindings/passed/multi_ident_match_option_3'
import * as multi_ident_match_or_left from '../bindings/passed/multi_ident_match_or_left'
import * as multi_ident_match_or_right from '../bindings/passed/multi_ident_match_or_right'
import * as multi_p from '../bindings/passed/multi_p'
import * as multi_sort from '../bindings/passed/multi_sort'
import * as multi_update from '../bindings/passed/multi_update'
import * as multi_var_storage from '../bindings/passed/multi_var_storage'
import * as multivars from '../bindings/passed/multivars'
import * as multivars1 from '../bindings/passed/multivars1'
import * as multivars_simple from '../bindings/passed/multivars_simple'
import * as mutez_to_nat from '../bindings/passed/mutez_to_nat'
import * as nat_to_string from '../bindings/passed/nat_to_string'
import * as nat_to_string_2 from '../bindings/passed/nat_to_string_2'
import * as nested_for from '../bindings/passed/nested_for'
import * as nested_if_return from '../bindings/passed/nested_if_return'
import * as no_entrypoint from '../bindings/passed/no_entrypoint'
import * as not_int from '../bindings/passed/not_int'
import * as not_nat from '../bindings/passed/not_nat'
import * as nothing from '../bindings/passed/nothing'
import * as one_constant from '../bindings/passed/one_constant'
import * as op_assign_rat_update_asset from '../bindings/passed/op_assign_rat_update_asset'
import * as param_const from '../bindings/passed/param_const'
import * as parameter_expr_map from '../bindings/passed/parameter_expr_map'
import * as partial_record from '../bindings/passed/partial_record'
import * as rat_arith_div from '../bindings/passed/rat_arith_div'
import * as rat_arith_minus from '../bindings/passed/rat_arith_minus'
import * as rat_arith_mult from '../bindings/passed/rat_arith_mult'
import * as rat_arith_plus from '../bindings/passed/rat_arith_plus'
import * as rat_arith_uminus from '../bindings/passed/rat_arith_uminus'
import * as rat_cmp_eq from '../bindings/passed/rat_cmp_eq'
import * as rat_cmp_ge from '../bindings/passed/rat_cmp_ge'
import * as rat_cmp_gt from '../bindings/passed/rat_cmp_gt'
import * as rat_cmp_le from '../bindings/passed/rat_cmp_le'
import * as rat_cmp_lt from '../bindings/passed/rat_cmp_lt'
import * as rat_dur from '../bindings/passed/rat_dur'
import * as rat_int from '../bindings/passed/rat_int'
import * as rat_max from '../bindings/passed/rat_max'
import * as rat_min from '../bindings/passed/rat_min'
import * as rat_nat from '../bindings/passed/rat_nat'
import * as rat_neg from '../bindings/passed/rat_neg'
import * as rat_tez from '../bindings/passed/rat_tez'
import * as rat_tez_big from '../bindings/passed/rat_tez_big'
import * as rational_cmp from '../bindings/passed/rational_cmp'
import * as rational_duration from '../bindings/passed/rational_duration'
import * as rational_full from '../bindings/passed/rational_full'
import * as rational_rat_tez_mult from '../bindings/passed/rational_rat_tez_mult'
import * as rational_simple from '../bindings/passed/rational_simple'
import * as rational_tez_rat_mult from '../bindings/passed/rational_tez_rat_mult'
import * as rec_update from '../bindings/passed/rec_update'
import * as rec_update2 from '../bindings/passed/rec_update2'
import * as record_access from '../bindings/passed/record_access'
import * as record_access2 from '../bindings/passed/record_access2'
import * as record_container from '../bindings/passed/record_container'
import * as record_double_key from '../bindings/passed/record_double_key'
import * as record_in_enum from '../bindings/passed/record_in_enum'
import * as record_update from '../bindings/passed/record_update'
import * as remove_asset_with_partition from '../bindings/passed/remove_asset_with_partition'
import * as reverse_otherwise from '../bindings/passed/reverse_otherwise'
import * as reverse_with_enum from '../bindings/passed/reverse_with_enum'
import * as rf_failif_with from '../bindings/passed/rf_failif_with'
import * as rf_require_otherwise from '../bindings/passed/rf_require_otherwise'
import * as same_varname_in_two_distinct_scope from '../bindings/passed/same_varname_in_two_distinct_scope'
import * as sample_asset_view from '../bindings/passed/sample_asset_view'
import * as sample_make_sandbox_exec_operation from '../bindings/passed/sample_make_sandbox_exec_operation'
import * as sample_sandbox_exec from '../bindings/passed/sample_sandbox_exec'
import * as sample_view_asset_value from '../bindings/passed/sample_view_asset_value'
import * as sapling_empty_state from '../bindings/passed/sapling_empty_state'
import * as sapling_var from '../bindings/passed/sapling_var'
import * as sapling_verify_update from '../bindings/passed/sapling_verify_update'
import * as section_constant_effect from '../bindings/passed/section_constant_effect'
import * as section_constant_transition from '../bindings/passed/section_constant_transition'
import * as select_partition from '../bindings/passed/select_partition'
import * as select_partition_big_map from '../bindings/passed/select_partition_big_map'
import * as select_with_extra_var from '../bindings/passed/select_with_extra_var'
import * as select_with_extra_var2 from '../bindings/passed/select_with_extra_var2'
import * as select_with_function_in_predicate from '../bindings/passed/select_with_function_in_predicate'
import * as setdelegate from '../bindings/passed/setdelegate'
import * as simple from '../bindings/passed/simple'
import * as simple2 from '../bindings/passed/simple2'
import * as simple3 from '../bindings/passed/simple3'
import * as simple4 from '../bindings/passed/simple4'
import * as simple_2vars from '../bindings/passed/simple_2vars'
import * as simple_addupdate from '../bindings/passed/simple_addupdate'
import * as simple_addupdate_asset from '../bindings/passed/simple_addupdate_asset'
import * as simple_arg_int from '../bindings/passed/simple_arg_int'
import * as simple_arith from '../bindings/passed/simple_arith'
import * as simple_asset from '../bindings/passed/simple_asset'
import * as simple_asset_2 from '../bindings/passed/simple_asset_2'
import * as simple_asset_get_asset1_value from '../bindings/passed/simple_asset_get_asset1_value'
import * as simple_asset_get_asset2_value from '../bindings/passed/simple_asset_get_asset2_value'
import * as simple_asset_get_asset2_value2 from '../bindings/passed/simple_asset_get_asset2_value2'
import * as simple_asset_one_field from '../bindings/passed/simple_asset_one_field'
import * as simple_asset_skip from '../bindings/passed/simple_asset_skip'
import * as simple_asset_skip_empty from '../bindings/passed/simple_asset_skip_empty'
import * as simple_asset_skip_empty_one_field from '../bindings/passed/simple_asset_skip_empty_one_field'
import * as simple_asset_skip_one_field from '../bindings/passed/simple_asset_skip_one_field'
import * as simple_assign1 from '../bindings/passed/simple_assign1'
import * as simple_assign2 from '../bindings/passed/simple_assign2'
import * as simple_assign3 from '../bindings/passed/simple_assign3'
import * as simple_contract_call from '../bindings/passed/simple_contract_call'
import * as simple_freeze from '../bindings/passed/simple_freeze'
import * as simple_fun1 from '../bindings/passed/simple_fun1'
import * as simple_fun2 from '../bindings/passed/simple_fun2'
import * as simple_fun3 from '../bindings/passed/simple_fun3'
import * as simple_fun4 from '../bindings/passed/simple_fun4'
import * as simple_fun5 from '../bindings/passed/simple_fun5'
import * as simple_fun6 from '../bindings/passed/simple_fun6'
import * as simple_fun7 from '../bindings/passed/simple_fun7'
import * as simple_fun8 from '../bindings/passed/simple_fun8'
import * as simple_fun_alt from '../bindings/passed/simple_fun_alt'
import * as simple_fun_with_storage from '../bindings/passed/simple_fun_with_storage'
import * as simple_fun_with_storage2 from '../bindings/passed/simple_fun_with_storage2'
import * as simple_fun_with_storage3 from '../bindings/passed/simple_fun_with_storage3'
import * as simple_get_field from '../bindings/passed/simple_get_field'
import * as simple_if3 from '../bindings/passed/simple_if3'
import * as simple_multi_entry from '../bindings/passed/simple_multi_entry'
import * as simple_multi_entry2 from '../bindings/passed/simple_multi_entry2'
import * as simple_multi_entry3 from '../bindings/passed/simple_multi_entry3'
import * as simple_op_add from '../bindings/passed/simple_op_add'
import * as simple_op_uminus from '../bindings/passed/simple_op_uminus'
import * as simple_param from '../bindings/passed/simple_param'
import * as simple_param_const from '../bindings/passed/simple_param_const'
import * as simple_param_with_default from '../bindings/passed/simple_param_with_default'
import * as simple_record_assign from '../bindings/passed/simple_record_assign'
import * as simple_record_assign1 from '../bindings/passed/simple_record_assign1'
import * as simple_record_assign2 from '../bindings/passed/simple_record_assign2'
import * as simple_record_lit from '../bindings/passed/simple_record_lit'
import * as simple_record_lit_rev from '../bindings/passed/simple_record_lit_rev'
import * as simple_reverse from '../bindings/passed/simple_reverse'
import * as simple_sequence from '../bindings/passed/simple_sequence'
import * as simple_sequence_with_arg from '../bindings/passed/simple_sequence_with_arg'
import * as simple_sequence_with_arg2 from '../bindings/passed/simple_sequence_with_arg2'
import * as simple_sequence_with_arg_var from '../bindings/passed/simple_sequence_with_arg_var'
import * as simple_string from '../bindings/passed/simple_string'
import * as simple_while from '../bindings/passed/simple_while'
import * as simple_with_arg_view from '../bindings/passed/simple_with_arg_view'
import * as simple_with_type_annot from '../bindings/passed/simple_with_type_annot'
import * as simple_with_view from '../bindings/passed/simple_with_view'
import * as sourced_by from '../bindings/passed/sourced_by'
import * as state_in_effect from '../bindings/passed/state_in_effect'
import * as state_is from '../bindings/passed/state_is'
import * as state_var from '../bindings/passed/state_var'
import * as tern_bool_false from '../bindings/passed/tern_bool_false'
import * as tern_bool_true from '../bindings/passed/tern_bool_true'
import * as tern_opt from '../bindings/passed/tern_opt'
import * as tern_opt_3 from '../bindings/passed/tern_opt_3'
import * as test_add_asset2_with_partition from '../bindings/passed/test_add_asset2_with_partition'
import * as test_add_asset_with_aggregate from '../bindings/passed/test_add_asset_with_aggregate'
import * as test_add_asset_with_both from '../bindings/passed/test_add_asset_with_both'
import * as test_add_asset_with_partition from '../bindings/passed/test_add_asset_with_partition'
import * as test_addfield_aggregate_1 from '../bindings/passed/test_addfield_aggregate_1'
import * as test_addfield_aggregate_2 from '../bindings/passed/test_addfield_aggregate_2'
import * as test_addfield_partition_1 from '../bindings/passed/test_addfield_partition_1'
import * as test_addfield_partition_2 from '../bindings/passed/test_addfield_partition_2'
import * as test_addupdate_0 from '../bindings/passed/test_addupdate_0'
import * as test_addupdate_1 from '../bindings/passed/test_addupdate_1'
import * as test_addupdate_2 from '../bindings/passed/test_addupdate_2'
import * as test_asset from '../bindings/passed/test_asset'
import * as test_asset_head_agg_0 from '../bindings/passed/test_asset_head_agg_0'
import * as test_asset_head_agg_1 from '../bindings/passed/test_asset_head_agg_1'
import * as test_asset_head_agg_2 from '../bindings/passed/test_asset_head_agg_2'
import * as test_asset_head_coll_0 from '../bindings/passed/test_asset_head_coll_0'
import * as test_asset_head_coll_1 from '../bindings/passed/test_asset_head_coll_1'
import * as test_asset_head_coll_2 from '../bindings/passed/test_asset_head_coll_2'
import * as test_asset_head_view_0 from '../bindings/passed/test_asset_head_view_0'
import * as test_asset_head_view_1 from '../bindings/passed/test_asset_head_view_1'
import * as test_asset_head_view_2 from '../bindings/passed/test_asset_head_view_2'
import * as test_asset_multi_key from '../bindings/passed/test_asset_multi_key'
import * as test_asset_multi_key_complex from '../bindings/passed/test_asset_multi_key_complex'
import * as test_asset_nth_agg_0 from '../bindings/passed/test_asset_nth_agg_0'
import * as test_asset_nth_agg_1 from '../bindings/passed/test_asset_nth_agg_1'
import * as test_asset_nth_agg_2 from '../bindings/passed/test_asset_nth_agg_2'
import * as test_asset_nth_coll_0 from '../bindings/passed/test_asset_nth_coll_0'
import * as test_asset_nth_coll_1 from '../bindings/passed/test_asset_nth_coll_1'
import * as test_asset_nth_coll_2 from '../bindings/passed/test_asset_nth_coll_2'
import * as test_asset_nth_view_0 from '../bindings/passed/test_asset_nth_view_0'
import * as test_asset_nth_view_1 from '../bindings/passed/test_asset_nth_view_1'
import * as test_asset_nth_view_2 from '../bindings/passed/test_asset_nth_view_2'
import * as test_asset_select_agg_0 from '../bindings/passed/test_asset_select_agg_0'
import * as test_asset_select_agg_1 from '../bindings/passed/test_asset_select_agg_1'
import * as test_asset_select_agg_2 from '../bindings/passed/test_asset_select_agg_2'
import * as test_asset_select_coll_0 from '../bindings/passed/test_asset_select_coll_0'
import * as test_asset_select_coll_1 from '../bindings/passed/test_asset_select_coll_1'
import * as test_asset_select_coll_2 from '../bindings/passed/test_asset_select_coll_2'
import * as test_asset_select_view_0 from '../bindings/passed/test_asset_select_view_0'
import * as test_asset_select_view_1 from '../bindings/passed/test_asset_select_view_1'
import * as test_asset_select_view_2 from '../bindings/passed/test_asset_select_view_2'
import * as test_asset_sort_agg_0 from '../bindings/passed/test_asset_sort_agg_0'
import * as test_asset_sort_agg_1 from '../bindings/passed/test_asset_sort_agg_1'
import * as test_asset_sort_agg_2 from '../bindings/passed/test_asset_sort_agg_2'
import * as test_asset_sort_coll_0 from '../bindings/passed/test_asset_sort_coll_0'
import * as test_asset_sort_coll_1 from '../bindings/passed/test_asset_sort_coll_1'
import * as test_asset_sort_coll_2 from '../bindings/passed/test_asset_sort_coll_2'
import * as test_asset_sort_coll_complex from '../bindings/passed/test_asset_sort_coll_complex'
import * as test_asset_sort_coll_random from '../bindings/passed/test_asset_sort_coll_random'
import * as test_asset_sort_coll_random2 from '../bindings/passed/test_asset_sort_coll_random2'
import * as test_asset_sort_coll_rational from '../bindings/passed/test_asset_sort_coll_rational'
import * as test_asset_sort_view_0 from '../bindings/passed/test_asset_sort_view_0'
import * as test_asset_sort_view_1 from '../bindings/passed/test_asset_sort_view_1'
import * as test_asset_sort_view_2 from '../bindings/passed/test_asset_sort_view_2'
import * as test_asset_sum_agg_0 from '../bindings/passed/test_asset_sum_agg_0'
import * as test_asset_sum_agg_1 from '../bindings/passed/test_asset_sum_agg_1'
import * as test_asset_sum_agg_2 from '../bindings/passed/test_asset_sum_agg_2'
import * as test_asset_sum_coll_0 from '../bindings/passed/test_asset_sum_coll_0'
import * as test_asset_sum_coll_1 from '../bindings/passed/test_asset_sum_coll_1'
import * as test_asset_sum_coll_2 from '../bindings/passed/test_asset_sum_coll_2'
import * as test_asset_sum_coll_rat from '../bindings/passed/test_asset_sum_coll_rat'
import * as test_asset_sum_view_0 from '../bindings/passed/test_asset_sum_view_0'
import * as test_asset_sum_view_1 from '../bindings/passed/test_asset_sum_view_1'
import * as test_asset_sum_view_2 from '../bindings/passed/test_asset_sum_view_2'
import * as test_asset_tail_agg_0 from '../bindings/passed/test_asset_tail_agg_0'
import * as test_asset_tail_agg_1 from '../bindings/passed/test_asset_tail_agg_1'
import * as test_asset_tail_agg_2 from '../bindings/passed/test_asset_tail_agg_2'
import * as test_asset_tail_coll_0 from '../bindings/passed/test_asset_tail_coll_0'
import * as test_asset_tail_coll_1 from '../bindings/passed/test_asset_tail_coll_1'
import * as test_asset_tail_coll_2 from '../bindings/passed/test_asset_tail_coll_2'
import * as test_asset_tail_view_0 from '../bindings/passed/test_asset_tail_view_0'
import * as test_asset_tail_view_1 from '../bindings/passed/test_asset_tail_view_1'
import * as test_asset_tail_view_2 from '../bindings/passed/test_asset_tail_view_2'
import * as test_asset_update from '../bindings/passed/test_asset_update'
import * as test_asset_update_2 from '../bindings/passed/test_asset_update_2'
import * as test_asset_update_3 from '../bindings/passed/test_asset_update_3'
import * as test_asset_update_4 from '../bindings/passed/test_asset_update_4'
import * as test_asset_update_5 from '../bindings/passed/test_asset_update_5'
import * as test_asset_update_aggregate_1 from '../bindings/passed/test_asset_update_aggregate_1'
import * as test_asset_update_aggregate_2 from '../bindings/passed/test_asset_update_aggregate_2'
import * as test_asset_update_aggregate_3 from '../bindings/passed/test_asset_update_aggregate_3'
import * as test_asset_update_partition_1 from '../bindings/passed/test_asset_update_partition_1'
import * as test_asset_update_partition_2 from '../bindings/passed/test_asset_update_partition_2'
import * as test_asset_update_partition_3 from '../bindings/passed/test_asset_update_partition_3'
import * as test_asset_update_partition_4 from '../bindings/passed/test_asset_update_partition_4'
import * as test_asset_update_partition_5 from '../bindings/passed/test_asset_update_partition_5'
import * as test_asset_update_partition_6 from '../bindings/passed/test_asset_update_partition_6'
import * as test_asset_update_partition_7 from '../bindings/passed/test_asset_update_partition_7'
import * as test_asset_update_partition_8 from '../bindings/passed/test_asset_update_partition_8'
import * as test_asset_update_partition_9 from '../bindings/passed/test_asset_update_partition_9'
import * as test_asset_view from '../bindings/passed/test_asset_view'
import * as test_bound_value from '../bindings/passed/test_bound_value'
import * as test_caller_getter from '../bindings/passed/test_caller_getter'
import * as test_cmp_bool from '../bindings/passed/test_cmp_bool'
import * as test_complex_sum from '../bindings/passed/test_complex_sum'
import * as test_conditions from '../bindings/passed/test_conditions'
import * as test_contains_get from '../bindings/passed/test_contains_get'
import * as test_contract from '../bindings/passed/test_contract'
import * as test_contract_self from '../bindings/passed/test_contract_self'
import * as test_create_contract_arl from '../bindings/passed/test_create_contract_arl'
import * as test_create_contract_arl_fa1 from '../bindings/passed/test_create_contract_arl_fa1'
import * as test_create_contract_arl_fa2 from '../bindings/passed/test_create_contract_arl_fa2'
import * as test_create_contract_arl_string from '../bindings/passed/test_create_contract_arl_string'
import * as test_create_contract_arl_with_param from '../bindings/passed/test_create_contract_arl_with_param'
import * as test_create_contract_arl_with_param_const from '../bindings/passed/test_create_contract_arl_with_param_const'
import * as test_create_contract_arl_with_param_with_default from '../bindings/passed/test_create_contract_arl_with_param_with_default'
import * as test_create_contract_bytes from '../bindings/passed/test_create_contract_bytes'
import * as test_create_contract_inline from '../bindings/passed/test_create_contract_inline'
import * as test_create_contract_tz_with_import from '../bindings/passed/test_create_contract_tz_with_import'
import * as test_create_contract_tz_with_path from '../bindings/passed/test_create_contract_tz_with_path'
import * as test_fget from '../bindings/passed/test_fget'
import * as test_for_list_alt from '../bindings/passed/test_for_list_alt'
import * as test_fun0 from '../bindings/passed/test_fun0'
import * as test_fun1 from '../bindings/passed/test_fun1'
import * as test_fun2 from '../bindings/passed/test_fun2'
import * as test_fun3 from '../bindings/passed/test_fun3'
import * as test_fun4 from '../bindings/passed/test_fun4'
import * as test_fun5 from '../bindings/passed/test_fun5'
import * as test_fun6 from '../bindings/passed/test_fun6'
import * as test_fun7 from '../bindings/passed/test_fun7'
import * as test_fun8 from '../bindings/passed/test_fun8'
import * as test_fun_asset from '../bindings/passed/test_fun_asset'
import * as test_fun_asset2 from '../bindings/passed/test_fun_asset2'
import * as test_fun_fail from '../bindings/passed/test_fun_fail'
import * as test_getter from '../bindings/passed/test_getter'
import * as test_getter2 from '../bindings/passed/test_getter2'
import * as test_getter_with_arg from '../bindings/passed/test_getter_with_arg'
import * as test_getter_with_args from '../bindings/passed/test_getter_with_args'
import * as test_global_constant from '../bindings/passed/test_global_constant'
import * as test_if_fail_expr from '../bindings/passed/test_if_fail_expr'
import * as test_if_int_nat from '../bindings/passed/test_if_int_nat'
import * as test_init_asset from '../bindings/passed/test_init_asset'
import * as test_init_asset2 from '../bindings/passed/test_init_asset2'
import * as test_init_asset3 from '../bindings/passed/test_init_asset3'
import * as test_init_rat_with_nat from '../bindings/passed/test_init_rat_with_nat'
import * as test_init_storage_arith from '../bindings/passed/test_init_storage_arith'
import * as test_init_storage_cmp from '../bindings/passed/test_init_storage_cmp'
import * as test_init_storage_funs from '../bindings/passed/test_init_storage_funs'
import * as test_init_storage_literals from '../bindings/passed/test_init_storage_literals'
import * as test_init_storage_simple from '../bindings/passed/test_init_storage_simple'
import * as test_initialized_with from '../bindings/passed/test_initialized_with'
import * as test_initialized_with_asset from '../bindings/passed/test_initialized_with_asset'
import * as test_is_implicit_address from '../bindings/passed/test_is_implicit_address'
import * as test_iter from '../bindings/passed/test_iter'
import * as test_iter2 from '../bindings/passed/test_iter2'
import * as test_length_operations from '../bindings/passed/test_length_operations'
import * as test_list_contains from '../bindings/passed/test_list_contains'
import * as test_list_contains2 from '../bindings/passed/test_list_contains2'
import * as test_list_mynth from '../bindings/passed/test_list_mynth'
import * as test_list_mynth2 from '../bindings/passed/test_list_mynth2'
import * as test_list_mynth3 from '../bindings/passed/test_list_mynth3'
import * as test_list_nth from '../bindings/passed/test_list_nth'
import * as test_metadata from '../bindings/passed/test_metadata'
import * as test_operations from '../bindings/passed/test_operations'
import * as test_oracle from '../bindings/passed/test_oracle'
import * as test_oracle_called from '../bindings/passed/test_oracle_called'
import * as test_parameter from '../bindings/passed/test_parameter'
import * as test_parameter_const from '../bindings/passed/test_parameter_const'
import * as test_prec from '../bindings/passed/test_prec'
import * as test_rational from '../bindings/passed/test_rational'
import * as test_read_asset_after_operation from '../bindings/passed/test_read_asset_after_operation'
import * as test_read_asset_after_update from '../bindings/passed/test_read_asset_after_update'
import * as test_record from '../bindings/passed/test_record'
import * as test_record_access_0 from '../bindings/passed/test_record_access_0'
import * as test_record_access_1 from '../bindings/passed/test_record_access_1'
import * as test_record_access_2 from '../bindings/passed/test_record_access_2'
import * as test_record_access_3 from '../bindings/passed/test_record_access_3'
import * as test_record_assign_1 from '../bindings/passed/test_record_assign_1'
import * as test_record_assign_2 from '../bindings/passed/test_record_assign_2'
import * as test_record_assign_3 from '../bindings/passed/test_record_assign_3'
import * as test_record_assign_full from '../bindings/passed/test_record_assign_full'
import * as test_record_assign_var from '../bindings/passed/test_record_assign_var'
import * as test_record_simple from '../bindings/passed/test_record_simple'
import * as test_remove_asset_with_partition from '../bindings/passed/test_remove_asset_with_partition'
import * as test_removeall_aggregate from '../bindings/passed/test_removeall_aggregate'
import * as test_removeall_aggregate_1 from '../bindings/passed/test_removeall_aggregate_1'
import * as test_removeall_aggregate_2 from '../bindings/passed/test_removeall_aggregate_2'
import * as test_removeall_partition_1 from '../bindings/passed/test_removeall_partition_1'
import * as test_removeall_partition_2 from '../bindings/passed/test_removeall_partition_2'
import * as test_removefield_aggregate_1 from '../bindings/passed/test_removefield_aggregate_1'
import * as test_removefield_aggregate_2 from '../bindings/passed/test_removefield_aggregate_2'
import * as test_removefield_partition_1 from '../bindings/passed/test_removefield_partition_1'
import * as test_removefield_partition_2 from '../bindings/passed/test_removefield_partition_2'
import * as test_removeif_agg_0 from '../bindings/passed/test_removeif_agg_0'
import * as test_removeif_agg_1 from '../bindings/passed/test_removeif_agg_1'
import * as test_removeif_agg_2 from '../bindings/passed/test_removeif_agg_2'
import * as test_removeif_coll_0 from '../bindings/passed/test_removeif_coll_0'
import * as test_removeif_coll_1 from '../bindings/passed/test_removeif_coll_1'
import * as test_removeif_coll_2 from '../bindings/passed/test_removeif_coll_2'
import * as test_removeif_part_0 from '../bindings/passed/test_removeif_part_0'
import * as test_removeif_part_1 from '../bindings/passed/test_removeif_part_1'
import * as test_removeif_part_2 from '../bindings/passed/test_removeif_part_2'
import * as test_result from '../bindings/passed/test_result'
import * as test_split_ticket from '../bindings/passed/test_split_ticket'
import * as test_tez from '../bindings/passed/test_tez'
import * as test_transfer from '../bindings/passed/test_transfer'
import * as test_transition from '../bindings/passed/test_transition'
import * as test_tuple_access_1 from '../bindings/passed/test_tuple_access_1'
import * as test_tuple_access_2 from '../bindings/passed/test_tuple_access_2'
import * as test_tuple_access_3 from '../bindings/passed/test_tuple_access_3'
import * as test_update from '../bindings/passed/test_update'
import * as test_var from '../bindings/passed/test_var'
import * as test_voting from '../bindings/passed/test_voting'
import * as ticket_create_ticket from '../bindings/passed/ticket_create_ticket'
import * as ticket_create_ticket_list_prepend from '../bindings/passed/ticket_create_ticket_list_prepend'
import * as ticket_detach_big_map from '../bindings/passed/ticket_detach_big_map'
import * as ticket_detach_big_map_record from '../bindings/passed/ticket_detach_big_map_record'
import * as ticket_detach_big_map_tuple from '../bindings/passed/ticket_detach_big_map_tuple'
import * as ticket_detach_map from '../bindings/passed/ticket_detach_map'
import * as ticket_detach_map_record from '../bindings/passed/ticket_detach_map_record'
import * as ticket_detach_map_tuple from '../bindings/passed/ticket_detach_map_tuple'
import * as ticket_detach_option from '../bindings/passed/ticket_detach_option'
import * as ticket_fun_join_tickets from '../bindings/passed/ticket_fun_join_tickets'
import * as ticket_fun_split_ticket from '../bindings/passed/ticket_fun_split_ticket'
import * as ticket_in_view from '../bindings/passed/ticket_in_view'
import * as ticket_read_ticket from '../bindings/passed/ticket_read_ticket'
import * as ticket_read_ticket_arg from '../bindings/passed/ticket_read_ticket_arg'
import * as ticket_read_ticket_arg_list from '../bindings/passed/ticket_read_ticket_arg_list'
import * as ticket_read_ticket_arg_record_list from '../bindings/passed/ticket_read_ticket_arg_record_list'
import * as ticket_read_ticket_arg_record_list2 from '../bindings/passed/ticket_read_ticket_arg_record_list2'
import * as ticket_read_ticket_arg_tuple_2_list from '../bindings/passed/ticket_read_ticket_arg_tuple_2_list'
import * as ticket_read_ticket_arg_tuple_3_list from '../bindings/passed/ticket_read_ticket_arg_tuple_3_list'
import * as ticket_read_ticket_record from '../bindings/passed/ticket_read_ticket_record'
import * as ticket_read_ticket_record_list from '../bindings/passed/ticket_read_ticket_record_list'
import * as ticket_record_list_var_0_0 from '../bindings/passed/ticket_record_list_var_0_0'
import * as ticket_record_list_var_0_1 from '../bindings/passed/ticket_record_list_var_0_1'
import * as ticket_record_list_var_0_2 from '../bindings/passed/ticket_record_list_var_0_2'
import * as ticket_record_list_var_1_0 from '../bindings/passed/ticket_record_list_var_1_0'
import * as ticket_record_list_var_1_1 from '../bindings/passed/ticket_record_list_var_1_1'
import * as ticket_record_list_var_1_2 from '../bindings/passed/ticket_record_list_var_1_2'
import * as ticket_record_list_var_2_0 from '../bindings/passed/ticket_record_list_var_2_0'
import * as ticket_record_list_var_2_1 from '../bindings/passed/ticket_record_list_var_2_1'
import * as ticket_record_list_var_2_2 from '../bindings/passed/ticket_record_list_var_2_2'
import * as ticket_record_list_var_3_0 from '../bindings/passed/ticket_record_list_var_3_0'
import * as ticket_record_list_var_3_1 from '../bindings/passed/ticket_record_list_var_3_1'
import * as ticket_record_list_var_3_2 from '../bindings/passed/ticket_record_list_var_3_2'
import * as ticket_store_map from '../bindings/passed/ticket_store_map'
import * as ticket_store_option from '../bindings/passed/ticket_store_option'
import * as ticket_var_detach_option from '../bindings/passed/ticket_var_detach_option'
import * as ticket_var_list from '../bindings/passed/ticket_var_list'
import * as ticket_var_option from '../bindings/passed/ticket_var_option'
import * as ticket_var_or_left from '../bindings/passed/ticket_var_or_left'
import * as ticket_var_or_right from '../bindings/passed/ticket_var_or_right'
import * as ticket_var_simple from '../bindings/passed/ticket_var_simple'
import * as timelock from '../bindings/passed/timelock'
import * as timelock_hardcoded from '../bindings/passed/timelock_hardcoded'
import * as transfer_call from '../bindings/passed/transfer_call'
import * as transfer_entrypoint from '../bindings/passed/transfer_entrypoint'
import * as transfer_entrypoint2 from '../bindings/passed/transfer_entrypoint2'
import * as transfer_op from '../bindings/passed/transfer_op'
import * as transfer_require_entrypoint from '../bindings/passed/transfer_require_entrypoint'
import * as transfer_self from '../bindings/passed/transfer_self'
import * as transfer_simple from '../bindings/passed/transfer_simple'
import * as transfer_simple_with_entrypoint from '../bindings/passed/transfer_simple_with_entrypoint'
import * as tuple_in_contains from '../bindings/passed/tuple_in_contains'
import * as type_never from '../bindings/passed/type_never'
import * as type_or from '../bindings/passed/type_or'
import * as type_set_enum_param from '../bindings/passed/type_set_enum_param'
import * as type_storage_or from '../bindings/passed/type_storage_or'
import * as typetuple from '../bindings/passed/typetuple'
import * as unused_argument from '../bindings/passed/unused_argument'
import * as unused_variable from '../bindings/passed/unused_variable'
import * as unused_variable_opt from '../bindings/passed/unused_variable_opt'
import * as update_minus_equal from '../bindings/passed/update_minus_equal'
import * as var_mult_ids from '../bindings/passed/var_mult_ids'
import * as var_mult_ids_3 from '../bindings/passed/var_mult_ids_3'
import * as var_mult_ids_complex from '../bindings/passed/var_mult_ids_complex'
import * as var_mult_tickets from '../bindings/passed/var_mult_tickets'
import * as var_without_effect from '../bindings/passed/var_without_effect'
import * as variable_in_container from '../bindings/passed/variable_in_container'
import * as very_simple from '../bindings/passed/very_simple'
import * as view_0 from '../bindings/passed/view_0'
import * as view_all_chain from '../bindings/passed/view_all_chain'
import * as view_args_0 from '../bindings/passed/view_args_0'
import * as view_args_1 from '../bindings/passed/view_args_1'
import * as view_args_storage_0 from '../bindings/passed/view_args_storage_0'
import * as view_args_storage_1 from '../bindings/passed/view_args_storage_1'
import * as view_asset from '../bindings/passed/view_asset'
import * as view_exhaustive from '../bindings/passed/view_exhaustive'
import * as view_in_arg from '../bindings/passed/view_in_arg'
import * as view_offchain from '../bindings/passed/view_offchain'
import * as view_offchain_nat from '../bindings/passed/view_offchain_nat'
import * as view_onchain from '../bindings/passed/view_onchain'
import * as view_onchain_offchain from '../bindings/passed/view_onchain_offchain'
import * as view_simple from '../bindings/passed/view_simple'
import * as view_simple_call from '../bindings/passed/view_simple_call'
import * as view_simple_caller from '../bindings/passed/view_simple_caller'
import * as view_storage_0 from '../bindings/passed/view_storage_0'
import * as view_storage_1 from '../bindings/passed/view_storage_1'
import * as view_storage_2 from '../bindings/passed/view_storage_2'
import * as view_storage_3 from '../bindings/passed/view_storage_3'
import * as view_storage_4 from '../bindings/passed/view_storage_4'
import * as view_storage_5 from '../bindings/passed/view_storage_5'
import * as view_with_nat_to_string from '../bindings/passed/view_with_nat_to_string'
import * as view_with_self from '../bindings/passed/view_with_self'
import * as view_with_self_add from '../bindings/passed/view_with_self_add'
import * as with_metadata_json from '../bindings/passed/with_metadata_json'
import * as with_metadata_json_with_offchain_view from '../bindings/passed/with_metadata_json_with_offchain_view'
import * as with_metadata_uri from '../bindings/passed/with_metadata_uri'


const alice = get_account('alice')
const bob = get_account('bob')
const carl = get_account('carl')

/* Verbose mode ------------------------------------------------------------ */

set_quiet(true);

/* Endpoint ---------------------------------------------------------------- */

set_mockup()

/* Tests-------------------------------------------------------------------- */

describe('passed', async () => {

  it('add_update_record', async () => {
    await add_update_record.add_update_record.deploy({ as: alice })
    const res_before = await add_update_record.add_update_record.get_my_asset();
    assert(res_before.length == 1, "Invalid Value")
    assert(res_before[0][0].equals(new Nat(0)), "Invalid Value")
    assert(res_before[0][1].b == false, "Invalid Value")
    assert(res_before[0][1].c.length == 0, "Invalid Value")
    await add_update_record.add_update_record.updateTransferlist({ as: alice })
    const res_after = await add_update_record.add_update_record.get_my_asset()
    assert(res_after.length == 1, "Invalid Value")
    assert(res_after[0][0].equals(new Nat(0)), "Invalid Value")
    assert(res_after[0][1].b == true, "Invalid Value")
    assert(res_after[0][1].c.length == 3, "Invalid Value")
    assert(res_after[0][1].c[0].equals(new Nat(0)), "Invalid Value")
    assert(res_after[0][1].c[1].equals(new Nat(1)), "Invalid Value")
    assert(res_after[0][1].c[2].equals(new Nat(2)), "Invalid Value")
  })

  it('addupdate_partition', async () => {
    await addupdate_partition.addupdate_partition.deploy({ as: alice })
    const res_before = await addupdate_partition.addupdate_partition.get_my_asset();
    assert(res_before.length == 3, "Invalid Value")
    assert(res_before[0][0] == "id0", "Invalid Value")
    assert(res_before[0][1].value.equals(new Nat(0)), "Invalid Value")
    assert(res_before[0][1].col.length == 0, "Invalid Value")
    assert(res_before[1][0] == "id1", "Invalid Value")
    assert(res_before[1][1].value.equals(new Nat(1)), "Invalid Value")
    assert(res_before[1][1].col.length == 0, "Invalid Value")
    assert(res_before[2][0] == "id2", "Invalid Value")
    assert(res_before[2][1].value.equals(new Nat(2)), "Invalid Value")
    assert(res_before[2][1].col.length == 0, "Invalid Value")
    const o_asset_before = await addupdate_partition.addupdate_partition.get_o_asset()
    assert(o_asset_before.length == 0, "Invalid Value")
    await addupdate_partition.addupdate_partition.exec({ as: alice })
    const res_after = await addupdate_partition.addupdate_partition.get_my_asset();
    assert(res_after.length == 3, "Invalid Value")
    assert(res_after[0][0] == "id0", "Invalid Value")
    assert(res_after[0][1].value.equals(new Nat(0)), "Invalid Value")
    assert(res_after[0][1].col.length == 1, "Invalid Value")
    assert(res_after[0][1].col[0] == "oid", "Invalid Value")
    assert(res_after[1][0] == "id1", "Invalid Value")
    assert(res_after[1][1].value.equals(new Nat(1)), "Invalid Value")
    assert(res_after[1][1].col.length == 0, "Invalid Value")
    assert(res_after[2][0] == "id2", "Invalid Value")
    assert(res_after[2][1].value.equals(new Nat(2)), "Invalid Value")
    assert(res_after[2][1].col.length == 0, "Invalid Value")
    const o_asset_after = await addupdate_partition.addupdate_partition.get_o_asset()
    assert(o_asset_after.length == 1, "Invalid Value")
    assert(o_asset_after[0][0] == "oid", "Invalid Value")
    assert(o_asset_after[0][1].equals(new Nat(0)), "Invalid Value")
  })

  it('addupdate_partition2', async () => {
    await addupdate_partition2.addupdate_partition2.deploy({ as: alice })
    const res_before = await addupdate_partition2.addupdate_partition2.get_my_asset();
    assert(res_before.length == 3, "Invalid Value")
    assert(res_before[0][0] == "id0", "Invalid Value")
    assert(res_before[0][1].value.equals(new Nat(0)), "Invalid Value")
    assert(res_before[0][1].col.length == 0, "Invalid Value")
    assert(res_before[1][0] == "id1", "Invalid Value")
    assert(res_before[1][1].value.equals(new Nat(1)), "Invalid Value")
    assert(res_before[1][1].col.length == 0, "Invalid Value")
    assert(res_before[2][0] == "id2", "Invalid Value")
    assert(res_before[2][1].value.equals(new Nat(2)), "Invalid Value")
    assert(res_before[2][1].col.length == 0, "Invalid Value")
    const o_asset_before = await addupdate_partition2.addupdate_partition2.get_o_asset()
    assert(o_asset_before.length == 0, "Invalid Value")
    await addupdate_partition2.addupdate_partition2.exec({ as: alice })
    const res_after = await addupdate_partition2.addupdate_partition2.get_my_asset();
    assert(res_after.length == 3, "Invalid Value")
    assert(res_after[0][0] == "id0", "Invalid Value")
    assert(res_after[0][1].value.equals(new Nat(0)), "Invalid Value")
    assert(res_after[0][1].col.length == 1, "Invalid Value")
    assert(res_after[0][1].col[0] == "oid", "Invalid Value")
    assert(res_after[1][0] == "id1", "Invalid Value")
    assert(res_after[1][1].value.equals(new Nat(1)), "Invalid Value")
    assert(res_after[1][1].col.length == 0, "Invalid Value")
    assert(res_after[2][0] == "id2", "Invalid Value")
    assert(res_after[2][1].value.equals(new Nat(2)), "Invalid Value")
    assert(res_after[2][1].col.length == 0, "Invalid Value")
    const o_asset_after = await addupdate_partition2.addupdate_partition2.get_o_asset()
    assert(o_asset_after.length == 1, "Invalid Value")
    assert(o_asset_after[0][0] == "oid", "Invalid Value")
    assert(o_asset_after[0][1].v.equals(new Nat(0)), "Invalid Value")
    assert(o_asset_after[0][1].v0.equals(new Nat(0)), "Invalid Value")
  })

  it('addupdate_partition_with_no_effect_on_default_value', async () => {
    await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.deploy({ as: alice })
    const my_asset_0 = await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.get_my_asset();
    assert(my_asset_0.length == 1, "Invalid Value")
    assert(my_asset_0[0][0] == "id0", "Invalid Value")
    assert(my_asset_0[0][1].value.equals(new Nat(0)), "Invalid Value")
    assert(my_asset_0[0][1].col.length == 0, "Invalid Value")
    const o_asset_0 = await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.get_o_asset()
    assert(o_asset_0.length == 0, "Invalid Value")

    await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.init({ as: alice })
    const my_asset_init = await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.get_my_asset();
    assert(my_asset_init.length == 1, "Invalid Value")
    assert(my_asset_init[0][0] == "id0", "Invalid Value")
    assert(my_asset_init[0][1].value.equals(new Nat(0)), "Invalid Value")
    assert(my_asset_init[0][1].col.length == 1, "Invalid Value")
    assert(my_asset_init[0][1].col[0] == "oid", "Invalid Value")
    const o_asset_init = await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.get_o_asset()
    assert(o_asset_init.length == 1, "Invalid Value")
    assert(o_asset_init[0][0] == "oid", "Invalid Value")
    assert(o_asset_init[0][1].v.equals(new Nat(0)), "Invalid Value")
    assert(o_asset_init[0][1].c.equals(new Nat(1)), "Invalid Value")

    await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.exec({ as: alice })
    const my_asset_exec = await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.get_my_asset();
    assert(my_asset_exec.length == 1, "Invalid Value")
    assert(my_asset_exec[0][0] == "id0", "Invalid Value")
    assert(my_asset_exec[0][1].value.equals(new Nat(0)), "Invalid Value")
    assert(my_asset_exec[0][1].col.length == 1, "Invalid Value")
    assert(my_asset_exec[0][1].col[0] == "oid", "Invalid Value")
    const o_asset_exec = await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.get_o_asset()
    assert(o_asset_exec.length == 1, "Invalid Value")
    assert(o_asset_exec[0][0] == "oid", "Invalid Value")
    assert(o_asset_exec[0][1].v.equals(new Nat(0)), "Invalid Value")
    // TODO: Bug
    // assert(o_asset_exec[0][1].c.equals(new Nat(1)), "Invalid Value")

    await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.exec2({ as: alice })
    const my_asset_exec2 = await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.get_my_asset();
    assert(my_asset_exec2.length == 1, "Invalid Value")
    assert(my_asset_exec2[0][0] == "id0", "Invalid Value")
    assert(my_asset_exec2[0][1].value.equals(new Nat(0)), "Invalid Value")
    assert(my_asset_exec2[0][1].col.length == 1, "Invalid Value")
    assert(my_asset_exec2[0][1].col[0] == "oid", "Invalid Value")
    const o_asset_exec2 = await addupdate_partition_with_no_effect_on_default_value.addupdate_partition_with_no_effect_on_default_value.get_o_asset()
    assert(o_asset_exec2.length == 1, "Invalid Value")
    assert(o_asset_exec2[0][0] == "oid", "Invalid Value")
    assert(o_asset_exec2[0][1].v.equals(new Nat(1)), "Invalid Value")
    // TODO: Bug
    // assert(o_asset_exec2[0][1].c.equals(new Nat(1)), "Invalid Value")
  })

  it('addupdate_with_no_effect_on_default_value', async () => {
    await addupdate_with_no_effect_on_default_value.addupdate_with_no_effect_on_default_value.deploy({ as: alice })
    const my_asset_0 = await addupdate_with_no_effect_on_default_value.addupdate_with_no_effect_on_default_value.get_my_asset();
    assert(my_asset_0.length == 1, "Invalid Value")
    assert(my_asset_0[0][0] == "id0", "Invalid Value")
    assert(my_asset_0[0][1].v.equals(new Nat(0)), "Invalid Value")
    assert(my_asset_0[0][1].c.equals(new Nat(1)), "Invalid Value")

    await addupdate_with_no_effect_on_default_value.addupdate_with_no_effect_on_default_value.exec({ as: alice })
    const my_asset_exec = await addupdate_with_no_effect_on_default_value.addupdate_with_no_effect_on_default_value.get_my_asset();
    assert(my_asset_exec.length == 1, "Invalid Value")
    assert(my_asset_exec[0][0] == "id0", "Invalid Value")
    assert(my_asset_exec[0][1].v.equals(new Nat(0)), "Invalid Value")
    // TODO: Bug
    // assert(my_asset_exec[0][1].c.equals(new Nat(1)), "Invalid Value")

    await addupdate_with_no_effect_on_default_value.addupdate_with_no_effect_on_default_value.exec2({ as: alice })
    const my_asset_exec2 = await addupdate_with_no_effect_on_default_value.addupdate_with_no_effect_on_default_value.get_my_asset();
    assert(my_asset_exec2.length == 1, "Invalid Value")
    assert(my_asset_exec2[0][0] == "id0", "Invalid Value")
    assert(my_asset_exec2[0][1].v.equals(new Nat(1)), "Invalid Value")
    // TODO: Bug
    // assert(my_asset_exec2[0][1].c.equals(new Nat(1)), "Invalid Value")
  })

  it('annot_enum', async () => {
    await annot_enum.annot_enum.deploy({ as: alice })
    const r_0 = await annot_enum.annot_enum.get_r()
    assert(r_0.equals(new annot_enum.abc(new Nat(1))), "Invalid Value")
    const z_0 = await annot_enum.annot_enum.get_z()
    assert(z_0.equals(new Nat(0)), "Invalid Value")
    await annot_enum.annot_enum.exec([], { as: alice })
    const r_exec = await annot_enum.annot_enum.get_r()
    assert(r_exec.equals(new annot_enum.abc(new Nat(1))), "Invalid Value")
    const z_exec = await annot_enum.annot_enum.get_z()
    assert(z_exec.equals(new Nat(0)), "Invalid Value")
  })

  it('apply_lambda', async () => {
    await apply_lambda.apply_lambda.deploy({ as: alice })
    const res_0 = await apply_lambda.apply_lambda.get_res();
    assert(res_0.equals(new Int(0)), "Invalid Value")
    await apply_lambda.apply_lambda.exec({ as: alice })
    const res_exec = await apply_lambda.apply_lambda.get_res();
    assert(res_exec.equals(new Int(6)), "Invalid Value")
  })

  it('arg_fun_constant', async () => {
    await arg_fun_constant.arg_fun_constant.deploy({ as: alice })
    const res_before = await arg_fun_constant.arg_fun_constant.get_res();
    assert(res_before == false, "Invalid Value")
    await arg_fun_constant.arg_fun_constant.manage_transfers({ as: alice })
    const res_after = await arg_fun_constant.arg_fun_constant.get_res();
    assert(res_after == true, "Invalid Value")
  })

  it('arith_bls', async () => {
    await arith_bls.arith_bls.deploy({ as: alice })
    await arith_bls.arith_bls.exec({ as: alice })
  })

  it('arith_tez', async () => {
    await arith_tez.arith_tez.deploy({ as: carl })

    const amount = new Tez(1)
    const bob_balance_before = await bob.get_balance()

    await arith_tez.arith_tez.exec(bob.get_address(), { as: alice, amount: amount })

    const bob_balance_after = await bob.get_balance()

    assert(bob_balance_before.plus(new Tez(1)).equals(bob_balance_after), "Invalid Value")
  })

  it('ascii_string', async () => {
    await ascii_string.ascii_string.deploy({ as: alice })
    const s_before = await ascii_string.ascii_string.get_s()
    assert(s_before == "", "Invalid Value")
    await ascii_string.ascii_string.exec({ as: alice })
    const s_after = await ascii_string.ascii_string.get_s();
    assert(s_after == " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{}~", "Invalid Value")
  })

  it('asset_access', async () => {
    await asset_access.asset_access.deploy({ as: alice })
    const my_asset_before = await asset_access.asset_access.get_my_asset()
    assert(my_asset_before.length == 1, "Invalid Value")
    assert(my_asset_before[0][0].equals(new Nat(0)), "Invalid Value")
    assert(my_asset_before[0][1].b == "mystr", "Invalid Value")
    assert(my_asset_before[0][1].c.equals(new Bytes("02")), "Invalid Value")
    const x_before = await asset_access.asset_access.get_x()
    assert(x_before.equals(new Bytes("")), "Invalid Value")
    const y_before = await asset_access.asset_access.get_y()
    assert(y_before.equals(Option.None<Bytes>()), "Invalid Value")
    const z_before = await asset_access.asset_access.get_z()
    assert(z_before.equals(new Bytes("")), "Invalid Value")
    await asset_access.asset_access.get_value({ as: alice })
    const my_asset_after = await asset_access.asset_access.get_my_asset()
    assert(my_asset_after.length == 1, "Invalid Value")
    assert(my_asset_after[0][0].equals(new Nat(0)), "Invalid Value")
    assert(my_asset_after[0][1].b == "mystr", "Invalid Value")
    assert(my_asset_after[0][1].c.equals(new Bytes("02")), "Invalid Value")
    const x_after = await asset_access.asset_access.get_x()
    assert(x_after.equals(new Bytes("")), "Invalid Value")
    const y_after = await asset_access.asset_access.get_y()
    assert(y_after.equals(Option.Some(new Bytes("02"))), "Invalid Value")
    const z_after = await asset_access.asset_access.get_z()
    assert(z_after.equals(new Bytes("02")), "Invalid Value")
  })

  it('asset_access_basic', async () => {
    await asset_access_basic.asset_access_basic.deploy({ as: alice })
    const abc_before = await asset_access_basic.asset_access_basic.get_abc()
    assert(abc_before.length == 1, "Invalid Value")
    assert(abc_before[0][0].equals(new Nat(0)), "Invalid Value")
    assert(abc_before[0][1].b == "mystr", "Invalid Value")
    assert(abc_before[0][1].c.equals(new Bytes("")), "Invalid Value")
    await asset_access_basic.asset_access_basic.get_value({ as: alice })
    const abc_after = await asset_access_basic.asset_access_basic.get_abc()
    assert(abc_after.length == 1, "Invalid Value")
    assert(abc_after[0][0].equals(new Nat(0)), "Invalid Value")
    assert(abc_after[0][1].b == "mystr", "Invalid Value")
    assert(abc_after[0][1].c.equals(new Bytes("")), "Invalid Value")
  })

  it('asset_access_option_found', async () => {
    await asset_access_option_found.asset_access_option_found.deploy({ as: alice })
    const abc_before = await asset_access_option_found.asset_access_option_found.get_abc()
    assert(abc_before.length == 1, "Invalid Value")
    assert(abc_before[0][0].equals(new Nat(0)), "Invalid Value")
    assert(abc_before[0][1].b == "mystr", "Invalid Value")
    assert(abc_before[0][1].c.equals(new Bytes("")), "Invalid Value")
    const res_before = await asset_access_option_found.asset_access_option_found.get_res()
    assert(res_before.equals(Option.None<string>()), "Invalid Value")
    await asset_access_option_found.asset_access_option_found.get_value({ as: alice })
    const abc_after = await asset_access_option_found.asset_access_option_found.get_abc()
    assert(abc_after.length == 1, "Invalid Value")
    assert(abc_after[0][0].equals(new Nat(0)), "Invalid Value")
    assert(abc_after[0][1].b == "mystr", "Invalid Value")
    assert(abc_after[0][1].c.equals(new Bytes("")), "Invalid Value")
    const res_after = await asset_access_option_found.asset_access_option_found.get_res()
    assert(res_after.equals(Option.Some<string>("mystr")), "Invalid Value")
  })

  it('asset_access_option_not_found', async () => {
    await asset_access_option_not_found.asset_access_option_not_found.deploy({ as: alice })
    const abc_before = await asset_access_option_not_found.asset_access_option_not_found.get_abc()
    assert(abc_before.length == 1, "Invalid Value")
    assert(abc_before[0][0].equals(new Nat(0)), "Invalid Value")
    assert(abc_before[0][1].b == "mystr", "Invalid Value")
    assert(abc_before[0][1].c.equals(new Bytes("")), "Invalid Value")
    const res_before = await asset_access_option_not_found.asset_access_option_not_found.get_res()
    assert(res_before.equals(Option.None<string>()), "Invalid Value")
    await asset_access_option_not_found.asset_access_option_not_found.get_value({ as: alice })
    const abc_after = await asset_access_option_not_found.asset_access_option_not_found.get_abc()
    assert(abc_after.length == 1, "Invalid Value")
    assert(abc_after[0][0].equals(new Nat(0)), "Invalid Value")
    assert(abc_after[0][1].b == "mystr", "Invalid Value")
    assert(abc_after[0][1].c.equals(new Bytes("")), "Invalid Value")
    const res_after = await asset_access_option_not_found.asset_access_option_not_found.get_res()
    assert(res_after.equals(Option.None<string>()), "Invalid Value")
  })

  it('asset_access_value', async () => {
    await asset_access_value.asset_access_value.deploy({ as: alice })
    const abc_before = await asset_access_value.asset_access_value.get_abc()
    assert(abc_before.length == 1, "Invalid Value")
    assert(abc_before[0][0].equals(new Nat(0)), "Invalid Value")
    assert(abc_before[0][1].b == "mystr", "Invalid Value")
    assert(abc_before[0][1].c.equals(new Bytes("")), "Invalid Value")
    await asset_access_value.asset_access_value.get_value({ as: alice })
    const abc_after = await asset_access_value.asset_access_value.get_abc()
    assert(abc_after.length == 1, "Invalid Value")
    assert(abc_after[0][0].equals(new Nat(0)), "Invalid Value")
    assert(abc_after[0][1].b == "mystr", "Invalid Value")
    assert(abc_after[0][1].c.equals(new Bytes("")), "Invalid Value")
  })

  it('asset_addupdate', async () => {
    await asset_addupdate.asset_addupdate.deploy({ as: alice })
    const my_asset_before = await asset_addupdate.asset_addupdate.get_my_asset()
    assert(my_asset_before.length == 0, "Invalid Value")
    await asset_addupdate.asset_addupdate.exec({ as: alice })
    const my_asset_after = await asset_addupdate.asset_addupdate.get_my_asset()
    assert(my_asset_after.length == 1, "Invalid Value")
    assert(my_asset_after[0][0].equals(alice.get_address()), "Invalid Value")
    assert(my_asset_after[0][1].b.equals(new Nat(2)), "Invalid Value")
    assert(my_asset_after[0][1].c.equals(new Nat(0)), "Invalid Value")
  })

  it('asset_big_map', async () => {
    await asset_big_map.asset_big_map.deploy({ as: alice })
    const id0_my_asset_before = await asset_big_map.asset_big_map.get_my_asset_value("id0")
    assert(id0_my_asset_before?.value.equals(new Int(0)), "Invalid Value")
    assert(id0_my_asset_before?.col.length == 0, "Invalid Value")
    const id1_my_asset_before = await asset_big_map.asset_big_map.get_my_asset_value("id1")
    assert(id1_my_asset_before?.value.equals(new Int(1)), "Invalid Value")
    assert(id1_my_asset_before?.col.length == 0, "Invalid Value")
    const id2_my_asset_before = await asset_big_map.asset_big_map.get_my_asset_value("id2")
    assert(id2_my_asset_before?.value.equals(new Int(2)), "Invalid Value")
    assert(id2_my_asset_before?.col.length == 0, "Invalid Value")
    await asset_big_map.asset_big_map.exec({ as: alice })
    const id0_my_asset_after = await asset_big_map.asset_big_map.get_my_asset_value("id0")
    assert(id0_my_asset_after?.value.equals(new Int(0)), "Invalid Value")
    assert(id0_my_asset_after?.col.length == 0, "Invalid Value")
    const id1_my_asset_after = await asset_big_map.asset_big_map.get_my_asset_value("id1")
    assert(id1_my_asset_after?.value.equals(new Int(1)), "Invalid Value")
    assert(id1_my_asset_after?.col.length == 0, "Invalid Value")
    const id2_my_asset_after = await asset_big_map.asset_big_map.get_my_asset_value("id2")
    assert(id2_my_asset_after?.value.equals(new Int(2)), "Invalid Value")
    assert(id2_my_asset_after?.col.length == 0, "Invalid Value")
  })

  it('asset_big_map_unit_effect_add', async () => {
    await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.deploy({ as: alice })
    const id0_my_asset_before = await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_before !== undefined)
    const id1_my_asset_before = await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_before !== undefined)
    const id2_my_asset_before = await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_before !== undefined)
    const id3_my_asset_before = await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_before === undefined)
    await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.exec({ as: alice })
    const id0_my_asset_after = await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_after !== undefined)
    const id1_my_asset_after = await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_after !== undefined)
    const id2_my_asset_after = await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_after !== undefined)
    const id3_my_asset_after = await asset_big_map_unit_effect_add.asset_big_map_unit_effect_add.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_after !== undefined)
  })

  it('asset_big_map_unit_effect_addupdate', async () => {
    await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.deploy({ as: alice })
    const id0_my_asset_before = await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_before !== undefined)
    const id1_my_asset_before = await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_before !== undefined)
    const id2_my_asset_before = await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_before !== undefined)
    const id3_my_asset_before = await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_before === undefined)
    await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.exec({ as: alice })
    const id0_my_asset_after = await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_after !== undefined)
    const id1_my_asset_after = await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_after !== undefined)
    const id2_my_asset_after = await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_after !== undefined)
    const id3_my_asset_after = await asset_big_map_unit_effect_addupdate.asset_big_map_unit_effect_addupdate.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_after !== undefined)
  })

  it('asset_big_map_unit_effect_remove', async () => {
    await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.deploy({ as: alice })
    const id0_my_asset_before = await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_before !== undefined)
    const id1_my_asset_before = await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_before !== undefined)
    const id2_my_asset_before = await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_before !== undefined)
    const id3_my_asset_before = await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_before === undefined)
    await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.exec({ as: alice })
    const id0_my_asset_after = await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_after !== undefined)
    const id1_my_asset_after = await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_after !== undefined)
    const id2_my_asset_after = await asset_big_map_unit_effect_remove.asset_big_map_unit_effect_remove.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_after === undefined)
  })

  it('asset_big_map_unit_effect_removeall', async () => {
    await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.deploy({ as: alice })
    const id0_my_asset_before = await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_before !== undefined)
    const id1_my_asset_before = await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_before !== undefined)
    const id2_my_asset_before = await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_before !== undefined)
    const id3_my_asset_before = await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_before === undefined)
    await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.exec({ as: alice })
    const id0_my_asset_after = await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_after === undefined)
    const id1_my_asset_after = await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_after === undefined)
    const id2_my_asset_after = await asset_big_map_unit_effect_removeall.asset_big_map_unit_effect_removeall.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_after === undefined)
  })

  it('asset_big_map_unit_effect_update', async () => {
    await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.deploy({ as: alice })
    const id0_my_asset_before = await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_before !== undefined)
    const id1_my_asset_before = await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_before !== undefined)
    const id2_my_asset_before = await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_before !== undefined)
    const id3_my_asset_before = await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_before === undefined)
    await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.exec({ as: alice })
    const id0_my_asset_after = await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_after !== undefined)
    const id1_my_asset_after = await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_after !== undefined)
    const id2_my_asset_after = await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_after !== undefined)
    const id3_my_asset_after = await asset_big_map_unit_effect_update.asset_big_map_unit_effect_update.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_after === undefined)
  })

  it('asset_big_map_unit_expression_contains', async () => {
    await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.deploy({ as: alice })
    const id0_my_asset_before = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_before !== undefined)
    const id1_my_asset_before = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_before !== undefined)
    const id2_my_asset_before = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_before !== undefined)
    const id3_my_asset_before = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_res();
    assert(res_before == false)
    await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.exec({ as: alice })
    const id0_my_asset_after = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_after !== undefined)
    const id1_my_asset_after = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_after !== undefined)
    const id2_my_asset_after = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_after !== undefined)
    const id3_my_asset_after = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_big_map_unit_expression_contains.asset_big_map_unit_expression_contains.get_res();
    assert(res_after == true)
  })

  it('asset_big_map_unit_storage', async () => {
    await asset_big_map_unit_storage.asset_big_map_unit_storage.deploy({ as: alice })
    const id0_my_asset_before = await asset_big_map_unit_storage.asset_big_map_unit_storage.get_my_asset_value(new Nat(0))
    assert(id0_my_asset_before !== undefined)
    const id1_my_asset_before = await asset_big_map_unit_storage.asset_big_map_unit_storage.get_my_asset_value(new Nat(1))
    assert(id1_my_asset_before !== undefined)
    const id2_my_asset_before = await asset_big_map_unit_storage.asset_big_map_unit_storage.get_my_asset_value(new Nat(2))
    assert(id2_my_asset_before !== undefined)
    const id3_my_asset_before = await asset_big_map_unit_storage.asset_big_map_unit_storage.get_my_asset_value(new Nat(3))
    assert(id3_my_asset_before === undefined)
  })

  it('asset_for', async () => {
    await asset_for.asset_for.deploy({ as: alice })
    const my_asset_before = await asset_for.asset_for.get_my_asset()
    assert(my_asset_before.length == 3, "Invalid Value")
    const res_before = await asset_for.asset_for.get_res()
    assert(res_before === "", "Invalid Value")
    await asset_for.asset_for.exec({ as: alice })
    const my_asset_after = await asset_for.asset_for.get_my_asset()
    assert(my_asset_after.length == 3, "Invalid Value")
    const res_after = await asset_for.asset_for.get_res()
    assert(res_after === "mystr_0mystr_1mystr_2", "Invalid Value")
  })

  it('asset_init_by_const_key', async () => {
    await asset_init_by_const_key.asset_init_by_const_key.deploy({ as: alice })
    const my_asset = await asset_init_by_const_key.asset_init_by_const_key.get_my_asset()
    assert(my_asset.length == 2)
    assert(my_asset[0].equals(new Nat(1)))
    assert(my_asset[1].equals(new Nat(2)))
  })

  it('asset_init_by_const_key_parameter', async () => {
    await asset_init_by_const_key_parameter.asset_init_by_const_key_parameter.deploy(new Nat(1), { as: alice })
    const my_asset = await asset_init_by_const_key_parameter.asset_init_by_const_key_parameter.get_my_asset()
    assert(my_asset.length == 1)
    assert(my_asset[0].equals(new Nat(1)))
  })

  it('asset_initializedby_aggregate_empty', async () => {
    await asset_initializedby_aggregate_empty.asset_initializedby_aggregate_empty.deploy({ as: alice })
    const my_asset = await asset_initializedby_aggregate_empty.asset_initializedby_aggregate_empty.get_my_asset()
    assert(my_asset.length == 1)
    assert(my_asset[0][0] == "my_id")
    assert(my_asset[0][1].length == 0)
    const o_asset = await asset_initializedby_aggregate_empty.asset_initializedby_aggregate_empty.get_o_asset()
    assert(o_asset.length == 0)
  })

  it('asset_initializedby_aggregate_filled', async () => {
    await asset_initializedby_aggregate_filled.asset_initializedby_aggregate_filled.deploy({ as: alice })
    const my_asset = await asset_initializedby_aggregate_filled.asset_initializedby_aggregate_filled.get_my_asset()
    assert(my_asset.length == 3)
    assert(my_asset[0][0] == "my_id0")
    assert(my_asset[0][1].length == 3)
    assert(my_asset[0][1][0].equals(new Nat(0)))
    assert(my_asset[0][1][1].equals(new Nat(1)))
    assert(my_asset[0][1][2].equals(new Nat(2)))
    assert(my_asset[1][0] == "my_id1")
    assert(my_asset[1][1].length == 3)
    assert(my_asset[1][1][0].equals(new Nat(3)))
    assert(my_asset[1][1][1].equals(new Nat(4)))
    assert(my_asset[1][1][2].equals(new Nat(5)))
    assert(my_asset[2][0] == "my_id2")
    assert(my_asset[2][1].length == 3)
    assert(my_asset[2][1][0].equals(new Nat(0)))
    assert(my_asset[2][1][1].equals(new Nat(1)))
    assert(my_asset[2][1][2].equals(new Nat(2)))
    const o_asset = await asset_initializedby_aggregate_filled.asset_initializedby_aggregate_filled.get_o_asset()
    assert(o_asset.length == 6)
    assert(o_asset[0][0].equals(new Nat(0)))
    assert(o_asset[0][1] == "str0")
    assert(o_asset[1][0].equals(new Nat(1)))
    assert(o_asset[1][1] == "str1")
    assert(o_asset[2][0].equals(new Nat(2)))
    assert(o_asset[2][1] == "str2")
    assert(o_asset[3][0].equals(new Nat(3)))
    assert(o_asset[3][1] == "str3")
    assert(o_asset[4][0].equals(new Nat(4)))
    assert(o_asset[4][1] == "str4")
    assert(o_asset[5][0].equals(new Nat(5)))
    assert(o_asset[5][1] == "str5")
  })

  it('asset_instructions', async () => {
    await asset_instructions.asset_instructions.deploy({ as: alice })

    const my_asset_before = asset_instructions.asset_instructions.get_my_asset()
    assert((await my_asset_before).length == 0)

    await asset_instructions.asset_instructions.exec({ as: alice })

    const my_asset_after = asset_instructions.asset_instructions.get_my_asset()
    assert((await my_asset_after).length == 0)
  })

  it('asset_iterable_big_map', async () => {
    await asset_iterable_big_map.asset_iterable_big_map.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map.asset_iterable_big_map.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map.asset_iterable_big_map.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map.asset_iterable_big_map.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map.asset_iterable_big_map.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map.asset_iterable_big_map.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map.asset_iterable_big_map.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map.asset_iterable_big_map.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map.asset_iterable_big_map.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map.asset_iterable_big_map.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_effect_add', async () => {
    await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_effect_add.asset_iterable_big_map_effect_add.get_my_asset_value("id3")
    assert(id3_my_asset_after?.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_effect_addupdate', async () => {
    await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(2)))
    const id1_my_asset_after = await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_effect_addupdate.asset_iterable_big_map_effect_addupdate.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_effect_remove', async () => {
    await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.get_my_asset_value("id2")
    assert(id2_my_asset_after === undefined)
    const id3_my_asset_after = await asset_iterable_big_map_effect_remove.asset_iterable_big_map_effect_remove.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_effect_removeall', async () => {
    await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.get_my_asset_value("id0")
    assert(id0_my_asset_after === undefined)
    const id1_my_asset_after = await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.get_my_asset_value("id1")
    assert(id1_my_asset_after === undefined)
    const id2_my_asset_after = await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.get_my_asset_value("id2")
    assert(id2_my_asset_after === undefined)
    const id3_my_asset_after = await asset_iterable_big_map_effect_removeall.asset_iterable_big_map_effect_removeall.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_effect_removeif', async () => {
    await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.get_my_asset_value("id1")
    assert(id1_my_asset_after === undefined)
    const id2_my_asset_after = await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_effect_removeif.asset_iterable_big_map_effect_removeif.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_effect_update', async () => {
    await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(2)))
    const id1_my_asset_after = await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_effect_update.asset_iterable_big_map_effect_update.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_expression_contains', async () => {
    await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_res()
    assert(!res_before)
    await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_contains.asset_iterable_big_map_expression_contains.get_res()
    assert(res_after)
  })

  it('asset_iterable_big_map_expression_count', async () => {
    await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_res()
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_count.asset_iterable_big_map_expression_count.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_expression_get', async () => {
    await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_res()
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_get.asset_iterable_big_map_expression_get.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('asset_iterable_big_map_expression_head', async () => {
    await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_res()
    assert(res_before.length == 0)
    await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_head.asset_iterable_big_map_expression_head.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id1")
  })

  it('asset_iterable_big_map_expression_nth', async () => {
    await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_res()
    assert(res_before == "")
    await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_nth.asset_iterable_big_map_expression_nth.get_res()
    assert(res_after == "id1")
  })

  it('asset_iterable_big_map_expression_select', async () => {
    await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_res()
    assert(res_before.length == 0)
    await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_select.asset_iterable_big_map_expression_select.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id2")
  })

  it('asset_iterable_big_map_expression_sort', async () => {
    await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_res()
    assert(res_before.length == 0)
    await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_sort.asset_iterable_big_map_expression_sort.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] == "id2")
    assert(res_after[1] == "id1")
    assert(res_after[2] == "id0")
  })

  it('asset_iterable_big_map_expression_sum', async () => {
    await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_res()
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_sum.asset_iterable_big_map_expression_sum.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_expression_tail', async () => {
    await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_res()
    assert(res_before.length == 0)
    await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_expression_tail.asset_iterable_big_map_expression_tail.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id1")
    assert(res_after[1] == "id2")
  })

  it('asset_iterable_big_map_instruction_for', async () => {
    await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new Nat(0)))
    const id1_my_asset_before = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new Nat(1)))
    const id2_my_asset_before = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new Nat(2)))
    const id3_my_asset_before = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const counter_before = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_counter()
    assert(counter_before.equals(new Nat(0)))
    await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new Nat(0)))
    const id1_my_asset_after = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new Nat(1)))
    const id2_my_asset_after = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new Nat(2)))
    const id3_my_asset_after = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const counter_after = await asset_iterable_big_map_instruction_for.asset_iterable_big_map_instruction_for.get_counter()
    assert(counter_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_multi_effect_add', async () => {
    await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_add.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_add.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_add.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_add.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_add.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_add.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_effect_add.asset_iterable_big_map_multi_effect_add.get_my_asset_value("id3")
    assert(id3_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_add.my_asset_value(new Nat(3), new Bytes("03"))))
  })

  it('asset_iterable_big_map_multi_effect_addupdate', async () => {
    await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_addupdate.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_addupdate.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_addupdate.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_addupdate.my_asset_value(new Nat(2), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_addupdate.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_addupdate.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_effect_addupdate.asset_iterable_big_map_multi_effect_addupdate.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_multi_effect_remove', async () => {
    await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_remove.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_remove.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_remove.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_remove.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_remove.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.get_my_asset_value("id2")
    assert(id2_my_asset_after === undefined)
    const id3_my_asset_after = await asset_iterable_big_map_multi_effect_remove.asset_iterable_big_map_multi_effect_remove.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_multi_effect_removeall', async () => {
    await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_removeall.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_removeall.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_removeall.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.get_my_asset_value("id0")
    assert(id0_my_asset_after === undefined)
    const id1_my_asset_after = await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.get_my_asset_value("id1")
    assert(id1_my_asset_after === undefined)
    const id2_my_asset_after = await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.get_my_asset_value("id2")
    assert(id2_my_asset_after === undefined)
    const id3_my_asset_after = await asset_iterable_big_map_multi_effect_removeall.asset_iterable_big_map_multi_effect_removeall.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_multi_effect_removeif', async () => {
    await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_removeif.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_removeif.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_removeif.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_removeif.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.get_my_asset_value("id1")
    assert(id1_my_asset_after === undefined)
    const id2_my_asset_after = await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_removeif.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_effect_removeif.asset_iterable_big_map_multi_effect_removeif.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_multi_effect_update', async () => {
    await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_update.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_update.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_effect_update.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_update.my_asset_value(new Nat(2), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_update.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_effect_update.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_effect_update.asset_iterable_big_map_multi_effect_update.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
  })

  it('asset_iterable_big_map_multi_expression_contains', async () => {
    await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_contains.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_contains.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_contains.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_res();
    assert(res_before == false)
    await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_contains.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_contains.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_contains.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_contains.asset_iterable_big_map_multi_expression_contains.get_res();
    assert(res_after == true)
  })

  it('asset_iterable_big_map_multi_expression_count', async () => {
    await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_count.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_count.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_count.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_res();
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_count.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_count.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_count.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_count.asset_iterable_big_map_multi_expression_count.get_res();
    assert(res_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_multi_expression_get', async () => {
    await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_get.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_get.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_get.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_res();
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_get.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_get.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_get.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_get.asset_iterable_big_map_multi_expression_get.get_res();
    assert(res_after.equals(new Nat(2)))
  })

  it('asset_iterable_big_map_multi_expression_head', async () => {
    await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_head.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_head.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_head.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_res();
    assert(res_before.length == 0)
    await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_head.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_head.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_head.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_head.asset_iterable_big_map_multi_expression_head.get_res();
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id1")
  })

  it('asset_iterable_big_map_multi_expression_nth', async () => {
    await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_nth.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_nth.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_nth.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_res();
    assert(res_before == "")
    await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_nth.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_nth.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_nth.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_nth.asset_iterable_big_map_multi_expression_nth.get_res();
    assert(res_after == "id1")
  })

  it('asset_iterable_big_map_multi_expression_select', async () => {
    await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_select.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_select.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_select.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_res();
    assert(res_before.length == 0)
    await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_select.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_select.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_select.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_select.asset_iterable_big_map_multi_expression_select.get_res();
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id2")
  })

  it('asset_iterable_big_map_multi_expression_sort', async () => {
    await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_sort.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_sort.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_sort.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_res();
    assert(res_before.length == 0)
    await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_sort.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_sort.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_sort.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_sort.asset_iterable_big_map_multi_expression_sort.get_res();
    assert(res_after.length == 3)
    assert(res_after[0] == "id2")
    assert(res_after[1] == "id1")
    assert(res_after[2] == "id0")
  })

  it('asset_iterable_big_map_multi_expression_sum', async () => {
    await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_sum.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_sum.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_sum.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_res();
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_sum.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_sum.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_sum.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_sum.asset_iterable_big_map_multi_expression_sum.get_res();
    assert(res_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_multi_expression_tail', async () => {
    await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_tail.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_tail.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_expression_tail.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_res();
    assert(res_before.length == 0)
    await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_tail.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_tail.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_expression_tail.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_expression_tail.asset_iterable_big_map_multi_expression_tail.get_res();
    assert(res_after.length == 2)
    assert(res_after[0] == "id1")
    assert(res_after[1] == "id2")
  })

  it('asset_iterable_big_map_multi_instruction_for', async () => {
    await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.deploy({ as: alice })
    const id0_my_asset_before = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_my_asset_value("id0")
    assert(id0_my_asset_before?.equals(new asset_iterable_big_map_multi_instruction_for.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_before = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_my_asset_value("id1")
    assert(id1_my_asset_before?.equals(new asset_iterable_big_map_multi_instruction_for.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_before = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_my_asset_value("id2")
    assert(id2_my_asset_before?.equals(new asset_iterable_big_map_multi_instruction_for.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_before = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_my_asset_value("id3")
    assert(id3_my_asset_before === undefined)
    const res_before = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_counter()
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.exec({ as: alice })
    const id0_my_asset_after = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_my_asset_value("id0")
    assert(id0_my_asset_after?.equals(new asset_iterable_big_map_multi_instruction_for.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset_after = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_my_asset_value("id1")
    assert(id1_my_asset_after?.equals(new asset_iterable_big_map_multi_instruction_for.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset_after = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_my_asset_value("id2")
    assert(id2_my_asset_after?.equals(new asset_iterable_big_map_multi_instruction_for.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset_after = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_my_asset_value("id3")
    assert(id3_my_asset_after === undefined)
    const res_after = await asset_iterable_big_map_multi_instruction_for.asset_iterable_big_map_multi_instruction_for.get_counter()
    assert(res_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_multi_storage', async () => {
    await asset_iterable_big_map_multi_storage.asset_iterable_big_map_multi_storage.deploy({ as: alice })
    const id0_my_asset = await asset_iterable_big_map_multi_storage.asset_iterable_big_map_multi_storage.get_my_asset_value("id0")
    assert(id0_my_asset?.equals(new asset_iterable_big_map_multi_storage.my_asset_value(new Nat(0), new Bytes("00"))))
    const id1_my_asset = await asset_iterable_big_map_multi_storage.asset_iterable_big_map_multi_storage.get_my_asset_value("id1")
    assert(id1_my_asset?.equals(new asset_iterable_big_map_multi_storage.my_asset_value(new Nat(1), new Bytes("01"))))
    const id2_my_asset = await asset_iterable_big_map_multi_storage.asset_iterable_big_map_multi_storage.get_my_asset_value("id2")
    assert(id2_my_asset?.equals(new asset_iterable_big_map_multi_storage.my_asset_value(new Nat(2), new Bytes("02"))))
    const id3_my_asset = await asset_iterable_big_map_multi_storage.asset_iterable_big_map_multi_storage.get_my_asset_value("id3")
    assert(id3_my_asset === undefined)
  })

  it('asset_iterable_big_map_storage', async () => {
    await asset_iterable_big_map_storage.asset_iterable_big_map_storage.deploy({ as: alice })
    const id0_my_asset = await asset_iterable_big_map_storage.asset_iterable_big_map_storage.get_my_asset_value("id0")
    assert(id0_my_asset?.equals(new Nat(0)))
    const id1_my_asset = await asset_iterable_big_map_storage.asset_iterable_big_map_storage.get_my_asset_value("id1")
    assert(id1_my_asset?.equals(new Nat(1)))
    const id2_my_asset = await asset_iterable_big_map_storage.asset_iterable_big_map_storage.get_my_asset_value("id2")
    assert(id2_my_asset?.equals(new Nat(2)))
    const id3_my_asset = await asset_iterable_big_map_storage.asset_iterable_big_map_storage.get_my_asset_value("id3")
    assert(id3_my_asset === undefined)
  })

  it('asset_iterable_big_map_unit', async () => {
    await asset_iterable_big_map_unit.asset_iterable_big_map_unit.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit.asset_iterable_big_map_unit.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit.asset_iterable_big_map_unit.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit.asset_iterable_big_map_unit.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit.asset_iterable_big_map_unit.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    await asset_iterable_big_map_unit.asset_iterable_big_map_unit.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit.asset_iterable_big_map_unit.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit.asset_iterable_big_map_unit.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit.asset_iterable_big_map_unit.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit.asset_iterable_big_map_unit.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
  })

  it('asset_iterable_big_map_unit_effect_add', async () => {
    await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_effect_add.asset_iterable_big_map_unit_effect_add.has_my_asset_value(new Nat(3))
    assert(has_3_after == true)
  })

  it('asset_iterable_big_map_unit_effect_addupdate', async () => {
    await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_effect_addupdate.asset_iterable_big_map_unit_effect_addupdate.has_my_asset_value(new Nat(3))
    assert(has_3_after == true)
  })

  it('asset_iterable_big_map_unit_effect_remove', async () => {
    await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.has_my_asset_value(new Nat(2))
    assert(has_2_after == false)
    const has_3_after = await asset_iterable_big_map_unit_effect_remove.asset_iterable_big_map_unit_effect_remove.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
  })

  it('asset_iterable_big_map_unit_effect_removeall', async () => {
    await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.has_my_asset_value(new Nat(0))
    assert(has_0_after == false)
    const has_1_after = await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.has_my_asset_value(new Nat(1))
    assert(has_1_after == false)
    const has_2_after = await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.has_my_asset_value(new Nat(2))
    assert(has_2_after == false)
    const has_3_after = await asset_iterable_big_map_unit_effect_removeall.asset_iterable_big_map_unit_effect_removeall.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
  })

  it('asset_iterable_big_map_unit_effect_removeif', async () => {
    await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.has_my_asset_value(new Nat(1))
    assert(has_1_after == false)
    const has_2_after = await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_effect_removeif.asset_iterable_big_map_unit_effect_removeif.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
  })

  it('asset_iterable_big_map_unit_effect_update', async () => {
    await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_effect_update.asset_iterable_big_map_unit_effect_update.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
  })

  it('asset_iterable_big_map_unit_expression_contains', async () => {
    await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.get_res();
    assert(res_before == false)
    await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_expression_contains.asset_iterable_big_map_unit_expression_contains.get_res();
    assert(res_after == true)
  })

  it('asset_iterable_big_map_unit_expression_count', async () => {
    await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.get_res();
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_expression_count.asset_iterable_big_map_unit_expression_count.get_res();
    assert(res_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_unit_expression_head', async () => {
    await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.get_res();
    assert(res_before.length == 0)
    await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_expression_head.asset_iterable_big_map_unit_expression_head.get_res();
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('asset_iterable_big_map_unit_expression_nth', async () => {
    await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.get_res();
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_expression_nth.asset_iterable_big_map_unit_expression_nth.get_res();
    assert(res_after.equals(new Nat(1)))
  })

  it('asset_iterable_big_map_unit_expression_select', async () => {
    await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.get_res();
    assert(res_before.length == 0)
    await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_expression_select.asset_iterable_big_map_unit_expression_select.get_res();
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('asset_iterable_big_map_unit_expression_sort', async () => {
    await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.get_res();
    assert(res_before.length == 0)
    await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_expression_sort.asset_iterable_big_map_unit_expression_sort.get_res();
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('asset_iterable_big_map_unit_expression_sum', async () => {
    await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.get_res();
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_expression_sum.asset_iterable_big_map_unit_expression_sum.get_res();
    assert(res_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_unit_expression_tail', async () => {
    await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.get_res();
    assert(res_before.length == 0)
    await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_expression_tail.asset_iterable_big_map_unit_expression_tail.get_res();
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('asset_iterable_big_map_unit_instruction_for', async () => {
    await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.deploy({ as: alice })
    const has_0_before = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.has_my_asset_value(new Nat(0))
    assert(has_0_before == true)
    const has_1_before = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.has_my_asset_value(new Nat(1))
    assert(has_1_before == true)
    const has_2_before = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.has_my_asset_value(new Nat(2))
    assert(has_2_before == true)
    const has_3_before = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.has_my_asset_value(new Nat(3))
    assert(has_3_before == false)
    const res_before = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.get_counter()
    assert(res_before.equals(new Nat(0)))
    await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.exec({ as: alice })
    const has_0_after = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.has_my_asset_value(new Nat(0))
    assert(has_0_after == true)
    const has_1_after = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.has_my_asset_value(new Nat(1))
    assert(has_1_after == true)
    const has_2_after = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.has_my_asset_value(new Nat(2))
    assert(has_2_after == true)
    const has_3_after = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.has_my_asset_value(new Nat(3))
    assert(has_3_after == false)
    const res_after = await asset_iterable_big_map_unit_instruction_for.asset_iterable_big_map_unit_instruction_for.get_counter();
    assert(res_after.equals(new Nat(3)))
  })

  it('asset_iterable_big_map_unit_storage', async () => {
    await asset_iterable_big_map_unit_storage.asset_iterable_big_map_unit_storage.deploy({ as: alice })
    const has_0 = await asset_iterable_big_map_unit_storage.asset_iterable_big_map_unit_storage.has_my_asset_value(new Nat(0))
    assert(has_0 == true)
    const has_1 = await asset_iterable_big_map_unit_storage.asset_iterable_big_map_unit_storage.has_my_asset_value(new Nat(1))
    assert(has_1 == true)
    const has_2 = await asset_iterable_big_map_unit_storage.asset_iterable_big_map_unit_storage.has_my_asset_value(new Nat(2))
    assert(has_2 == true)
    const has_3 = await asset_iterable_big_map_unit_storage.asset_iterable_big_map_unit_storage.has_my_asset_value(new Nat(3))
    assert(has_3 == false)
  })

  it('asset_key_in_record', async () => {
    await asset_key_in_record.asset_key_in_record.deploy({ as: alice })
    const my_asset_before = await asset_key_in_record.asset_key_in_record.get_my_asset();
    assert(my_asset_before.length == 0)
    await asset_key_in_record.asset_key_in_record.exec({ as: alice })
    const my_asset_after = await asset_key_in_record.asset_key_in_record.get_my_asset();
    assert(my_asset_after.length == 0)
  })

  it('asset_key_tuple', async () => {
    await asset_key_tuple.asset_key_tuple.deploy({ as: alice })
    const my_asset_before = await asset_key_tuple.asset_key_tuple.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0][0].equals(new Int(3)))
    assert(my_asset_before[0][0][1].equals(new Nat(4)))
    assert(my_asset_before[0][1] == "value")
    await asset_key_tuple.asset_key_tuple.exec({ as: alice })
    const my_asset_after = await asset_key_tuple.asset_key_tuple.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0][0].equals(new Int(3)))
    assert(my_asset_after[0][0][1].equals(new Nat(4)))
    assert(my_asset_after[0][1] == "value")
  })

  it('asset_not_found', async () => {
    await asset_not_found.asset_not_found.deploy({ as: alice })
    const my_asset_before = await asset_not_found.asset_not_found.get_my_asset()
    assert(my_asset_before.length == 0)
    expect_to_fail(async () => {
      await asset_not_found.asset_not_found.exec({ as: alice })
    }, { prim: "Pair", args: [{ string: "ASSET_NOT_FOUND" }, { string: "my_asset" }] })
  })

  it('asset_nth', async () => {
    await asset_nth.asset_nth.deploy({ as: alice })
    const my_asset_before = await asset_nth.asset_nth.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await asset_nth.asset_nth.get_res();
    assert(res_before.equals(Option.None<string>()))
    await asset_nth.asset_nth.exec({ as: alice })
    const my_asset_after = await asset_nth.asset_nth.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    const res_after = await asset_nth.asset_nth.get_res();
    assert(res_after.equals(Option.None<string>()))
  })

  it('asset_put_single', async () => {
    await asset_put_single.asset_put_single.deploy({ as: alice })
    const abc_before = await asset_put_single.asset_put_single.get_abc()
    assert(abc_before.length == 1)
    assert(abc_before[0][0].equals(new Nat(0)))
    assert(abc_before[0][1].equals(new asset_put_single.abc_value("mystr", new Bytes(""))))
    await asset_put_single.asset_put_single.exec({ as: alice })
    const abc_after = await asset_put_single.asset_put_single.get_abc()
    assert(abc_after.length == 1)
    assert(abc_after[0][0].equals(new Nat(0)))
    assert(abc_after[0][1].equals(new asset_put_single.abc_value("toto", new Bytes("02"))))
  })

  it('asset_simple', async () => {
    await asset_simple.asset_simple.deploy({ as: alice })
    const my_asset_before = await asset_simple.asset_simple.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr_0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr_1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr_2")
    await asset_simple.asset_simple.exec({ as: alice })
    const my_asset_after = await asset_simple.asset_simple.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr_0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr_1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr_2")
  })

  it('asset_simple_to_big_map', async () => {
    await asset_simple_to_big_map.asset_simple_to_big_map.deploy({ as: alice })
    const id_0_before = await asset_simple_to_big_map.asset_simple_to_big_map.get_my_asset_value(new Nat(0))
    assert(id_0_before == "mystr_0")
    const id_1_before = await asset_simple_to_big_map.asset_simple_to_big_map.get_my_asset_value(new Nat(1))
    assert(id_1_before == "mystr_1")
    const id_2_before = await asset_simple_to_big_map.asset_simple_to_big_map.get_my_asset_value(new Nat(2))
    assert(id_2_before == "mystr_2")
    const id_3_before = await asset_simple_to_big_map.asset_simple_to_big_map.get_my_asset_value(new Nat(3))
    assert(id_3_before == undefined)
    await asset_simple_to_big_map.asset_simple_to_big_map.exec({ as: alice })
    const id_0_after = await asset_simple_to_big_map.asset_simple_to_big_map.get_my_asset_value(new Nat(0))
    assert(id_0_after == "mystr_0")
    const id_1_after = await asset_simple_to_big_map.asset_simple_to_big_map.get_my_asset_value(new Nat(1))
    assert(id_1_after == "mystr_1")
    const id_2_after = await asset_simple_to_big_map.asset_simple_to_big_map.get_my_asset_value(new Nat(2))
    assert(id_2_after == "mystr_2")
    const id_3_after = await asset_simple_to_big_map.asset_simple_to_big_map.get_my_asset_value(new Nat(3))
    assert(id_3_after == undefined)
  })

  it('asset_simple_to_iterable_big_map', async () => {
    await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.deploy({ as: alice })
    const id_0_before = await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.get_my_asset_value(new Nat(0))
    assert(id_0_before == "mystr_0")
    const id_1_before = await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.get_my_asset_value(new Nat(1))
    assert(id_1_before == "mystr_1")
    const id_2_before = await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.get_my_asset_value(new Nat(2))
    assert(id_2_before == "mystr_2")
    const id_3_before = await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.get_my_asset_value(new Nat(3))
    assert(id_3_before == undefined)
    await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.exec({ as: alice })
    const id_0_after = await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.get_my_asset_value(new Nat(0))
    assert(id_0_after == "mystr_0")
    const id_1_after = await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.get_my_asset_value(new Nat(1))
    assert(id_1_after == "mystr_1")
    const id_2_after = await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.get_my_asset_value(new Nat(2))
    assert(id_2_after == "mystr_2")
    const id_3_after = await asset_simple_to_iterable_big_map.asset_simple_to_iterable_big_map.get_my_asset_value(new Nat(3))
    assert(id_3_after == undefined)
  })

  it('asset_tern_opt', async () => {
    await asset_tern_opt.asset_tern_opt.deploy({ as: alice })
    const my_asset_before = await asset_tern_opt.asset_tern_opt.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await asset_tern_opt.asset_tern_opt.get_res();
    assert(res_before.length == 0)
    await asset_tern_opt.asset_tern_opt.exec({ as: alice })
    const my_asset_after = await asset_tern_opt.asset_tern_opt.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await asset_tern_opt.asset_tern_opt.get_res();
    assert(res_after.length == 1)
    assert(res_after[0].equals(new Nat(2)))
  })

  it('asset_ternary_expr_found', async () => {
    await asset_ternary_expr_found.asset_ternary_expr_found.deploy({ as: alice })
    const abc_before = await asset_ternary_expr_found.asset_ternary_expr_found.get_abc()
    assert(abc_before.length == 1)
    assert(abc_before[0][0].equals(new Nat(0)))
    assert(abc_before[0][1].equals(new Nat(2)))
    const res_before = await asset_ternary_expr_found.asset_ternary_expr_found.get_res();
    assert(res_before == false)
    await asset_ternary_expr_found.asset_ternary_expr_found.exec({ as: alice })
    const abc_after = await asset_ternary_expr_found.asset_ternary_expr_found.get_abc()
    assert(abc_after.length == 1)
    assert(abc_after[0][0].equals(new Nat(0)))
    assert(abc_after[0][1].equals(new Nat(2)))
    const res_after = await asset_ternary_expr_found.asset_ternary_expr_found.get_res();
    assert(res_after == true)
  })

  it('asset_ternary_expr_notfound', async () => {
    await asset_ternary_expr_notfound.asset_ternary_expr_notfound.deploy({ as: alice })
    const abc_before = await asset_ternary_expr_notfound.asset_ternary_expr_notfound.get_abc()
    assert(abc_before.length == 1)
    assert(abc_before[0][0].equals(new Nat(0)))
    assert(abc_before[0][1].equals(new Nat(2)))
    const res_before = await asset_ternary_expr_notfound.asset_ternary_expr_notfound.get_res();
    assert(res_before == true)
    await asset_ternary_expr_notfound.asset_ternary_expr_notfound.exec({ as: alice })
    const abc_after = await asset_ternary_expr_notfound.asset_ternary_expr_notfound.get_abc()
    assert(abc_after.length == 1)
    assert(abc_after[0][0].equals(new Nat(0)))
    assert(abc_after[0][1].equals(new Nat(2)))
    const res_after = await asset_ternary_expr_notfound.asset_ternary_expr_notfound.get_res();
    assert(res_after == false)
  })

  it('asset_types_get', async () => {
    await asset_types_get.asset_types_get.deploy({ as: alice })
    const abc_before = await asset_types_get.asset_types_get.get_abc()
    assert(abc_before.length == 1)
    assert(abc_before[0][0].equals(new Nat(0)))
    assert(abc_before[0][1].b == "mystr")
    assert(abc_before[0][1].c.equals(new Bytes("")))
    await asset_types_get.asset_types_get.get_value({ as: alice })
    const abc_after = await asset_types_get.asset_types_get.get_abc()
    assert(abc_after.length == 1)
    assert(abc_after[0][0].equals(new Nat(0)))
    assert(abc_after[0][1].b == "mystr")
    assert(abc_after[0][1].c.equals(new Bytes("")))
  })

  it('asset_update_with_basic_container_map_lit_add', async () => {
    await asset_update_with_basic_container_map_lit_add.asset_update_with_basic_container_map_lit_add.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_map_lit_add.asset_update_with_basic_container_map_lit_add.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_map_lit_add.asset_update_with_basic_container_map_lit_add.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_map_lit_add.asset_update_with_basic_container_map_lit_add.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 3)
    assert(my_asset_after[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[0][1] == "0")
    assert(my_asset_after[1][1].c[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].c[1][1] == "1")
    assert(my_asset_after[1][1].c[2][0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[2][1] == "2")
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_map_lit_remove', async () => {
    await asset_update_with_basic_container_map_lit_remove.asset_update_with_basic_container_map_lit_remove.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_map_lit_remove.asset_update_with_basic_container_map_lit_remove.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[0][1] == "0")
    assert(my_asset_before[1][1].c[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].c[1][1] == "1")
    assert(my_asset_before[1][1].c[2][0].equals(new Nat(2)))
    assert(my_asset_before[1][1].c[2][1] == "2")
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_map_lit_remove.asset_update_with_basic_container_map_lit_remove.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_map_lit_remove.asset_update_with_basic_container_map_lit_remove.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[0][1] == "0")
    assert(my_asset_after[1][1].c[1][0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1][1] == "2")
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_map_var_list_add', async () => {
    await asset_update_with_basic_container_map_var_list_add.asset_update_with_basic_container_map_var_list_add.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_map_var_list_add.asset_update_with_basic_container_map_var_list_add.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_map_var_list_add.asset_update_with_basic_container_map_var_list_add.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_map_var_list_add.asset_update_with_basic_container_map_var_list_add.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 3)
    assert(my_asset_after[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[0][1] == "0")
    assert(my_asset_after[1][1].c[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].c[1][1] == "1")
    assert(my_asset_after[1][1].c[2][0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[2][1] == "2")
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_map_var_list_remove', async () => {
    await asset_update_with_basic_container_map_var_list_remove.asset_update_with_basic_container_map_var_list_remove.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_map_var_list_remove.asset_update_with_basic_container_map_var_list_remove.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[0][1] == "0")
    assert(my_asset_before[1][1].c[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].c[1][1] == "1")
    assert(my_asset_before[1][1].c[2][0].equals(new Nat(2)))
    assert(my_asset_before[1][1].c[2][1] == "2")
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_map_var_list_remove.asset_update_with_basic_container_map_var_list_remove.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_map_var_list_remove.asset_update_with_basic_container_map_var_list_remove.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[0][1] == "0")
    assert(my_asset_after[1][1].c[1][0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1][1] == "2")
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_map_var_set_add', async () => {
    await asset_update_with_basic_container_map_var_set_add.asset_update_with_basic_container_map_var_set_add.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_map_var_set_add.asset_update_with_basic_container_map_var_set_add.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_map_var_set_add.asset_update_with_basic_container_map_var_set_add.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_map_var_set_add.asset_update_with_basic_container_map_var_set_add.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 3)
    assert(my_asset_after[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[0][1] == "0")
    assert(my_asset_after[1][1].c[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].c[1][1] == "1")
    assert(my_asset_after[1][1].c[2][0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[2][1] == "2")
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_map_var_set_remove', async () => {
    await asset_update_with_basic_container_map_var_set_remove.asset_update_with_basic_container_map_var_set_remove.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_map_var_set_remove.asset_update_with_basic_container_map_var_set_remove.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[0][1] == "0")
    assert(my_asset_before[1][1].c[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].c[1][1] == "1")
    assert(my_asset_before[1][1].c[2][0].equals(new Nat(2)))
    assert(my_asset_before[1][1].c[2][1] == "2")
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_map_var_set_remove.asset_update_with_basic_container_map_var_set_remove.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_map_var_set_remove.asset_update_with_basic_container_map_var_set_remove.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0][0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[0][1] == "0")
    assert(my_asset_after[1][1].c[1][0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1][1] == "2")
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_set_lit_add', async () => {
    await asset_update_with_basic_container_set_lit_add.asset_update_with_basic_container_set_lit_add.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_set_lit_add.asset_update_with_basic_container_set_lit_add.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_set_lit_add.asset_update_with_basic_container_set_lit_add.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_set_lit_add.asset_update_with_basic_container_set_lit_add.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 3)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(1)))
    assert(my_asset_after[1][1].c[2].equals(new Nat(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_set_lit_remove', async () => {
    await asset_update_with_basic_container_set_lit_remove.asset_update_with_basic_container_set_lit_remove.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_set_lit_remove.asset_update_with_basic_container_set_lit_remove.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[1].equals(new Nat(1)))
    assert(my_asset_before[1][1].c[2].equals(new Nat(2)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_set_lit_remove.asset_update_with_basic_container_set_lit_remove.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_set_lit_remove.asset_update_with_basic_container_set_lit_remove.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_set_var_list_add', async () => {
    await asset_update_with_basic_container_set_var_list_add.asset_update_with_basic_container_set_var_list_add.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_set_var_list_add.asset_update_with_basic_container_set_var_list_add.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_set_var_list_add.asset_update_with_basic_container_set_var_list_add.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_set_var_list_add.asset_update_with_basic_container_set_var_list_add.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 3)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(1)))
    assert(my_asset_after[1][1].c[2].equals(new Nat(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_set_var_list_remove', async () => {
    await asset_update_with_basic_container_set_var_list_remove.asset_update_with_basic_container_set_var_list_remove.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_set_var_list_remove.asset_update_with_basic_container_set_var_list_remove.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[1].equals(new Nat(1)))
    assert(my_asset_before[1][1].c[2].equals(new Nat(2)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_set_var_list_remove.asset_update_with_basic_container_set_var_list_remove.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_set_var_list_remove.asset_update_with_basic_container_set_var_list_remove.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_set_var_set_add', async () => {
    await asset_update_with_basic_container_set_var_set_add.asset_update_with_basic_container_set_var_set_add.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_set_var_set_add.asset_update_with_basic_container_set_var_set_add.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_set_var_set_add.asset_update_with_basic_container_set_var_set_add.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_set_var_set_add.asset_update_with_basic_container_set_var_set_add.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 3)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(1)))
    assert(my_asset_after[1][1].c[2].equals(new Nat(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('asset_update_with_basic_container_set_var_set_remove', async () => {
    await asset_update_with_basic_container_set_var_set_remove.asset_update_with_basic_container_set_var_set_remove.deploy({ as: alice })
    const my_asset_before = await asset_update_with_basic_container_set_var_set_remove.asset_update_with_basic_container_set_var_set_remove.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[1].equals(new Nat(1)))
    assert(my_asset_before[1][1].c[2].equals(new Nat(2)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    await asset_update_with_basic_container_set_var_set_remove.asset_update_with_basic_container_set_var_set_remove.exec({ as: alice })
    const my_asset_after = await asset_update_with_basic_container_set_var_set_remove.asset_update_with_basic_container_set_var_set_remove.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
  })

  it('assign_add_record', async () => {
    await assign_add_record.assign_add_record.deploy({ as: alice })
    const res_before = await assign_add_record.assign_add_record.get_res();
    assert(res_before.equals(new assign_add_record.r("", new Nat(0))))
    await assign_add_record.assign_add_record.exec({ as: alice })
    const res_after = await assign_add_record.assign_add_record.get_res();
    assert(res_after.equals(new assign_add_record.r("", new Nat(2))))
  })

  it('assign_add_tuple', async () => {
    await assign_add_tuple.assign_add_tuple.deploy({ as: alice })
    const res_before = await assign_add_tuple.assign_add_tuple.get_res();
    assert(res_before[0].equals(new Nat(0)))
    assert(res_before[1].equals(new Nat(0)))
    assert(res_before[2].equals(new Nat(0)))
    await assign_add_tuple.assign_add_tuple.exec({ as: alice })
    const res_after = await assign_add_tuple.assign_add_tuple.get_res();
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(0)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('assign_field', async () => {
    await assign_field.assign_field.deploy({ as: alice })
    const myasset_before = await assign_field.assign_field.get_myasset();
    assert(myasset_before[0][0].equals(new Nat(0)))
    assert(myasset_before[0][1] == "")
    await assign_field.assign_field.exec({ as: alice })
    const myasset_after = await assign_field.assign_field.get_myasset();
    assert(myasset_after[0][0].equals(new Nat(0)))
    assert(myasset_after[0][1] == "mystr")
  })

  it('assign_minus_nat', async () => {
    await assign_minus_nat.assign_minus_nat.deploy({ as: alice })
    const n_before = await assign_minus_nat.assign_minus_nat.get_n();
    assert(n_before.equals(new Nat(10)))
    await assign_minus_nat.assign_minus_nat.exec({ as: alice })
    const n_after = await assign_minus_nat.assign_minus_nat.get_n();
    assert(n_after.equals(new Nat(9)))
  })

  it('assign_opt', async () => {
    await assign_opt.assign_opt.deploy({ as: alice })
    const res_before = await assign_opt.assign_opt.get_res();
    assert(res_before.equals(new Nat(0)))
    await assign_opt.assign_opt.exec({ as: alice })
    const res_after = await assign_opt.assign_opt.get_res();
    assert(res_after.equals(new Nat(2)))
  })

  it('assign_var_rat_int', async () => {
    await assign_var_rat_int.assign_var_rat_int.deploy({ as: alice })
    const res_before = await assign_var_rat_int.assign_var_rat_int.get_res();
    assert(res_before.equals(new Rational(0)))
    await assign_var_rat_int.assign_var_rat_int.exec({ as: alice })
    const res_after = await assign_var_rat_int.assign_var_rat_int.get_res();
    assert(res_after.equals(new Rational(1)))
  })

  it('assign_vardecl_rat_int', async () => {
    await assign_vardecl_rat_int.assign_vardecl_rat_int.deploy({ as: alice })
    const res_before = await assign_vardecl_rat_int.assign_vardecl_rat_int.get_res();
    assert(res_before.equals(new Rational(0)))
    await assign_vardecl_rat_int.assign_vardecl_rat_int.exec({ as: alice })
    const res_after = await assign_vardecl_rat_int.assign_vardecl_rat_int.get_res();
    assert(res_after.equals(new Rational(1)))
  })

  it('assign_vardecl_rat_nat', async () => {
    await assign_vardecl_rat_nat.assign_vardecl_rat_nat.deploy({ as: alice })
    const res_before = await assign_vardecl_rat_nat.assign_vardecl_rat_nat.get_res();
    assert(res_before.equals(new Rational(0)))
    await assign_vardecl_rat_nat.assign_vardecl_rat_nat.exec({ as: alice })
    const res_after = await assign_vardecl_rat_nat.assign_vardecl_rat_nat.get_res();
    assert(res_after.equals(new Rational(1)))
  })

  it('before_asset_api', async () => {
    await before_asset_api.before_asset_api.deploy({ as: alice })
    const myasset_before = await before_asset_api.before_asset_api.get_myasset();
    assert(myasset_before[0][0].equals(new Nat(1)))
    assert(myasset_before[0][1] == "str1")
    assert(myasset_before[1][0].equals(new Nat(2)))
    assert(myasset_before[1][1] == "str2")
    assert(myasset_before[2][0].equals(new Nat(3)))
    assert(myasset_before[2][1] == "str3")
    await before_asset_api.before_asset_api.exec({ as: alice })
    const myasset_after = await before_asset_api.before_asset_api.get_myasset();
    assert(myasset_after[0][0].equals(new Nat(1)))
    assert(myasset_after[0][1] == "str1")
    assert(myasset_after[1][0].equals(new Nat(2)))
    assert(myasset_after[1][1] == "str2")
    assert(myasset_after[2][0].equals(new Nat(3)))
    assert(myasset_after[2][1] == "str3")
  })

  it('before_var', async () => {
    await before_var.before_var.deploy({ as: alice })
    const v_before = await before_var.before_var.get_v()
    assert(v_before.equals(new Int(0)))
    await before_var.before_var.exec({ as: alice })
    const v_after = await before_var.before_var.get_v()
    assert(v_after.equals(new Int(0)))
  })

  it('bls_lit', async () => {
    await bls_lit.bls_lit.deploy({ as: alice })
    // TODO
  })

  it('builtin_in_function', async () => {
    await builtin_in_function.builtin_in_function.deploy({ as: alice })
    const res_before = await builtin_in_function.builtin_in_function.get_res()
    assert(res_before.equals(Option.None<Nat>()))
    await builtin_in_function.builtin_in_function.exec({ as: alice })
    const res_after = await builtin_in_function.builtin_in_function.get_res()
    assert(res_after.equals(Option.Some(new Nat(1))))
  })

  it('called_by_an_asset', async () => {
    await called_by_an_asset.called_by_an_asset.deploy({ as: alice })
    await expect_to_fail(async () => {
      await called_by_an_asset.called_by_an_asset.exec({ as: bob });
    }, { "string": "INVALID_CALLER" });
    await called_by_an_asset.called_by_an_asset.exec({ as: alice })
  })

  it('cast', async () => {
    await cast.cast.deploy({ as: alice })
    const res_before = await cast.cast.get_res()
    assert(res_before.equals(new Rational(0)))
    await cast.cast.exec({ as: alice })
    const res_after = await cast.cast.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('cast_dur_int', async () => {
    await cast_dur_int.cast_dur_int.deploy({ as: alice })
    await cast_dur_int.cast_dur_int.exec({ as: alice })
  })

  it('cast_nat_int', async () => {
    await cast_nat_int.cast_nat_int.deploy({ as: alice })
    await cast_nat_int.cast_nat_int.exec({ as: alice })
  })

  it('cast_nat_int_lit', async () => {
    await cast_nat_int_lit.cast_nat_int_lit.deploy({ as: alice })
    await cast_nat_int_lit.cast_nat_int_lit.exec({ as: alice })
  })

  it('cast_return', async () => {
    await cast_return.cast_return.deploy({ as: alice })
    const res_before = await cast_return.cast_return.get_res()
    assert(res_before.equals(new Int(0)))
    await cast_return.cast_return.exec({ as: alice })
    const res_after = await cast_return.cast_return.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('cast_view_pklist', async () => {
    await cast_view_pklist.cast_view_pklist.deploy({ as: alice })
    const res_before = await cast_view_pklist.cast_view_pklist.get_res()
    assert(res_before.length == 0)
    await cast_view_pklist.cast_view_pklist.exec({ as: alice })
    const res_after = await cast_view_pklist.cast_view_pklist.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id1")
    assert(res_after[1] == "id2")
  })

  it('col_iter_direct_storage', async () => {
    await col_iter_direct_storage.col_iter_direct_storage.deploy({ as: alice })
    const res_before = await col_iter_direct_storage.col_iter_direct_storage.get_res()
    assert(res_before.equals(new Int(0)))
    await col_iter_direct_storage.col_iter_direct_storage.exec({ as: alice })
    const res_after = await col_iter_direct_storage.col_iter_direct_storage.get_res()
    assert(res_after.equals(new Int(3)))
  })

  it('col_iter_filter_storage', async () => {
    await col_iter_filter_storage.col_iter_filter_storage.deploy({ as: alice })
    const res_before = await col_iter_filter_storage.col_iter_filter_storage.get_res()
    assert(res_before.equals(new Int(0)))
    await col_iter_filter_storage.col_iter_filter_storage.exec({ as: alice })
    const res_after = await col_iter_filter_storage.col_iter_filter_storage.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('compare_enum', async () => {
    await compare_enum.compare_enum.deploy({ as: alice });
    compare_enum.compare_enum.exec({ as: alice })
  })

  it('const_decl', async () => {
    await const_decl.const_decl.deploy({ as: alice })
    await const_decl.const_decl.exec({ as: alice })
  })

  it('containers_of_tuple', async () => {
    await containers_of_tuple.containers_of_tuple.deploy({ as: alice })

    await containers_of_tuple.containers_of_tuple.test({ as: alice })
  })

  it('contract_called', async () => {
    await contract_called.contract_called.deploy({ as: alice })
    const v_before = await contract_called.contract_called.get_v()
    assert(v_before.equals(new Int(0)))
    await contract_called.contract_called.set_value(new Int(2), { as: alice });
    const v_1 = await contract_called.contract_called.get_v()
    assert(v_1.equals(new Int(2)))
    await contract_called.contract_called.add_value(new Int(2), new Int(1), { as: alice });
    const v_2 = await contract_called.contract_called.get_v()
    assert(v_2.equals(new Int(3)))
  })

  it('contract_caller', async () => {
    await contract_called.contract_called.deploy({ as: alice })
    await contract_caller.contract_caller.deploy({ as: alice })

    await contract_caller.contract_caller.update_value(new Int(4), contract_called.contract_called.get_address(), { as: alice });
    const v_1 = await contract_called.contract_called.get_v()
    assert(v_1.equals(new Int(4)))

    await contract_caller.contract_caller.add_one(new Int(6), contract_called.contract_called.get_address(), { as: alice });
    const v_2 = await contract_called.contract_called.get_v()
    assert(v_2.equals(new Int(8)))
  })

  it('contract_empty', async () => {
    await contract_empty.contract_empty.deploy({ as: alice })
    await contract_empty.contract_empty.exec({ as: alice })
  })

  it('contract_to_address', async () => {
    await contract_to_address.contract_to_address.deploy({ as: alice })
    const res_before = await contract_to_address.contract_to_address.get_res()
    assert(res_before.equals(Option.None<Address>()))
    await contract_to_address.contract_to_address.exec({ as: alice })
    const res_after = await contract_to_address.contract_to_address.get_res()
    assert(res_after.equals(Option.Some<Address>(alice.get_address())))
  })

  it('contract_transition', async () => {
    await contract_transition.contract_transition.deploy({ as: alice })

    const state_init = await contract_transition.contract_transition.get_state();
    assert(state_init == contract_transition.states.First);

    await contract_transition.contract_transition.mytr({ as: alice })

    const state_1 = await contract_transition.contract_transition.get_state();
    assert(state_1 == contract_transition.states.Second);

    await contract_transition.contract_transition.mytr_a({ as: alice })

    const state_2 = await contract_transition.contract_transition.get_state();
    assert(state_2 == contract_transition.states.Third);

    await expect_to_fail(async () => {
      await contract_transition.contract_transition.mytr_b({ as: alice })
    }, { "string": "INVALID_STATE" })

    await expect_to_fail(async () => {
      await contract_transition.contract_transition.mytr({ as: alice })
    }, { "string": "INVALID_STATE" })
  })

  it('counter', async () => {
    await counter.counter.deploy({ as: alice })

    const value_init = await counter.counter.get_value()
    assert(value_init.equals(new Int(0)));

    await counter.counter.incr(new Int(2), { as: alice })

    const value_0 = await counter.counter.get_value()
    assert(value_0.equals(new Int(2)));

    await counter.counter.decr(new Int(1), { as: alice })

    const value_1 = await counter.counter.get_value()
    assert(value_1.equals(new Int(1)));

    await counter.counter.reset({ as: alice })

    const value_2 = await counter.counter.get_value()
    assert(value_2.equals(new Int(0)));

  })

  it('counter_proxy', async () => {
    await counter.counter.deploy({ as: alice })
    await counter_proxy.counter_proxy.deploy({ as: alice })

    const value_before = await counter.counter.get_value()
    assert(value_before.equals(new Int(0)));

    await counter_proxy.counter_proxy.exec(new Int(2), counter.counter.get_address(), { as: alice })

    const value_after = await counter.counter.get_value()
    assert(value_after.equals(new Int(2)));
  })

  it('custom_args_with_record', async () => {
    await custom_args_with_record.custom_args_with_record.deploy({ as: alice })

    // TODO: Bug binder
    // const res_before = await custom_args_with_record.custom_args_with_record.get_res();
    // assert(res_before.equals(new Nat(0)))
    // await custom_args_with_record.custom_args_with_record.exec(new custom_args_with_record.my_arg(new Int(1), new Nat(2), alice.get_address()), {as : alice})
    // const res_after = await custom_args_with_record.custom_args_with_record.get_res();
    // assert(res_after.equals(new Nat(2)))
  })

  it('custom_storage', async () => {
    await custom_storage.custom_storage.deploy({ as: alice })

    // TODO: Bug binder
    // const r_before = await custom_storage.custom_storage.get_r();
    // assert(r_before.equals(new custom_storage.my_record(new Int(1), new Nat(2), "mystr")))

    // const res_before = await custom_storage.custom_storage.get_res();
    // assert(res_before.equals(new Nat(0)))

    // await custom_storage.custom_storage.exec({ as: alice })

    // const r_after = await custom_storage.custom_storage.get_r();
    // assert(r_after.equals(new custom_storage.my_record(new Int(1), new Nat(2), "mystr")))

    // const res_after = await custom_storage.custom_storage.get_res();
    // assert(res_after.equals(new Nat(2)))
  })

  it('custom_storage10', async () => {
    await custom_storage10.custom_storage10.deploy({ as: alice })

    const r_before = await custom_storage10.custom_storage10.get_r();
    assert(r_before.equals(new custom_storage10.my_record(new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0))))
    await custom_storage10.custom_storage10.exec({ as: alice })
    const r_after = await custom_storage10.custom_storage10.get_r();
    assert(r_after.equals(new custom_storage10.my_record(new Nat(0), new Nat(1), new Nat(2), new Nat(3), new Nat(4), new Nat(5), new Nat(6), new Nat(7), new Nat(8), new Nat(9), new Nat(10), new Nat(11), new Nat(12))))
  })

  it('custom_storage2', async () => {
    await custom_storage2.custom_storage2.deploy({ as: alice })

    const r_before = await custom_storage2.custom_storage2.get_r();
    assert(r_before.equals(new custom_storage2.my_record(new Int(0), new Nat(2), alice.get_address(), new Int(0), new Nat(0), alice.get_address(), new Int(0), new Nat(0), alice.get_address(), new Int(0), new Nat(0), alice.get_address())))

    const res_before = await custom_storage2.custom_storage2.get_res()
    assert(res_before.equals(new Nat(0)))

    await custom_storage2.custom_storage2.exec({ as: alice })

    const r_after = await custom_storage2.custom_storage2.get_r();
    assert(r_after.equals(new custom_storage2.my_record(new Int(0), new Nat(2), alice.get_address(), new Int(0), new Nat(0), alice.get_address(), new Int(0), new Nat(0), alice.get_address(), new Int(0), new Nat(0), alice.get_address())))

    const res_after = await custom_storage2.custom_storage2.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('custom_storage3', async () => {
    await custom_storage3.custom_storage3.deploy({ as: alice })

    const r_before = await custom_storage3.custom_storage3.get_r();
    assert(r_before.equals(new custom_storage3.my_record(new Nat(0), new Nat(1), new Nat(2), new Nat(3), new Nat(4), new Nat(5), new Nat(6), new Nat(7), new Nat(8), new Nat(9), new Nat(10), new Nat(11), new Nat(12))))

    const a_before = await custom_storage3.custom_storage3.get_a();
    assert(a_before.equals(new Nat(0)));
    // TODO: Bug binder
    // const b_before = await custom_storage3.custom_storage3.get_b();
    // assert(b_before.equals(new Nat(0)));
    // const c_before = await custom_storage3.custom_storage3.get_c();
    // assert(c_before.equals(new Nat(0)));
    // const d_before = await custom_storage3.custom_storage3.get_d();
    // assert(d_before.equals(new Nat(0)));
    // const e_before = await custom_storage3.custom_storage3.get_e();
    // assert(e_before.equals(new Nat(0)));
    // const f_before = await custom_storage3.custom_storage3.get_f();
    // assert(f_before.equals(new Nat(0)));
    // const g_before = await custom_storage3.custom_storage3.get_g();
    // assert(g_before.equals(new Nat(0)));
    // const h_before = await custom_storage3.custom_storage3.get_h();
    // assert(h_before.equals(new Nat(0)));
    // const i_before = await custom_storage3.custom_storage3.get_i();
    // assert(i_before.equals(new Nat(0)));
    // const j_before = await custom_storage3.custom_storage3.get_j();
    // assert(j_before.equals(new Nat(0)));
    // const k_before = await custom_storage3.custom_storage3.get_k();
    // assert(k_before.equals(new Nat(0)));
    // const l_before = await custom_storage3.custom_storage3.get_l();
    // assert(l_before.equals(new Nat(0)));
    // const m_before = await custom_storage3.custom_storage3.get_m();
    // assert(m_before.equals(new Nat(0)));

    await custom_storage3.custom_storage3.exec({ as: alice })

    const r_after = await custom_storage3.custom_storage3.get_r();
    assert(r_after.equals(new custom_storage3.my_record(new Nat(0), new Nat(1), new Nat(2), new Nat(3), new Nat(4), new Nat(5), new Nat(6), new Nat(7), new Nat(8), new Nat(9), new Nat(10), new Nat(11), new Nat(12))))

    const a_after = await custom_storage3.custom_storage3.get_a();
    assert(a_after.equals(new Nat(0)));
    const b_after = await custom_storage3.custom_storage3.get_b();
    assert(b_after.equals(new Nat(1)));
    const c_after = await custom_storage3.custom_storage3.get_c();
    assert(c_after.equals(new Nat(2)));
    const d_after = await custom_storage3.custom_storage3.get_d();
    assert(d_after.equals(new Nat(3)));
    const e_after = await custom_storage3.custom_storage3.get_e();
    assert(e_after.equals(new Nat(4)));
    const f_after = await custom_storage3.custom_storage3.get_f();
    assert(f_after.equals(new Nat(5)));
    const g_after = await custom_storage3.custom_storage3.get_g();
    assert(g_after.equals(new Nat(6)));
    const h_after = await custom_storage3.custom_storage3.get_h();
    assert(h_after.equals(new Nat(7)));
    const i_after = await custom_storage3.custom_storage3.get_i();
    assert(i_after.equals(new Nat(8)));
    const j_after = await custom_storage3.custom_storage3.get_j();
    assert(j_after.equals(new Nat(9)));
    const k_after = await custom_storage3.custom_storage3.get_k();
    assert(k_after.equals(new Nat(10)));
    const l_after = await custom_storage3.custom_storage3.get_l();
    assert(l_after.equals(new Nat(11)));
    const m_after = await custom_storage3.custom_storage3.get_m();
    assert(m_after.equals(new Nat(12)));
  })

  it('custom_storage4', async () => {
    await custom_storage4.custom_storage4.deploy({ as: alice })

    // TODO: Bug binder
    // const r_before = await custom_storage4.custom_storage4.get_r();
    // assert(r_before.equals(new custom_storage4.my_record(new Int(0), new Nat(0), "", new Nat(0))))
    // await custom_storage4.custom_storage4.exec({ as: alice })
    // const r_after = await custom_storage4.custom_storage4.get_r();
    // assert(r_after.equals(new custom_storage4.my_record(new Int(1), new Nat(2), "mystr", new Nat(3))))
  })

  it('custom_storage5', async () => {
    await custom_storage5.custom_storage5.deploy({ as: alice })

    const r_before = await custom_storage5.custom_storage5.get_r();
    assert(r_before.equals(new custom_storage5.my_record(new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0))))
    await custom_storage5.custom_storage5.exec({ as: alice })
    const r_after = await custom_storage5.custom_storage5.get_r();
    assert(r_after.equals(new custom_storage5.my_record(new Nat(0), new Nat(1), new Nat(2), new Nat(3), new Nat(15), new Nat(5), new Nat(6), new Nat(7), new Nat(8), new Nat(9), new Nat(10), new Nat(11), new Nat(12))))
  })

  it('custom_storage6', async () => {
    await custom_storage6.custom_storage6.deploy({ as: alice })

    // TODO: Bug binder
    // const r_before = await custom_storage6.custom_storage6.get_r();
    // assert(r_before.equals(new custom_storage6.my_record(new Int(1), new Nat(2), alice.get_address())))
    // await custom_storage6.custom_storage6.exec({ as: alice })
    // const r_after = await custom_storage6.custom_storage6.get_r();
    // assert(r_after.equals(new custom_storage6.my_record(new Int(11), new Nat(22), alice.get_address())))
  })

  it('custom_storage7', async () => {
    await custom_storage7.custom_storage7.deploy({ as: alice })

    // TODO: Bug binder
    // const r_before = await custom_storage7.custom_storage7.get_r();
    // assert(r_before.equals(new custom_storage7.my_record(new Int(1), new Nat(2), alice.get_address())))
    // await custom_storage7.custom_storage7.exec({ as: alice })
    // const r_after = await custom_storage7.custom_storage7.get_r();
    // assert(r_after.equals(new custom_storage7.my_record(new Int(1), new Nat(4), alice.get_address())))
  })

  it('custom_storage8', async () => {
    await custom_storage8.custom_storage8.deploy({ as: alice })

    const r_before = await custom_storage8.custom_storage8.get_r();
    assert(r_before.equals(new custom_storage8.my_record(new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0))))
    await custom_storage8.custom_storage8.exec({ as: alice })
    const r_after = await custom_storage8.custom_storage8.get_r();
    assert(r_after.equals(new custom_storage8.my_record(new Nat(0), new Nat(1), new Nat(2), new Nat(3), new Nat(4), new Nat(5), new Nat(6), new Nat(7), new Nat(8), new Nat(9), new Nat(10), new Nat(11), new Nat(12))))
  })

  it('custom_storage9', async () => {
    await custom_storage9.custom_storage9.deploy({ as: alice })

    const r_before = await custom_storage9.custom_storage9.get_r();
    assert(r_before.equals(new custom_storage9.my_record(new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0))))
    await custom_storage9.custom_storage9.exec({ as: alice })
    const r_after = await custom_storage9.custom_storage9.get_r();
    assert(r_after.equals(new custom_storage9.my_record(new Nat(0), new Nat(1), new Nat(2), new Nat(3), new Nat(4), new Nat(5), new Nat(6), new Nat(7), new Nat(8), new Nat(9), new Nat(10), new Nat(11), new Nat(12))))
  })

  it('dangling_else', async () => {
    await dangling_else.dangling_else.deploy({ as: alice })

    const res_before = await dangling_else.dangling_else.get_res();
    assert(res_before.equals(new Nat(0)))
    await dangling_else.dangling_else.exec({ as: alice })
    const res_after = await dangling_else.dangling_else.get_res();
    assert(res_after.equals(new Nat(42)))
  })

  it('debug_assign', async () => {
    await debug_assign.debug_assign.deploy({ as: alice })

    const a_before = await debug_assign.debug_assign.get_a();
    assert(a_before.equals(new Nat(0)))
    await debug_assign.debug_assign.exec({ as: alice })
    const a_after = await debug_assign.debug_assign.get_a();
    assert(a_after.equals(new Nat(2)))
  })

  it('dec_lit', async () => {
    await dec_lit.dec_lit.deploy({ as: alice })

    const g = await dec_lit.dec_lit.get_g();
    assert(g.equals(new Rational(0.042)))
    const dtz = await dec_lit.dec_lit.get_dtz();
    assert(dtz.equals(new Tez(1.2)))
    const dmtz = await dec_lit.dec_lit.get_dmtz();
    assert(dmtz.equals(new Tez(0.0012)))
    const dutz = await dec_lit.dec_lit.get_dutz();
    assert(dutz.equals(new Tez(1, "mutez")))
  })

  it('decl_var_opt', async () => {
    await decl_var_opt.decl_var_opt.deploy({ as: alice })

    await decl_var_opt.decl_var_opt.exec({ as: alice })
  })

  it('decl_var_opt_default', async () => {
    await decl_var_opt_default.decl_var_opt_default.deploy({ as: alice })

    await decl_var_opt_default.decl_var_opt_default.exec({ as: alice })
  })

  it('decomp_if', async () => {
    await decomp_if.decomp_if.deploy({ as: alice })

    const n_init = await decomp_if.decomp_if.get_n();
    assert(n_init.equals(new Nat(0)))

    await decomp_if.decomp_if.exec(true, { as: alice })

    const n_true = await decomp_if.decomp_if.get_n();
    assert(n_true.equals(new Nat(2)))

    await decomp_if.decomp_if.exec(false, { as: alice })

    const n_false = await decomp_if.decomp_if.get_n();
    assert(n_false.equals(new Nat(3)))
  })

  it('decomp_if2', async () => {
    await decomp_if2.decomp_if2.deploy({ as: alice })

    const a_init = await decomp_if2.decomp_if2.get_a();
    assert(a_init.equals(new Nat(0)))
    const b_init = await decomp_if2.decomp_if2.get_b();
    assert(b_init.equals(new Nat(0)))

    await decomp_if2.decomp_if2.exec(new Nat(0), { as: alice });

    const a_0 = await decomp_if2.decomp_if2.get_a();
    assert(a_0.equals(new Nat(0)))
    const b_0 = await decomp_if2.decomp_if2.get_b();
    assert(b_0.equals(new Nat(4)))

    await decomp_if2.decomp_if2.exec(new Nat(3), { as: alice });

    const a_3 = await decomp_if2.decomp_if2.get_a();
    assert(a_3.equals(new Nat(2)))
    const b_3 = await decomp_if2.decomp_if2.get_b();
    assert(b_3.equals(new Nat(5)))
  })

  it('decomp_if3', async () => {
    await decomp_if3.decomp_if3.deploy({ as: alice })

    const a_init = await decomp_if3.decomp_if3.get_a();
    assert(a_init.equals(new Nat(0)))
    const b_init = await decomp_if3.decomp_if3.get_b();
    assert(b_init.equals(new Nat(0)))

    await decomp_if3.decomp_if3.exec(new Nat(0), { as: alice });

    const a_0 = await decomp_if3.decomp_if3.get_a();
    assert(a_0.equals(new Nat(3)))
    const b_0 = await decomp_if3.decomp_if3.get_b();
    assert(b_0.equals(new Nat(4)))

    await decomp_if3.decomp_if3.exec(new Nat(3), { as: alice });

    const a_3 = await decomp_if3.decomp_if3.get_a();
    assert(a_3.equals(new Nat(2)))
    const b_3 = await decomp_if3.decomp_if3.get_b();
    assert(b_3.equals(new Nat(5)))
  })

  it('decomp_if4', async () => {
    await decomp_if4.decomp_if4.deploy({ as: alice })

    const a_init = await decomp_if4.decomp_if4.get_a();
    assert(a_init.equals(new Nat(0)))
    const b_init = await decomp_if4.decomp_if4.get_b();
    assert(b_init.equals(new Nat(0)))

    await decomp_if4.decomp_if4.exec(new Nat(0), { as: alice });

    const a_0 = await decomp_if4.decomp_if4.get_a();
    assert(a_0.equals(new Nat(0)))
    const b_0 = await decomp_if4.decomp_if4.get_b();
    assert(b_0.equals(new Nat(4)))

    await decomp_if4.decomp_if4.exec(new Nat(3), { as: alice });

    const a_3 = await decomp_if4.decomp_if4.get_a();
    assert(a_3.equals(new Nat(3)))
    const b_3 = await decomp_if4.decomp_if4.get_b();
    assert(b_3.equals(new Nat(4)))
  })

  it('decomp_ifexpr', async () => {
    await decomp_ifexpr.decomp_ifexpr.deploy({ as: alice })

    const n_init = await decomp_ifexpr.decomp_ifexpr.get_n();
    assert(n_init.equals(new Nat(0)))

    await decomp_ifexpr.decomp_ifexpr.exec(true, { as: alice })

    const n_true = await decomp_ifexpr.decomp_ifexpr.get_n();
    assert(n_true.equals(new Nat(2)))

    await decomp_ifexpr.decomp_ifexpr.exec(false, { as: alice })

    const n_false = await decomp_ifexpr.decomp_ifexpr.get_n();
    assert(n_false.equals(new Nat(3)))
  })

  it('decomp_map', async () => {
    await decomp_map.decomp_map.deploy({ as: alice })

    const s_before = await decomp_map.decomp_map.get_s();
    assert(s_before.equals(Option.None()))
    const m_before = await decomp_map.decomp_map.get_m();
    assert(m_before.length == 0)

    await decomp_map.decomp_map.exec({ as: alice })

    const s_after = await decomp_map.decomp_map.get_s();
    assert(s_after.equals(Option.Some<string>("mystr0")))
    const m_after = await decomp_map.decomp_map.get_m();
    assert(m_after.length == 1)
    assert(m_after[0][0].equals(new Nat(0)))
    assert(m_after[0][1] == "mystr0")
  })

  it('decomp_test', async () => {
    await decomp_test.decomp_test.deploy({ as: alice })

    const a_before = await decomp_test.decomp_test.get_a();
    assert(a_before.equals(new Nat(0)))
    const b_before = await decomp_test.decomp_test.get_b();
    assert(b_before.equals(new Nat(0)))

    await decomp_test.decomp_test.exec("mystr", { as: alice });

    const a_after = await decomp_test.decomp_test.get_a();
    assert(a_after.equals(new Nat(5)))
    const b_after = await decomp_test.decomp_test.get_b();
    assert(b_after.equals(new Nat(6)))
  })

  it('decomp_test2', async () => {
    await decomp_test2.decomp_test2.deploy({ as: alice })

    const a_before = await decomp_test2.decomp_test2.get_a();
    assert(a_before.equals(new Nat(0)))
    const b_before = await decomp_test2.decomp_test2.get_b();
    assert(b_before.equals(new Int(0)))

    await decomp_test2.decomp_test2.exec("mystr", { as: alice });

    const a_after = await decomp_test2.decomp_test2.get_a();
    assert(a_after.equals(new Nat(5)))
    const b_after = await decomp_test2.decomp_test2.get_b();
    assert(b_after.equals(new Int(6)))
  })

  it('decomp_while', async () => {
    await decomp_while.decomp_while.deploy({ as: alice })

    const a_before = await decomp_while.decomp_while.get_a();
    assert(a_before.equals(new Nat(0)))
    const b_before = await decomp_while.decomp_while.get_b();
    assert(b_before.equals(new Int(0)))

    await decomp_while.decomp_while.exec({ as: alice })

    const a_after = await decomp_while.decomp_while.get_a();
    assert(a_after.equals(new Nat(10)))
    const b_after = await decomp_while.decomp_while.get_b();
    assert(b_after.equals(new Int(60)))
  })

  it('decomp_while1', async () => {
    await decomp_while1.decomp_while1.deploy({ as: alice })

    await decomp_while1.decomp_while1.exec({ as: alice })
  })

  it('decomp_while2', async () => {
    await decomp_while2.decomp_while2.deploy({ as: alice })

    await decomp_while2.decomp_while2.exec(new Nat(2), { as: alice })
  })

  it('detach_big_map_string', async () => {
    await detach_big_map_string.detach_big_map_string.deploy({ as: alice })
    const res_before = await detach_big_map_string.detach_big_map_string.get_res()
    assert(res_before == "")
    const mt_before = await detach_big_map_string.detach_big_map_string.get_mt_value(new Nat(0));
    assert(mt_before === "my_string")
    await detach_big_map_string.detach_big_map_string.exec({ as: alice })
    const res_after = await detach_big_map_string.detach_big_map_string.get_res()
    assert(res_after == "my_string")
    const mt_after = await detach_big_map_string.detach_big_map_string.get_mt_value(new Nat(0));
    assert(mt_after === undefined)
  })

  it('detach_big_map_unit', async () => {
    await detach_big_map_unit.detach_big_map_unit.deploy({ as: alice })

    await detach_big_map_unit.detach_big_map_unit.init(alice.get_address(), { as: alice })

    const ticket_alice_before = await detach_big_map_unit.detach_big_map_unit.get_mt_value(alice.get_address());
    assert(ticket_alice_before?.equals(new Ticket<Unit>(detach_big_map_unit.detach_big_map_unit.get_address(), new Unit(), new Nat(1))))

    const ticket_bob_before = await detach_big_map_unit.detach_big_map_unit.get_mt_value(bob.get_address());
    assert(ticket_bob_before === undefined)

    await detach_big_map_unit.detach_big_map_unit.exec({ as: alice })

    const ticket_alice_after = await detach_big_map_unit.detach_big_map_unit.get_mt_value(alice.get_address());
    assert(ticket_alice_after?.equals(new Ticket<Unit>(detach_big_map_unit.detach_big_map_unit.get_address(), new Unit(), new Nat(3))))

    const ticket_bob_after = await detach_big_map_unit.detach_big_map_unit.get_mt_value(bob.get_address());
    assert(ticket_bob_after === undefined)
  })

  it('detach_map_string', async () => {
    await detach_map_string.detach_map_string.deploy({ as: alice })
    const res_before = await detach_map_string.detach_map_string.get_res()
    assert(res_before == "")
    const mt_before = await detach_map_string.detach_map_string.get_mt();
    assert(mt_before.length == 1)
    assert(mt_before[0][0].equals(new Nat(0)))
    assert(mt_before[0][1] === "my_string")
    await detach_map_string.detach_map_string.exec({ as: alice })
    const res_after = await detach_map_string.detach_map_string.get_res()
    assert(res_after == "my_string")
    const mt_after = await detach_map_string.detach_map_string.get_mt();
    assert(mt_after.length == 0)
  })

  it('detach_option_string', async () => {
    await detach_option_string.detach_option_string.deploy({ as: alice })
    const res_before = await detach_option_string.detach_option_string.get_res()
    assert(res_before == "")
    const ot_before = await detach_option_string.detach_option_string.get_ot();
    assert(ot_before.equals(Option.Some<string>("my_string")))
    await detach_option_string.detach_option_string.exec({ as: alice })
    const res_after = await detach_option_string.detach_option_string.get_res()
    assert(res_after == "my_string")
    const ot_after = await detach_option_string.detach_option_string.get_ot();
    assert(ot_after.equals(Option.None()))
  })

  it('duration_to_int', async () => {
    await duration_to_int.duration_to_int.deploy({ as: alice })
    const res_before = await duration_to_int.duration_to_int.get_res();
    assert(res_before.equals(new Int(0)), "Invalid Value")
    await duration_to_int.duration_to_int.exec({ as: alice })
    const res_after = await duration_to_int.duration_to_int.get_res();
    assert(res_after.equals(new Int(2)), "Invalid Value")
  })

  it('effect_add_asset_with_complex_partition', async () => {
    await effect_add_asset_with_complex_partition.effect_add_asset_with_complex_partition.deploy({ as: alice })

    const my_asset_before = await effect_add_asset_with_complex_partition.effect_add_asset_with_complex_partition.get_my_asset();
    assert(my_asset_before.length == 0);
    const o_asset_before = await effect_add_asset_with_complex_partition.effect_add_asset_with_complex_partition.get_o_asset()
    assert(o_asset_before.length == 0);

    await effect_add_asset_with_complex_partition.effect_add_asset_with_complex_partition.add({ as: alice })

    const my_asset_after = await effect_add_asset_with_complex_partition.effect_add_asset_with_complex_partition.get_my_asset();
    assert(my_asset_after.length == 1);
    assert(my_asset_after[0][0].equals(new Int(1)));
    assert(my_asset_after[0][1].length == 3);
    assert(my_asset_after[0][1][0] == "my_id1");
    assert(my_asset_after[0][1][1] == "my_id2");
    assert(my_asset_after[0][1][2] == "my_id3");
    const o_asset_after = await effect_add_asset_with_complex_partition.effect_add_asset_with_complex_partition.get_o_asset()
    assert(o_asset_after.length == 3);
    assert(o_asset_after[0][0] == "my_id1");
    assert(o_asset_after[0][1].equals(new Int(42)));
    assert(o_asset_after[1][0] == "my_id2");
    assert(o_asset_after[1][1].equals(new Int(43)));
    assert(o_asset_after[2][0] == "my_id3");
    assert(o_asset_after[2][1].equals(new Int(44)));
  })

  it('effect_control_for_aggregate', async () => {
    await effect_control_for_aggregate.effect_control_for_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_control_for_aggregate.effect_control_for_aggregate.get_my_asset();
    assert(my_asset_before.length == 3)
    const o_asset_before = await effect_control_for_aggregate.effect_control_for_aggregate.get_o_asset();
    assert(o_asset_before.length == 2)
    const res_before = await effect_control_for_aggregate.effect_control_for_aggregate.get_res();
    assert(res_before.equals(new Int(0)))

    await effect_control_for_aggregate.effect_control_for_aggregate.exec({ as: alice })

    const my_asset_after = await effect_control_for_aggregate.effect_control_for_aggregate.get_my_asset();
    assert(my_asset_after.length == 3)
    const o_asset_after = await effect_control_for_aggregate.effect_control_for_aggregate.get_o_asset();
    assert(o_asset_after.length == 2)
    const res_after = await effect_control_for_aggregate.effect_control_for_aggregate.get_res();
    assert(res_after.equals(new Int(3)))
  })

  it('effect_control_for_collection', async () => {
    await effect_control_for_collection.effect_control_for_collection.deploy({ as: alice })

    const my_asset_before = await effect_control_for_collection.effect_control_for_collection.get_myasset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(1)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(2)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(3)))
    const res_before = await effect_control_for_collection.effect_control_for_collection.get_res();
    assert(res_before.equals(new Int(0)))

    await effect_control_for_collection.effect_control_for_collection.exec({ as: alice })

    const my_asset_after = await effect_control_for_collection.effect_control_for_collection.get_myasset();
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(1)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(3)))
    const res_after = await effect_control_for_collection.effect_control_for_collection.get_res();
    assert(res_after.equals(new Int(6)))
  })

  it('effect_control_for_collection_one_field', async () => {
    await effect_control_for_collection_one_field.effect_control_for_collection_one_field.deploy({ as: alice })

    const my_asset_before = await effect_control_for_collection_one_field.effect_control_for_collection_one_field.get_myasset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(1)))
    assert(my_asset_before[1].equals(new Nat(2)))
    assert(my_asset_before[2].equals(new Nat(3)))
    const res_before = await effect_control_for_collection_one_field.effect_control_for_collection_one_field.get_res();
    assert(res_before.equals(new Int(0)))

    await effect_control_for_collection_one_field.effect_control_for_collection_one_field.exec({ as: alice })

    const my_asset_after = await effect_control_for_collection_one_field.effect_control_for_collection_one_field.get_myasset();
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(1)))
    assert(my_asset_after[1].equals(new Nat(2)))
    assert(my_asset_after[2].equals(new Nat(3)))
    const res_after = await effect_control_for_collection_one_field.effect_control_for_collection_one_field.get_res();
    assert(res_after.equals(new Int(6)))
  })

  it('effect_control_for_list', async () => {
    await effect_control_for_list.effect_control_for_list.deploy({ as: alice })

    const res_before = await effect_control_for_list.effect_control_for_list.get_res();
    assert(res_before.equals(new Nat(0)))
    await effect_control_for_list.effect_control_for_list.exec({ as: alice })
    const res_after = await effect_control_for_list.effect_control_for_list.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('effect_control_for_map', async () => {
    await effect_control_for_map.effect_control_for_map.deploy({ as: alice })

    const res_before = await effect_control_for_map.effect_control_for_map.get_res();
    assert(res_before.equals(new Nat(0)))
    await effect_control_for_map.effect_control_for_map.exec({ as: alice })
    const res_after = await effect_control_for_map.effect_control_for_map.get_res();
    assert(res_after.equals(new Nat(3)))
  })

  it('effect_control_for_partition', async () => {
    await effect_control_for_partition.effect_control_for_partition.deploy({ as: alice })

    const res_before = await effect_control_for_partition.effect_control_for_partition.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_for_partition.effect_control_for_partition.exec({ as: alice })
    const res_after = await effect_control_for_partition.effect_control_for_partition.get_res();
    assert(res_after.equals(new Int(3)))
  })

  it('effect_control_for_set', async () => {
    await effect_control_for_set.effect_control_for_set.deploy({ as: alice })

    const res_before = await effect_control_for_set.effect_control_for_set.get_res();
    assert(res_before.equals(new Nat(0)))
    await effect_control_for_set.effect_control_for_set.exec({ as: alice })
    const res_after = await effect_control_for_set.effect_control_for_set.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('effect_control_for_view', async () => {
    await effect_control_for_view.effect_control_for_view.deploy({ as: alice })

    const res_before = await effect_control_for_view.effect_control_for_view.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_for_view.effect_control_for_view.exec({ as: alice })
    const res_after = await effect_control_for_view.effect_control_for_view.get_res();
    assert(res_after.equals(new Int(5)))
  })

  it('effect_control_if', async () => {
    await effect_control_if.effect_control_if.deploy({ as: alice })

    const res_before = await effect_control_if.effect_control_if.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_if.effect_control_if.exec({ as: alice })
    const res_after = await effect_control_if.effect_control_if.get_res();
    assert(res_after.equals(new Int(1)))
  })

  it('effect_control_if_else', async () => {
    await effect_control_if_else.effect_control_if_else.deploy({ as: alice })

    const res_before = await effect_control_if_else.effect_control_if_else.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_if_else.effect_control_if_else.exec({ as: alice })
    const res_after = await effect_control_if_else.effect_control_if_else.get_res();
    assert(res_after.equals(new Int(1)))
  })

  it('effect_control_iter', async () => {
    await effect_control_iter.effect_control_iter.deploy({ as: alice })

    const res_before = await effect_control_iter.effect_control_iter.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_iter.effect_control_iter.exec({ as: alice })
    const res_after = await effect_control_iter.effect_control_iter.get_res();
    assert(res_after.equals(new Int(6)))
  })

  it('effect_control_iter_init', async () => {
    await effect_control_iter_init.effect_control_iter_init.deploy({ as: alice })

    const res_before = await effect_control_iter_init.effect_control_iter_init.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_iter_init.effect_control_iter_init.exec({ as: alice })
    const res_after = await effect_control_iter_init.effect_control_iter_init.get_res();
    assert(res_after.equals(new Int(5)))
  })

  it('effect_control_match_enum', async () => {
    await effect_control_match_enum.effect_control_match_enum.deploy({ as: alice })

    const res_before = await effect_control_match_enum.effect_control_match_enum.get_res();
    assert(res_before.equals(new Nat(0)))
    await effect_control_match_enum.effect_control_match_enum.exec({ as: alice })
    const res_after = await effect_control_match_enum.effect_control_match_enum.get_res();
    assert(res_after.equals(new Nat(1)))
  })

  it('effect_control_match_list', async () => {
    await effect_control_match_list.effect_control_match_list.deploy({ as: alice })

    const res_before = await effect_control_match_list.effect_control_match_list.get_res();
    assert(res_before.equals(new Nat(0)))
    await effect_control_match_list.effect_control_match_list.exec({ as: alice })
    const res_after = await effect_control_match_list.effect_control_match_list.get_res();
    assert(res_after.equals(new Nat(1)))
  })

  it('effect_control_match_option', async () => {
    await effect_control_match_option.effect_control_match_option.deploy({ as: alice })

    const res_before = await effect_control_match_option.effect_control_match_option.get_res();
    assert(res_before.equals(new Nat(0)))
    await effect_control_match_option.effect_control_match_option.exec({ as: alice })
    const res_after = await effect_control_match_option.effect_control_match_option.get_res();
    assert(res_after.equals(new Nat(1)))
  })

  it('effect_control_match_option_2', async () => {
    await effect_control_match_option_2.effect_control_match_option_2.deploy({ as: alice })

    const r1_before = await effect_control_match_option_2.effect_control_match_option_2.get_r1();
    assert(r1_before.equals(new Nat(0)))
    const r2_before = await effect_control_match_option_2.effect_control_match_option_2.get_r2();
    assert(r2_before == "")
    await effect_control_match_option_2.effect_control_match_option_2.exec({ as: alice })
    const r1_after = await effect_control_match_option_2.effect_control_match_option_2.get_r1();
    assert(r1_after.equals(new Nat(1)))
    const r2_after = await effect_control_match_option_2.effect_control_match_option_2.get_r2();
    assert(r2_after == "mystr")
  })

  it('effect_control_match_or', async () => {
    await effect_control_match_or.effect_control_match_or.deploy({ as: alice })

    const res_before = await effect_control_match_or.effect_control_match_or.get_res();
    assert(res_before.equals(new Nat(0)))
    await effect_control_match_or.effect_control_match_or.exec({ as: alice })
    const res_after = await effect_control_match_or.effect_control_match_or.get_res();
    assert(res_after.equals(new Nat(1)))
  })

  it('effect_control_matchwith', async () => {
    await effect_control_matchwith.effect_control_matchwith.deploy({ as: alice })

    // TODO: handle value out of enum definition
    const res_before = await effect_control_matchwith.effect_control_matchwith.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_matchwith.effect_control_matchwith.exec({ as: alice })
    const res_after = await effect_control_matchwith.effect_control_matchwith.get_res();
    assert(res_after.equals(new Int(1)))
  })

  it('effect_control_sequence', async () => {
    await effect_control_sequence.effect_control_sequence.deploy({ as: alice })

    const res_before = await effect_control_sequence.effect_control_sequence.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_sequence.effect_control_sequence.exec({ as: alice })
    const res_after = await effect_control_sequence.effect_control_sequence.get_res();
    assert(res_after.equals(new Int(3)))
  })

  it('effect_control_while', async () => {
    await effect_control_while.effect_control_while.deploy({ as: alice })

    const res_before = await effect_control_while.effect_control_while.get_res();
    assert(res_before.equals(new Int(0)))
    await effect_control_while.effect_control_while.exec({ as: alice })
    const res_after = await effect_control_while.effect_control_while.get_res();
    assert(res_after.equals(new Int(3)))
  })

  it('effect_dofailif', async () => {
    await effect_dofailif.effect_dofailif.deploy({ as: alice })

    await effect_dofailif.effect_dofailif.exec({ as: alice })
  })

  it('effect_dorequire', async () => {
    await effect_dorequire.effect_dorequire.deploy({ as: alice })

    await effect_dorequire.effect_dorequire.exec({ as: alice })
  })

  it('effect_dorequire_not', async () => {
    await effect_dorequire_not.effect_dorequire_not.deploy({ as: alice })

    await effect_dorequire_not.effect_dorequire_not.exec({ as: alice })
  })

  it('effect_fail', async () => {
    await effect_fail.effect_fail.deploy({ as: alice })

    await expect_to_fail(async () => {
      await effect_fail.effect_fail.exec({ as: alice })
    }, { string: "message" })
  })

  it('effect_fail_complex', async () => {
    await effect_fail_complex.effect_fail_complex.deploy({ as: alice })

    await expect_to_fail(async () => {
      await effect_fail_complex.effect_fail_complex.exec({ as: alice })
    }, { prim: "Pair", args: [{ string: "error" }, { int: "0" }] })
  })

  it('effect_instruction_put_in_asset', async () => {
    await effect_instruction_put_in_asset.effect_instruction_put_in_asset.deploy({ as: alice })

    const my_asset_before = await effect_instruction_put_in_asset.effect_instruction_put_in_asset.get_my_asset();
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 0)
    await effect_instruction_put_in_asset.effect_instruction_put_in_asset.exec({ as: alice })
    const my_asset_after = await effect_instruction_put_in_asset.effect_instruction_put_in_asset.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0][0] == "k")
    assert(my_asset_after[0][1][0][1].equals(new Bytes("00")))
  })

  it('effect_method_asset_add_aggregate', async () => {
    await effect_method_asset_add_aggregate.effect_method_asset_add_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_aggregate.effect_method_asset_add_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await effect_method_asset_add_aggregate.effect_method_asset_add_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await effect_method_asset_add_aggregate.effect_method_asset_add_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_add_aggregate.effect_method_asset_add_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await effect_method_asset_add_aggregate.effect_method_asset_add_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('effect_method_asset_add_asset', async () => {
    await effect_method_asset_add_asset.effect_method_asset_add_asset.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_asset.effect_method_asset_add_asset.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    await effect_method_asset_add_asset.effect_method_asset_add_asset.exec({ as: alice })
    const my_asset_after = await effect_method_asset_add_asset.effect_method_asset_add_asset.get_my_asset()
    assert(my_asset_after.length == 4)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(2)))
    assert(my_asset_after[3][0] == "id3")
    assert(my_asset_after[3][1].equals(new Int(3)))
  })

  it('effect_method_asset_add_asset2', async () => {
    await effect_method_asset_add_asset2.effect_method_asset_add_asset2.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_asset2.effect_method_asset_add_asset2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].v == true)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].v == true)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].v == true)
    await effect_method_asset_add_asset2.effect_method_asset_add_asset2.exec({ as: alice })
    const my_asset_after = await effect_method_asset_add_asset2.effect_method_asset_add_asset2.get_my_asset()
    assert(my_asset_after.length == 4)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].v == true)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].v == true)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].v == true)
    assert(my_asset_after[3][0] == "id3")
    assert(my_asset_after[3][1].value.equals(new Int(3)))
    assert(my_asset_after[3][1].v == true)
  })

  it('effect_method_asset_add_asset_one_field', async () => {
    await effect_method_asset_add_asset_one_field.effect_method_asset_add_asset_one_field.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_asset_one_field.effect_method_asset_add_asset_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    await effect_method_asset_add_asset_one_field.effect_method_asset_add_asset_one_field.exec({ as: alice })
    const my_asset_after = await effect_method_asset_add_asset_one_field.effect_method_asset_add_asset_one_field.get_my_asset()
    assert(my_asset_after.length == 4)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    assert(my_asset_after[3] == "id3")
  })

  it('effect_method_asset_add_asset_with_aggregate', async () => {
    await effect_method_asset_add_asset_with_aggregate.effect_method_asset_add_asset_with_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_asset_with_aggregate.effect_method_asset_add_asset_with_aggregate.get_my_asset()
    assert(my_asset_before.length == 0)
    const o_asset_before = await effect_method_asset_add_asset_with_aggregate.effect_method_asset_add_asset_with_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(1)))
    assert(o_asset_before[1].equals(new Nat(2)))
    assert(o_asset_before[2].equals(new Nat(3)))
    await effect_method_asset_add_asset_with_aggregate.effect_method_asset_add_asset_with_aggregate.exec({ as: alice })
    const my_asset_after = await effect_method_asset_add_asset_with_aggregate.effect_method_asset_add_asset_with_aggregate.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id3")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    assert(my_asset_after[0][1][1].equals(new Nat(2)))
    assert(my_asset_after[0][1][2].equals(new Nat(3)))
    const o_asset_after = await effect_method_asset_add_asset_with_aggregate.effect_method_asset_add_asset_with_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(1)))
    assert(o_asset_after[1].equals(new Nat(2)))
    assert(o_asset_after[2].equals(new Nat(3)))
  })

  it('effect_method_asset_add_asset_with_partition', async () => {
    await effect_method_asset_add_asset_with_partition.effect_method_asset_add_asset_with_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_asset_with_partition.effect_method_asset_add_asset_with_partition.get_my_asset()
    assert(my_asset_before.length == 0)
    const o_asset_before = await effect_method_asset_add_asset_with_partition.effect_method_asset_add_asset_with_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    await effect_method_asset_add_asset_with_partition.effect_method_asset_add_asset_with_partition.exec({ as: alice })
    const my_asset_after = await effect_method_asset_add_asset_with_partition.effect_method_asset_add_asset_with_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id3")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    assert(my_asset_after[0][1][1].equals(new Nat(2)))
    assert(my_asset_after[0][1][2].equals(new Nat(3)))
    const o_asset_after = await effect_method_asset_add_asset_with_partition.effect_method_asset_add_asset_with_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(1)))
    assert(o_asset_after[1].equals(new Nat(2)))
    assert(o_asset_after[2].equals(new Nat(3)))
  })

  it('effect_method_asset_add_asset_with_partition_2', async () => {
    await effect_method_asset_add_asset_with_partition_2.effect_method_asset_add_asset_with_partition_2.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_asset_with_partition_2.effect_method_asset_add_asset_with_partition_2.get_my_asset()
    assert(my_asset_before.length == 0)
    const o_asset_before = await effect_method_asset_add_asset_with_partition_2.effect_method_asset_add_asset_with_partition_2.get_o_asset()
    assert(o_asset_before.length == 0)
    const o_asset2_before = await effect_method_asset_add_asset_with_partition_2.effect_method_asset_add_asset_with_partition_2.get_o_asset2()
    assert(o_asset2_before.length == 0)
    await effect_method_asset_add_asset_with_partition_2.effect_method_asset_add_asset_with_partition_2.exec({ as: alice })
    const my_asset_after = await effect_method_asset_add_asset_with_partition_2.effect_method_asset_add_asset_with_partition_2.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id3")
    assert(my_asset_after[0][1].apartition.length == 3)
    assert(my_asset_after[0][1].apartition[0].equals(new Nat(1)))
    assert(my_asset_after[0][1].apartition[1].equals(new Nat(2)))
    assert(my_asset_after[0][1].apartition[2].equals(new Nat(3)))
    assert(my_asset_after[0][1].apartition2.length == 3)
    assert(my_asset_after[0][1].apartition2[0].equals(new Nat(4)))
    assert(my_asset_after[0][1].apartition2[1].equals(new Nat(5)))
    assert(my_asset_after[0][1].apartition2[2].equals(new Nat(6)))
    const o_asset_after = await effect_method_asset_add_asset_with_partition_2.effect_method_asset_add_asset_with_partition_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(1)))
    assert(o_asset_after[1].equals(new Nat(2)))
    assert(o_asset_after[2].equals(new Nat(3)))
    const o_asset2_after = await effect_method_asset_add_asset_with_partition_2.effect_method_asset_add_asset_with_partition_2.get_o_asset2()
    assert(o_asset2_after.length == 3)
    assert(o_asset2_after[0].equals(new Nat(4)))
    assert(o_asset2_after[1].equals(new Nat(5)))
    assert(o_asset2_after[2].equals(new Nat(6)))
  })

  it('effect_method_asset_add_partition', async () => {
    await effect_method_asset_add_partition.effect_method_asset_add_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_partition.effect_method_asset_add_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].col.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].col.length == 0)
    const o_asset_before = await effect_method_asset_add_partition.effect_method_asset_add_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    await effect_method_asset_add_partition.effect_method_asset_add_partition.exec({ as: alice })
    const my_asset_after = await effect_method_asset_add_partition.effect_method_asset_add_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].col.length == 1)
    assert(my_asset_after[0][1].col[0] == "oid")
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await effect_method_asset_add_partition.effect_method_asset_add_partition.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0][0] == "oid")
    assert(o_asset_after[0][1].equals(new Int(1)))
  })

  it('effect_method_asset_add_partition_one_field', async () => {
    await effect_method_asset_add_partition_one_field.effect_method_asset_add_partition_one_field.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_add_partition_one_field.effect_method_asset_add_partition_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].col.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].col.length == 0)
    const o_asset_before = await effect_method_asset_add_partition_one_field.effect_method_asset_add_partition_one_field.get_o_asset()
    assert(o_asset_before.length == 0)
    await effect_method_asset_add_partition_one_field.effect_method_asset_add_partition_one_field.exec({ as: alice })
    const my_asset_after = await effect_method_asset_add_partition_one_field.effect_method_asset_add_partition_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].col.length == 1)
    assert(my_asset_after[0][1].col[0] == "oid")
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await effect_method_asset_add_partition_one_field.effect_method_asset_add_partition_one_field.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0] == "oid")
  })

  it('effect_method_asset_addupdate', async () => {
    await effect_method_asset_addupdate.effect_method_asset_addupdate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate.effect_method_asset_addupdate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))

    await effect_method_asset_addupdate.effect_method_asset_addupdate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_addupdate.effect_method_asset_addupdate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(5)))
  })

  it('effect_method_asset_addupdate_partition', async () => {
    await effect_method_asset_addupdate_partition.effect_method_asset_addupdate_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate_partition.effect_method_asset_addupdate_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await effect_method_asset_addupdate_partition.effect_method_asset_addupdate_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await effect_method_asset_addupdate_partition.effect_method_asset_addupdate_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_addupdate_partition.effect_method_asset_addupdate_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    // TODO: Bug
    // assert(my_asset_after[0][1].length == 1)
    // assert(my_asset_after[0][1][0].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await effect_method_asset_addupdate_partition.effect_method_asset_addupdate_partition.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0][0].equals(new Int(0)))
    assert(o_asset_after[0][1].equals(new Int(2)))
  })

  it('effect_method_asset_addupdate_with_add_aggregate', async () => {
    await effect_method_asset_addupdate_with_add_aggregate.effect_method_asset_addupdate_with_add_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate_with_add_aggregate.effect_method_asset_addupdate_with_add_aggregate.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_aggregate.length == 1)
    assert(my_asset_before[0][1].my_aggregate[0].equals(new Nat(0)))
    const o_asset_before = await effect_method_asset_addupdate_with_add_aggregate.effect_method_asset_addupdate_with_add_aggregate.get_o_asset()
    assert(o_asset_before.length == 4)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    assert(o_asset_before[3].equals(new Nat(3)))
    await effect_method_asset_addupdate_with_add_aggregate.effect_method_asset_addupdate_with_add_aggregate.exec({ as: alice })
    const my_asset_after = await effect_method_asset_addupdate_with_add_aggregate.effect_method_asset_addupdate_with_add_aggregate.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_aggregate.length == 3)
    assert(my_asset_after[0][1].my_aggregate[0].equals(new Nat(0)))
    assert(my_asset_after[0][1].my_aggregate[1].equals(new Nat(1)))
    assert(my_asset_after[0][1].my_aggregate[2].equals(new Nat(2)))
    const o_asset_after = await effect_method_asset_addupdate_with_add_aggregate.effect_method_asset_addupdate_with_add_aggregate.get_o_asset()
    assert(o_asset_after.length == 4)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
  })

  it('effect_method_asset_addupdate_with_add_map', async () => {
    await effect_method_asset_addupdate_with_add_map.effect_method_asset_addupdate_with_add_map.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate_with_add_map.effect_method_asset_addupdate_with_add_map.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0][0] == "z")
    assert(my_asset_before[0][1][0][1].equals(new Bytes("ff")))

    await effect_method_asset_addupdate_with_add_map.effect_method_asset_addupdate_with_add_map.exec({ as: alice })

    const my_asset_after = await effect_method_asset_addupdate_with_add_map.effect_method_asset_addupdate_with_add_map.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 4)
    assert(my_asset_after[0][1][0][0] == "k")
    assert(my_asset_after[0][1][0][1].equals(new Bytes("00")))
    assert(my_asset_after[0][1][1][0] == "l")
    assert(my_asset_after[0][1][1][1].equals(new Bytes("01")))
    assert(my_asset_after[0][1][2][0] == "m")
    assert(my_asset_after[0][1][2][1].equals(new Bytes("02")))
    assert(my_asset_after[0][1][3][0] == "z")
    assert(my_asset_after[0][1][3][1].equals(new Bytes("ff")))
  })

  it('effect_method_asset_addupdate_with_add_map_var', async () => {
    await effect_method_asset_addupdate_with_add_map_var.effect_method_asset_addupdate_with_add_map_var.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate_with_add_map_var.effect_method_asset_addupdate_with_add_map_var.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0][0] == "z")
    assert(my_asset_before[0][1][0][1].equals(new Bytes("ff")))

    await effect_method_asset_addupdate_with_add_map_var.effect_method_asset_addupdate_with_add_map_var.exec({ as: alice })

    const my_asset_after = await effect_method_asset_addupdate_with_add_map_var.effect_method_asset_addupdate_with_add_map_var.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 4)
    assert(my_asset_after[0][1][0][0] == "k")
    assert(my_asset_after[0][1][0][1].equals(new Bytes("00")))
    assert(my_asset_after[0][1][1][0] == "l")
    assert(my_asset_after[0][1][1][1].equals(new Bytes("01")))
    assert(my_asset_after[0][1][2][0] == "m")
    assert(my_asset_after[0][1][2][1].equals(new Bytes("02")))
    assert(my_asset_after[0][1][3][0] == "z")
    assert(my_asset_after[0][1][3][1].equals(new Bytes("ff")))
  })

  it('effect_method_asset_addupdate_with_add_partition', async () => {
    await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_partition.length == 0)
    const o_asset_before = await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.init({ as: alice })

    const my_asset_init = await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.get_my_asset()
    assert(my_asset_init.length == 1)
    assert(my_asset_init[0][0] == "my_id")
    assert(my_asset_init[0][1].value.equals(new Int(0)))
    assert(my_asset_init[0][1].my_partition.length == 1)
    assert(my_asset_init[0][1].my_partition[0].equals(new Int(0)))
    const o_asset_init = await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0].equals(new Int(0)))

    await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_partition.length == 4)
    assert(my_asset_after[0][1].my_partition[0].equals(new Int(0)))
    assert(my_asset_after[0][1].my_partition[1].equals(new Int(1)))
    assert(my_asset_after[0][1].my_partition[2].equals(new Int(2)))
    assert(my_asset_after[0][1].my_partition[3].equals(new Int(3)))
    const o_asset_after = await effect_method_asset_addupdate_with_add_partition.effect_method_asset_addupdate_with_add_partition.get_o_asset()
    assert(o_asset_after.length == 4)
    assert(o_asset_after[0].equals(new Int(0)))
    assert(o_asset_after[1].equals(new Int(1)))
    assert(o_asset_after[2].equals(new Int(2)))
    assert(o_asset_after[3].equals(new Int(3)))
  })

  it('effect_method_asset_addupdate_with_add_set', async () => {
    await effect_method_asset_addupdate_with_add_set.effect_method_asset_addupdate_with_add_set.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate_with_add_set.effect_method_asset_addupdate_with_add_set.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0] == "z")

    await effect_method_asset_addupdate_with_add_set.effect_method_asset_addupdate_with_add_set.exec({ as: alice })

    const my_asset_after = await effect_method_asset_addupdate_with_add_set.effect_method_asset_addupdate_with_add_set.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 4)
    assert(my_asset_after[0][1][0] == "k")
    assert(my_asset_after[0][1][1] == "l")
    assert(my_asset_after[0][1][2] == "m")
    assert(my_asset_after[0][1][3] == "z")
  })

  it('effect_method_asset_addupdate_with_remove_map', async () => {
    await effect_method_asset_addupdate_with_remove_map.effect_method_asset_addupdate_with_remove_map.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate_with_remove_map.effect_method_asset_addupdate_with_remove_map.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0][0] == "k")
    assert(my_asset_before[0][1][0][1].equals(new Bytes("00")))
    assert(my_asset_before[0][1][1][0] == "l")
    assert(my_asset_before[0][1][1][1].equals(new Bytes("01")))
    assert(my_asset_before[0][1][2][0] == "m")
    assert(my_asset_before[0][1][2][1].equals(new Bytes("02")))

    await effect_method_asset_addupdate_with_remove_map.effect_method_asset_addupdate_with_remove_map.exec({ as: alice })

    const my_asset_after = await effect_method_asset_addupdate_with_remove_map.effect_method_asset_addupdate_with_remove_map.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 2)
    assert(my_asset_after[0][1][0][0] == "l")
    assert(my_asset_after[0][1][0][1].equals(new Bytes("01")))
    assert(my_asset_after[0][1][1][0] == "m")
    assert(my_asset_after[0][1][1][1].equals(new Bytes("02")))
  })

  it('effect_method_asset_addupdate_with_remove_set', async () => {
    await effect_method_asset_addupdate_with_remove_set.effect_method_asset_addupdate_with_remove_set.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_addupdate_with_remove_set.effect_method_asset_addupdate_with_remove_set.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0] == "k")
    assert(my_asset_before[0][1][1] == "l")
    assert(my_asset_before[0][1][2] == "m")

    await effect_method_asset_addupdate_with_remove_set.effect_method_asset_addupdate_with_remove_set.exec({ as: alice })

    const my_asset_after = await effect_method_asset_addupdate_with_remove_set.effect_method_asset_addupdate_with_remove_set.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 2)
    assert(my_asset_after[0][1][0] == "l")
    assert(my_asset_after[0][1][1] == "m")
  })

  it('effect_method_asset_addupdate_with_replace_aggregate', async () => {
    await effect_method_asset_addupdate_with_replace_aggregate.effect_method_asset_addupdate_with_replace_aggregate.deploy({ as: alice })

    const o_asset_before = await effect_method_asset_addupdate_with_replace_aggregate.effect_method_asset_addupdate_with_replace_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(1)))
    assert(o_asset_before[1].equals(new Nat(2)))
    assert(o_asset_before[2].equals(new Nat(3)))
    const my_asset_before = await effect_method_asset_addupdate_with_replace_aggregate.effect_method_asset_addupdate_with_replace_aggregate.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_aggregate.length == 0)

    await effect_method_asset_addupdate_with_replace_aggregate.effect_method_asset_addupdate_with_replace_aggregate.exec({ as: alice })

    const o_asset_after = await effect_method_asset_addupdate_with_replace_aggregate.effect_method_asset_addupdate_with_replace_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(1)))
    assert(o_asset_after[1].equals(new Nat(2)))
    assert(o_asset_after[2].equals(new Nat(3)))
    const my_asset_after = await effect_method_asset_addupdate_with_replace_aggregate.effect_method_asset_addupdate_with_replace_aggregate.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_aggregate.length == 3)
    assert(my_asset_after[0][1].my_aggregate[0].equals(new Nat(1)))
    assert(my_asset_after[0][1].my_aggregate[1].equals(new Nat(2)))
    assert(my_asset_after[0][1].my_aggregate[2].equals(new Nat(3)))
  })

  it('effect_method_asset_addupdate_with_replace_partition', async () => {
    await effect_method_asset_addupdate_with_replace_partition.effect_method_asset_addupdate_with_replace_partition.deploy({ as: alice })

    const o_asset_before = await effect_method_asset_addupdate_with_replace_partition.effect_method_asset_addupdate_with_replace_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const my_asset_before = await effect_method_asset_addupdate_with_replace_partition.effect_method_asset_addupdate_with_replace_partition.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_partition.length == 0)

    await effect_method_asset_addupdate_with_replace_partition.effect_method_asset_addupdate_with_replace_partition.exec({ as: alice })

    const o_asset_after = await effect_method_asset_addupdate_with_replace_partition.effect_method_asset_addupdate_with_replace_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(1)))
    assert(o_asset_after[1].equals(new Nat(2)))
    assert(o_asset_after[2].equals(new Nat(3)))
    const my_asset_after = await effect_method_asset_addupdate_with_replace_partition.effect_method_asset_addupdate_with_replace_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_partition.length == 3)
    assert(my_asset_after[0][1].my_partition[0].equals(new Nat(1)))
    assert(my_asset_after[0][1].my_partition[1].equals(new Nat(2)))
    assert(my_asset_after[0][1].my_partition[2].equals(new Nat(3)))
  })

  it('effect_method_asset_big_map_0_put_remove_put', async () => {
    await effect_method_asset_big_map_0_put_remove_put.effect_method_asset_big_map_0_put_remove_put.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_big_map_0_put_remove_put.effect_method_asset_big_map_0_put_remove_put.get_my_asset_value(new Nat(0))
    assert(my_asset_before == undefined)
    await effect_method_asset_big_map_0_put_remove_put.effect_method_asset_big_map_0_put_remove_put.exec(new Unit(), { as: alice })
    const my_asset_after = await effect_method_asset_big_map_0_put_remove_put.effect_method_asset_big_map_0_put_remove_put.get_my_asset_value(new Nat(0))
    assert(my_asset_after?.equals(new Unit()))
  })

  it('effect_method_asset_big_map_0_put_remove_remove', async () => {
    await effect_method_asset_big_map_0_put_remove_remove.effect_method_asset_big_map_0_put_remove_remove.deploy({ as: alice })

    const my_asset_0_before = await effect_method_asset_big_map_0_put_remove_remove.effect_method_asset_big_map_0_put_remove_remove.get_my_asset_value(new Nat(0))
    assert(my_asset_0_before?.equals(new Unit()))
    const my_asset_1_before = await effect_method_asset_big_map_0_put_remove_remove.effect_method_asset_big_map_0_put_remove_remove.get_my_asset_value(new Nat(1))
    assert(my_asset_1_before?.equals(new Unit()))
    const my_asset_2_before = await effect_method_asset_big_map_0_put_remove_remove.effect_method_asset_big_map_0_put_remove_remove.get_my_asset_value(new Nat(2))
    assert(my_asset_2_before?.equals(new Unit()))
    await effect_method_asset_big_map_0_put_remove_remove.effect_method_asset_big_map_0_put_remove_remove.exec({ as: alice })
    const my_asset_0_after = await effect_method_asset_big_map_0_put_remove_remove.effect_method_asset_big_map_0_put_remove_remove.get_my_asset_value(new Nat(0))
    assert(my_asset_0_after == undefined)
    const my_asset_1_after = await effect_method_asset_big_map_0_put_remove_remove.effect_method_asset_big_map_0_put_remove_remove.get_my_asset_value(new Nat(1))
    assert(my_asset_1_after?.equals(new Unit()))
    const my_asset_2_after = await effect_method_asset_big_map_0_put_remove_remove.effect_method_asset_big_map_0_put_remove_remove.get_my_asset_value(new Nat(2))
    assert(my_asset_2_after?.equals(new Unit()))
  })

  it('effect_method_asset_big_map_1_put_remove_put', async () => {
    await effect_method_asset_big_map_1_put_remove_put.effect_method_asset_big_map_1_put_remove_put.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_big_map_1_put_remove_put.effect_method_asset_big_map_1_put_remove_put.get_my_asset_value(new Nat(0))
    assert(my_asset_before == undefined)
    await effect_method_asset_big_map_1_put_remove_put.effect_method_asset_big_map_1_put_remove_put.exec("mystr", { as: alice })
    const my_asset_after = await effect_method_asset_big_map_1_put_remove_put.effect_method_asset_big_map_1_put_remove_put.get_my_asset_value(new Nat(0))
    assert(my_asset_after == "mystr")
  })

  it('effect_method_asset_big_map_1_put_remove_remove', async () => {
    await effect_method_asset_big_map_1_put_remove_remove.effect_method_asset_big_map_1_put_remove_remove.deploy({ as: alice })

    const my_asset_0_before = await effect_method_asset_big_map_1_put_remove_remove.effect_method_asset_big_map_1_put_remove_remove.get_my_asset_value(new Nat(0))
    assert(my_asset_0_before == "id0")
    const my_asset_1_before = await effect_method_asset_big_map_1_put_remove_remove.effect_method_asset_big_map_1_put_remove_remove.get_my_asset_value(new Nat(1))
    assert(my_asset_1_before == "id1")
    const my_asset_2_before = await effect_method_asset_big_map_1_put_remove_remove.effect_method_asset_big_map_1_put_remove_remove.get_my_asset_value(new Nat(2))
    assert(my_asset_2_before == "id2")
    await effect_method_asset_big_map_1_put_remove_remove.effect_method_asset_big_map_1_put_remove_remove.exec({ as: alice })
    const my_asset_0_after = await effect_method_asset_big_map_1_put_remove_remove.effect_method_asset_big_map_1_put_remove_remove.get_my_asset_value(new Nat(0))
    assert(my_asset_0_after == undefined)
    const my_asset_1_after = await effect_method_asset_big_map_1_put_remove_remove.effect_method_asset_big_map_1_put_remove_remove.get_my_asset_value(new Nat(1))
    assert(my_asset_1_after == "id1")
    const my_asset_2_after = await effect_method_asset_big_map_1_put_remove_remove.effect_method_asset_big_map_1_put_remove_remove.get_my_asset_value(new Nat(2))
    assert(my_asset_2_after == "id2")
  })

  it('effect_method_asset_big_map_2_put_remove_put', async () => {
    await effect_method_asset_big_map_2_put_remove_put.effect_method_asset_big_map_2_put_remove_put.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_big_map_2_put_remove_put.effect_method_asset_big_map_2_put_remove_put.get_my_asset_value(new Nat(0))
    assert(my_asset_before == undefined)
    const v = new effect_method_asset_big_map_2_put_remove_put.my_asset_value("mystr", new Bytes("00"))
    await effect_method_asset_big_map_2_put_remove_put.effect_method_asset_big_map_2_put_remove_put.exec(v, { as: alice })
    const my_asset_after = await effect_method_asset_big_map_2_put_remove_put.effect_method_asset_big_map_2_put_remove_put.get_my_asset_value(new Nat(0))
    assert(my_asset_after?.equals(v))
  })

  it('effect_method_asset_big_map_2_put_remove_remove', async () => {
    await effect_method_asset_big_map_2_put_remove_remove.effect_method_asset_big_map_2_put_remove_remove.deploy({ as: alice })

    const my_asset_0_before = await effect_method_asset_big_map_2_put_remove_remove.effect_method_asset_big_map_2_put_remove_remove.get_my_asset_value(new Nat(0))
    assert(my_asset_0_before?.equals(new effect_method_asset_big_map_2_put_remove_remove.my_asset_value("id0", new Bytes("00"))))
    const my_asset_1_before = await effect_method_asset_big_map_2_put_remove_remove.effect_method_asset_big_map_2_put_remove_remove.get_my_asset_value(new Nat(1))
    assert(my_asset_1_before?.equals(new effect_method_asset_big_map_2_put_remove_remove.my_asset_value("id1", new Bytes("01"))))
    const my_asset_2_before = await effect_method_asset_big_map_2_put_remove_remove.effect_method_asset_big_map_2_put_remove_remove.get_my_asset_value(new Nat(2))
    assert(my_asset_2_before?.equals(new effect_method_asset_big_map_2_put_remove_remove.my_asset_value("id2", new Bytes("02"))))
    await effect_method_asset_big_map_2_put_remove_remove.effect_method_asset_big_map_2_put_remove_remove.exec({ as: alice })
    const my_asset_0_after = await effect_method_asset_big_map_2_put_remove_remove.effect_method_asset_big_map_2_put_remove_remove.get_my_asset_value(new Nat(0))
    assert(my_asset_0_after == undefined)
    const my_asset_1_after = await effect_method_asset_big_map_2_put_remove_remove.effect_method_asset_big_map_2_put_remove_remove.get_my_asset_value(new Nat(1))
    assert(my_asset_1_after?.equals(new effect_method_asset_big_map_2_put_remove_remove.my_asset_value("id1", new Bytes("01"))))
    const my_asset_2_after = await effect_method_asset_big_map_2_put_remove_remove.effect_method_asset_big_map_2_put_remove_remove.get_my_asset_value(new Nat(2))
    assert(my_asset_2_after?.equals(new effect_method_asset_big_map_2_put_remove_remove.my_asset_value("id2", new Bytes("02"))))
  })

  it('effect_method_asset_clear_view', async () => {
    await effect_method_asset_clear_view.effect_method_asset_clear_view.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_clear_view.effect_method_asset_clear_view.get_my_asset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))

    await effect_method_asset_clear_view.effect_method_asset_clear_view.exec({ as: alice })

    const my_asset_after = await effect_method_asset_clear_view.effect_method_asset_clear_view.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id1")
    assert(my_asset_after[0][1].equals(new Int(1)))
  })

  it('effect_method_asset_clear_view_with_aggregate', async () => {
    await effect_method_asset_clear_view_with_aggregate.effect_method_asset_clear_view_with_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_clear_view_with_aggregate.effect_method_asset_clear_view_with_aggregate.get_my_asset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].p.length == 1)
    assert(my_asset_before[0][1].p[0].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].p.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].p.length == 0)

    const o_asset_before = await effect_method_asset_clear_view_with_aggregate.effect_method_asset_clear_view_with_aggregate.get_o_asset();
    assert(o_asset_before.length == 1)
    assert(o_asset_before[0].equals(new Int(0)))

    await effect_method_asset_clear_view_with_aggregate.effect_method_asset_clear_view_with_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_clear_view_with_aggregate.effect_method_asset_clear_view_with_aggregate.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id1")
    assert(my_asset_after[0][1].value.equals(new Int(1)))
    assert(my_asset_after[0][1].p.length == 0)

    const o_asset_after = await effect_method_asset_clear_view_with_aggregate.effect_method_asset_clear_view_with_aggregate.get_o_asset();
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0].equals(new Int(0)))
  })

  it('effect_method_asset_clear_view_with_partition', async () => {
    await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.get_my_asset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].p.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].p.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].p.length == 0)

    const o_asset_before = await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.get_o_asset();
    assert(o_asset_before.length == 0)

    await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.init({ as: alice })

    const my_asset_init = await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.get_my_asset();
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].value.equals(new Int(0)))
    assert(my_asset_init[0][1].p.length == 1)
    assert(my_asset_init[0][1].p[0].equals(new Int(0)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].value.equals(new Int(1)))
    assert(my_asset_init[1][1].p.length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].value.equals(new Int(2)))
    assert(my_asset_init[2][1].p.length == 0)

    const o_asset_init = await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.get_o_asset();
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0].equals(new Int(0)))

    await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id1")
    assert(my_asset_after[0][1].value.equals(new Int(1)))
    assert(my_asset_after[0][1].p.length == 0)

    const o_asset_after = await effect_method_asset_clear_view_with_partition.effect_method_asset_clear_view_with_partition.get_o_asset();
    assert(o_asset_after.length == 0)
  })

  it('effect_method_asset_map_0_put_remove_put', async () => {
    await effect_method_asset_map_0_put_remove_put.effect_method_asset_map_0_put_remove_put.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_map_0_put_remove_put.effect_method_asset_map_0_put_remove_put.get_my_asset();
    assert(my_asset_before.length == 0)

    await effect_method_asset_map_0_put_remove_put.effect_method_asset_map_0_put_remove_put.exec(new Unit(), { as: alice })

    const my_asset_after = await effect_method_asset_map_0_put_remove_put.effect_method_asset_map_0_put_remove_put.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0].equals(new Nat(0)))
  })

  it('effect_method_asset_map_0_put_remove_remove', async () => {
    await effect_method_asset_map_0_put_remove_remove.effect_method_asset_map_0_put_remove_remove.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_map_0_put_remove_remove.effect_method_asset_map_0_put_remove_remove.get_my_asset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))

    await effect_method_asset_map_0_put_remove_remove.effect_method_asset_map_0_put_remove_remove.exec({ as: alice })

    const my_asset_after = await effect_method_asset_map_0_put_remove_remove.effect_method_asset_map_0_put_remove_remove.get_my_asset();
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0].equals(new Nat(1)))
    assert(my_asset_after[1].equals(new Nat(2)))
  })

  it('effect_method_asset_map_1_put_remove_put', async () => {
    await effect_method_asset_map_1_put_remove_put.effect_method_asset_map_1_put_remove_put.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_map_1_put_remove_put.effect_method_asset_map_1_put_remove_put.get_my_asset();
    assert(my_asset_before.length == 0)

    await effect_method_asset_map_1_put_remove_put.effect_method_asset_map_1_put_remove_put.exec("mystr", { as: alice })

    const my_asset_after = await effect_method_asset_map_1_put_remove_put.effect_method_asset_map_1_put_remove_put.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr")
  })

  it('effect_method_asset_map_1_put_remove_remove', async () => {
    await effect_method_asset_map_1_put_remove_remove.effect_method_asset_map_1_put_remove_remove.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_map_1_put_remove_remove.effect_method_asset_map_1_put_remove_remove.get_my_asset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "id0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "id1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "id2")

    await effect_method_asset_map_1_put_remove_remove.effect_method_asset_map_1_put_remove_remove.exec({ as: alice })

    const my_asset_after = await effect_method_asset_map_1_put_remove_remove.effect_method_asset_map_1_put_remove_remove.get_my_asset();
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0].equals(new Nat(1)))
    assert(my_asset_after[0][1] == "id1")
    assert(my_asset_after[1][0].equals(new Nat(2)))
    assert(my_asset_after[1][1] == "id2")
  })

  it('effect_method_asset_map_2_put_remove_put', async () => {
    await effect_method_asset_map_2_put_remove_put.effect_method_asset_map_2_put_remove_put.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_map_2_put_remove_put.effect_method_asset_map_2_put_remove_put.get_my_asset();
    assert(my_asset_before.length == 0)

    const v = new effect_method_asset_map_2_put_remove_put.my_asset_value("mystr", new Bytes("00"));
    await effect_method_asset_map_2_put_remove_put.effect_method_asset_map_2_put_remove_put.exec(v, { as: alice })

    const my_asset_after = await effect_method_asset_map_2_put_remove_put.effect_method_asset_map_2_put_remove_put.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].equals(v))
  })

  it('effect_method_asset_map_2_put_remove_remove', async () => {
    await effect_method_asset_map_2_put_remove_remove.effect_method_asset_map_2_put_remove_remove.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_map_2_put_remove_remove.effect_method_asset_map_2_put_remove_remove.get_my_asset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].equals(new effect_method_asset_map_2_put_remove_put.my_asset_value("id0", new Bytes("00"))))
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].equals(new effect_method_asset_map_2_put_remove_put.my_asset_value("id1", new Bytes("01"))))
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].equals(new effect_method_asset_map_2_put_remove_put.my_asset_value("id2", new Bytes("02"))))

    await effect_method_asset_map_2_put_remove_remove.effect_method_asset_map_2_put_remove_remove.exec({ as: alice })

    const my_asset_after = await effect_method_asset_map_2_put_remove_remove.effect_method_asset_map_2_put_remove_remove.get_my_asset();
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0].equals(new Nat(1)))
    assert(my_asset_after[0][1].equals(new effect_method_asset_map_2_put_remove_put.my_asset_value("id1", new Bytes("01"))))
    assert(my_asset_after[1][0].equals(new Nat(2)))
    assert(my_asset_after[1][1].equals(new effect_method_asset_map_2_put_remove_put.my_asset_value("id2", new Bytes("02"))))
  })

  it('effect_method_asset_remove_aggregate', async () => {
    await effect_method_asset_remove_aggregate.effect_method_asset_remove_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_aggregate.effect_method_asset_remove_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].col.length == 1)
    assert(my_asset_before[0][1].col[0] == "oid")
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].col.length == 0)

    const o_asset_before = await effect_method_asset_remove_aggregate.effect_method_asset_remove_aggregate.get_o_asset()
    assert(o_asset_before.length == 1)
    assert(o_asset_before[0] == "oid")

    await effect_method_asset_remove_aggregate.effect_method_asset_remove_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_aggregate.effect_method_asset_remove_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].col.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].col.length == 0)

    const o_asset_after = await effect_method_asset_remove_aggregate.effect_method_asset_remove_aggregate.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0] == "oid")
  })

  it('effect_method_asset_remove_all_aggregate', async () => {
    await effect_method_asset_remove_all_aggregate.effect_method_asset_remove_all_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_all_aggregate.effect_method_asset_remove_all_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].col.length == 1)
    assert(my_asset_before[0][1].col[0] == "oid")
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].col.length == 0)

    const o_asset_before = await effect_method_asset_remove_all_aggregate.effect_method_asset_remove_all_aggregate.get_o_asset()
    assert(o_asset_before.length == 1)
    assert(o_asset_before[0][0] == "oid")
    assert(o_asset_before[0][1].equals(new Int(2)))

    await effect_method_asset_remove_all_aggregate.effect_method_asset_remove_all_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_all_aggregate.effect_method_asset_remove_all_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].col.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].col.length == 0)

    const o_asset_after = await effect_method_asset_remove_all_aggregate.effect_method_asset_remove_all_aggregate.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0][0] == "oid")
    assert(o_asset_after[0][1].equals(new Int(2)))
  })

  it('effect_method_asset_remove_all_asset_one_field', async () => {
    await effect_method_asset_remove_all_asset_one_field.effect_method_asset_remove_all_asset_one_field.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_all_asset_one_field.effect_method_asset_remove_all_asset_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")

    await effect_method_asset_remove_all_asset_one_field.effect_method_asset_remove_all_asset_one_field.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_all_asset_one_field.effect_method_asset_remove_all_asset_one_field.get_my_asset()
    assert(my_asset_after.length == 0)
  })

  it('effect_method_asset_remove_all_asset_with_aggregate', async () => {
    await effect_method_asset_remove_all_asset_with_aggregate.effect_method_asset_remove_all_asset_with_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_all_asset_with_aggregate.effect_method_asset_remove_all_asset_with_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].p.length == 1)
    assert(my_asset_before[0][1].p[0].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].p.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].p.length == 0)

    const o_asset_before = await effect_method_asset_remove_all_asset_with_aggregate.effect_method_asset_remove_all_asset_with_aggregate.get_o_asset()
    assert(o_asset_before.length == 1)
    assert(o_asset_before[0].equals(new Int(0)))

    await effect_method_asset_remove_all_asset_with_aggregate.effect_method_asset_remove_all_asset_with_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_all_asset_with_aggregate.effect_method_asset_remove_all_asset_with_aggregate.get_my_asset()
    assert(my_asset_after.length == 0)

    const o_asset_after = await effect_method_asset_remove_all_asset_with_aggregate.effect_method_asset_remove_all_asset_with_aggregate.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0].equals(new Int(0)))
  })

  it('effect_method_asset_remove_all_asset_with_partition', async () => {
    await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].p.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].p.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].p.length == 0)

    const o_asset_before = await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.init({ as: alice })

    const my_asset_init = await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].value.equals(new Int(0)))
    assert(my_asset_init[0][1].p.length == 1)
    assert(my_asset_init[0][1].p[0].equals(new Int(0)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].value.equals(new Int(1)))
    assert(my_asset_init[1][1].p.length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].value.equals(new Int(2)))
    assert(my_asset_init[2][1].p.length == 0)

    const o_asset_init = await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0].equals(new Int(0)))

    await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.get_my_asset()
    assert(my_asset_after.length == 0)

    const o_asset_after = await effect_method_asset_remove_all_asset_with_partition.effect_method_asset_remove_all_asset_with_partition.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('effect_method_asset_remove_all_collection', async () => {
    await effect_method_asset_remove_all_collection.effect_method_asset_remove_all_collection.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_all_collection.effect_method_asset_remove_all_collection.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))

    await effect_method_asset_remove_all_collection.effect_method_asset_remove_all_collection.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_all_collection.effect_method_asset_remove_all_collection.get_my_asset()
    assert(my_asset_after.length == 0)
  })

  it('effect_method_asset_remove_asset', async () => {
    await effect_method_asset_remove_asset.effect_method_asset_remove_asset.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_asset.effect_method_asset_remove_asset.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))

    await effect_method_asset_remove_asset.effect_method_asset_remove_asset.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_asset.effect_method_asset_remove_asset.get_my_asset()
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0] == "id1")
    assert(my_asset_after[0][1].equals(new Int(1)))
    assert(my_asset_after[1][0] == "id2")
    assert(my_asset_after[1][1].equals(new Int(2)))
  })

  it('effect_method_asset_remove_asset2', async () => {
    await effect_method_asset_remove_asset2.effect_method_asset_remove_asset2.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_asset2.effect_method_asset_remove_asset2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].v == true)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].v == true)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].v == true)

    await effect_method_asset_remove_asset2.effect_method_asset_remove_asset2.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_asset2.effect_method_asset_remove_asset2.get_my_asset()
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0] == "id1")
    assert(my_asset_after[0][1].value.equals(new Int(1)))
    assert(my_asset_after[0][1].v == true)
    assert(my_asset_after[1][0] == "id2")
    assert(my_asset_after[1][1].value.equals(new Int(2)))
    assert(my_asset_after[1][1].v == true)
  })

  it('effect_method_asset_remove_asset_one_field', async () => {
    await effect_method_asset_remove_asset_one_field.effect_method_asset_remove_asset_one_field.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_asset_one_field.effect_method_asset_remove_asset_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")

    await effect_method_asset_remove_asset_one_field.effect_method_asset_remove_asset_one_field.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_asset_one_field.effect_method_asset_remove_asset_one_field.get_my_asset()
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0] == "id1")
    assert(my_asset_after[1] == "id2")
  })

  it('effect_method_asset_remove_asset_with_aggregate', async () => {
    await effect_method_asset_remove_asset_with_aggregate.effect_method_asset_remove_asset_with_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_asset_with_aggregate.effect_method_asset_remove_asset_with_aggregate.get_my_asset()
    assert(my_asset_before.length == 4)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(1)))
    assert(my_asset_before[0][1][1].equals(new Nat(2)))
    assert(my_asset_before[0][1][2].equals(new Nat(3)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 3)
    assert(my_asset_before[1][1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1][1].equals(new Nat(2)))
    assert(my_asset_before[1][1][2].equals(new Nat(3)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 3)
    assert(my_asset_before[2][1][0].equals(new Nat(1)))
    assert(my_asset_before[2][1][1].equals(new Nat(2)))
    assert(my_asset_before[2][1][2].equals(new Nat(3)))
    assert(my_asset_before[3][0] == "id3")
    assert(my_asset_before[3][1].length == 3)
    assert(my_asset_before[3][1][0].equals(new Nat(1)))
    assert(my_asset_before[3][1][1].equals(new Nat(2)))
    assert(my_asset_before[3][1][2].equals(new Nat(3)))
    const o_asset_before = await effect_method_asset_remove_asset_with_aggregate.effect_method_asset_remove_asset_with_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(1)))
    assert(o_asset_before[1].equals(new Nat(2)))
    assert(o_asset_before[2].equals(new Nat(3)))

    await effect_method_asset_remove_asset_with_aggregate.effect_method_asset_remove_asset_with_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_asset_with_aggregate.effect_method_asset_remove_asset_with_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    assert(my_asset_after[0][1][1].equals(new Nat(2)))
    assert(my_asset_after[0][1][2].equals(new Nat(3)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 3)
    assert(my_asset_after[1][1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1][1].equals(new Nat(2)))
    assert(my_asset_after[1][1][2].equals(new Nat(3)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 3)
    assert(my_asset_after[2][1][0].equals(new Nat(1)))
    assert(my_asset_after[2][1][1].equals(new Nat(2)))
    assert(my_asset_after[2][1][2].equals(new Nat(3)))
    const o_asset_after = await effect_method_asset_remove_asset_with_aggregate.effect_method_asset_remove_asset_with_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(1)))
    assert(o_asset_after[1].equals(new Nat(2)))
    assert(o_asset_after[2].equals(new Nat(3)))
  })

  it('effect_method_asset_remove_asset_with_partition', async () => {
    await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.get_my_asset()
    assert(my_asset_before.length == 4)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    assert(my_asset_before[3][0] == "id3")
    assert(my_asset_before[3][1].length == 0)
    const o_asset_before = await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.init({ as: alice })

    const my_asset_init = await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.get_my_asset()
    assert(my_asset_init.length == 4)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 0)
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    assert(my_asset_init[3][0] == "id3")
    assert(my_asset_init[3][1].length == 1)
    assert(my_asset_init[3][1][0].equals(new Nat(0)))
    const o_asset_init = await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0].equals(new Nat(0)))

    await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await effect_method_asset_remove_asset_with_partition.effect_method_asset_remove_asset_with_partition.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('effect_method_asset_remove_asset_with_partition_2', async () => {
    await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_my_asset()
    assert(my_asset_before.length == 4)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].my_partition_1.length == 0)
    assert(my_asset_before[0][1].my_partition_2.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].my_partition_1.length == 0)
    assert(my_asset_before[1][1].my_partition_2.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].my_partition_1.length == 0)
    assert(my_asset_before[2][1].my_partition_2.length == 0)
    assert(my_asset_before[3][0] == "id3")
    assert(my_asset_before[3][1].my_partition_1.length == 0)
    assert(my_asset_before[3][1].my_partition_2.length == 0)
    const o_asset_before = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_o_asset()
    assert(o_asset_before.length == 0)
    const o_asset2_before = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_o_asset2()
    assert(o_asset2_before.length == 0)

    await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.init({ as: alice })

    const my_asset_init = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_my_asset()
    assert(my_asset_init.length == 4)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].my_partition_1.length == 0)
    assert(my_asset_init[0][1].my_partition_2.length == 0)
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].my_partition_1.length == 0)
    assert(my_asset_init[1][1].my_partition_2.length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].my_partition_1.length == 0)
    assert(my_asset_init[2][1].my_partition_2.length == 0)
    assert(my_asset_init[3][0] == "id3")
    assert(my_asset_init[3][1].my_partition_1.length == 1)
    assert(my_asset_init[3][1].my_partition_1[0].equals(new Nat(0)))
    assert(my_asset_init[3][1].my_partition_2.length == 1)
    assert(my_asset_init[3][1].my_partition_2[0].equals(new Nat(1)))
    const o_asset_init = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0].equals(new Nat(0)))
    const o_asset2_init = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_o_asset2()
    assert(o_asset2_init.length == 1)
    assert(o_asset2_init[0].equals(new Nat(1)))

    await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].my_partition_1.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].my_partition_1.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].my_partition_1.length == 0)
    const o_asset_after = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_o_asset()
    assert(o_asset_after.length == 0)
    const o_asset2_after = await effect_method_asset_remove_asset_with_partition_2.effect_method_asset_remove_asset_with_partition_2.get_o_asset2()
    assert(o_asset2_after.length == 0)
  })

  it('effect_method_asset_remove_partition', async () => {
    await effect_method_asset_remove_partition.effect_method_asset_remove_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_remove_partition.effect_method_asset_remove_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].col.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].col.length == 0)
    const o_asset_before = await effect_method_asset_remove_partition.effect_method_asset_remove_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await effect_method_asset_remove_partition.effect_method_asset_remove_partition.init({ as: alice })

    const my_asset_init = await effect_method_asset_remove_partition.effect_method_asset_remove_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].value.equals(new Int(0)))
    assert(my_asset_init[0][1].col.length == 1)
    assert(my_asset_init[0][1].col[0] == "oid")
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].value.equals(new Int(1)))
    assert(my_asset_init[1][1].col.length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].value.equals(new Int(2)))
    assert(my_asset_init[2][1].col.length == 0)
    const o_asset_init = await effect_method_asset_remove_partition.effect_method_asset_remove_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0] == "oid")

    await effect_method_asset_remove_partition.effect_method_asset_remove_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_remove_partition.effect_method_asset_remove_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].col.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await effect_method_asset_remove_partition.effect_method_asset_remove_partition.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('effect_method_asset_removeall_aggregate', async () => {
    await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.init({ as: alice })

    const my_asset_init = await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 2)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))

    await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await effect_method_asset_removeall_aggregate.effect_method_asset_removeall_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('effect_method_asset_removeall_partition', async () => {
    await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.init({ as: alice })

    const my_asset_init = await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(1)))
    assert(my_asset_init[0][1][1].equals(new Nat(2)))
    assert(my_asset_init[0][1][2].equals(new Nat(3)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(1)))
    assert(o_asset_init[1].equals(new Nat(2)))
    assert(o_asset_init[2].equals(new Nat(3)))

    await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await effect_method_asset_removeall_partition.effect_method_asset_removeall_partition.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('effect_method_asset_removeif_aggregate', async () => {
    await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(1)))
    assert(o_asset_before[0][1].equals(new Int(1)))
    assert(o_asset_before[1][0].equals(new Nat(2)))
    assert(o_asset_before[1][1].equals(new Int(2)))
    assert(o_asset_before[2][0].equals(new Nat(3)))
    assert(o_asset_before[2][1].equals(new Int(3)))

    await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.init({ as: alice })

    const my_asset_init = await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(1)))
    assert(my_asset_init[0][1][1].equals(new Nat(2)))
    assert(my_asset_init[0][1][2].equals(new Nat(3)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0][0].equals(new Nat(1)))
    assert(o_asset_init[0][1].equals(new Int(1)))
    assert(o_asset_init[1][0].equals(new Nat(2)))
    assert(o_asset_init[1][1].equals(new Int(2)))
    assert(o_asset_init[2][0].equals(new Nat(3)))
    assert(o_asset_init[2][1].equals(new Int(3)))

    await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 2)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    assert(my_asset_after[0][1][1].equals(new Nat(3)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await effect_method_asset_removeif_aggregate.effect_method_asset_removeif_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(1)))
    assert(o_asset_after[0][1].equals(new Int(1)))
    assert(o_asset_after[1][0].equals(new Nat(2)))
    assert(o_asset_after[1][1].equals(new Int(2)))
    assert(o_asset_after[2][0].equals(new Nat(3)))
    assert(o_asset_after[2][1].equals(new Int(3)))
  })

  it('effect_method_asset_removeif_collection', async () => {
    await effect_method_asset_removeif_collection.effect_method_asset_removeif_collection.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_removeif_collection.effect_method_asset_removeif_collection.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))

    await effect_method_asset_removeif_collection.effect_method_asset_removeif_collection.exec({ as: alice })

    const my_asset_after = await effect_method_asset_removeif_collection.effect_method_asset_removeif_collection.get_my_asset()
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id2")
    assert(my_asset_after[1][1].equals(new Nat(2)))
  })

  it('effect_method_asset_removeif_collection_with_aggregate', async () => {
    await effect_method_asset_removeif_collection_with_aggregate.effect_method_asset_removeif_collection_with_aggregate.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_removeif_collection_with_aggregate.effect_method_asset_removeif_collection_with_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].c.length == 2)
    assert(my_asset_before[0][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[0][1].c[1].equals(new Nat(1)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].c.length == 1)
    assert(my_asset_before[1][1].c[0].equals(new Nat(2)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await effect_method_asset_removeif_collection_with_aggregate.effect_method_asset_removeif_collection_with_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await effect_method_asset_removeif_collection_with_aggregate.effect_method_asset_removeif_collection_with_aggregate.exec({ as: alice })

    const my_asset_after = await effect_method_asset_removeif_collection_with_aggregate.effect_method_asset_removeif_collection_with_aggregate.get_my_asset()
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].c.length == 2)
    assert(my_asset_after[0][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[0][1].c[1].equals(new Nat(1)))
    assert(my_asset_after[1][0] == "id2")
    assert(my_asset_after[1][1].value.equals(new Int(2)))
    assert(my_asset_after[1][1].c.length == 0)
    const o_asset_after = await effect_method_asset_removeif_collection_with_aggregate.effect_method_asset_removeif_collection_with_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('effect_method_asset_removeif_collection_with_partition', async () => {
    await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(1)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.init({ as: alice })

    const my_asset_init = await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].value.equals(new Int(1)))
    assert(my_asset_init[0][1].c.length == 1)
    assert(my_asset_init[0][1].c[0].equals(new Nat(0)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].value.equals(new Int(1)))
    assert(my_asset_init[1][1].c.length == 2)
    assert(my_asset_init[1][1].c[0].equals(new Nat(1)))
    assert(my_asset_init[1][1].c[1].equals(new Nat(2)))
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].value.equals(new Int(2)))
    assert(my_asset_init[2][1].c.length == 1)
    assert(my_asset_init[2][1].c[0].equals(new Nat(3)))
    const o_asset_init = await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.get_o_asset()
    assert(o_asset_init.length == 4)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    assert(o_asset_init[3].equals(new Nat(3)))

    await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id2")
    assert(my_asset_after[0][1].value.equals(new Int(2)))
    assert(my_asset_after[0][1].c.length == 1)
    assert(my_asset_after[0][1].c[0].equals(new Nat(3)))
    const o_asset_after = await effect_method_asset_removeif_collection_with_partition.effect_method_asset_removeif_collection_with_partition.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0].equals(new Nat(3)))
  })

  it('effect_method_asset_removeif_partition', async () => {
    await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.init({ as: alice })

    const my_asset_init = await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 1)
    assert(my_asset_init[1][1][0].equals(new Nat(3)))
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.get_o_asset()
    assert(o_asset_init.length == 4)
    assert(o_asset_init[0][0].equals(new Nat(0)))
    assert(o_asset_init[0][1].equals(new Nat(0)))
    assert(o_asset_init[1][0].equals(new Nat(1)))
    assert(o_asset_init[1][1].equals(new Nat(1)))
    assert(o_asset_init[2][0].equals(new Nat(2)))
    assert(o_asset_init[2][1].equals(new Nat(2)))
    assert(o_asset_init[3][0].equals(new Nat(3)))
    assert(o_asset_init[3][1].equals(new Nat(3)))

    await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.exec({ as: alice })

    const my_asset_after = await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 2)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    assert(my_asset_after[0][1][1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 1)
    assert(my_asset_after[1][1][0].equals(new Nat(3)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await effect_method_asset_removeif_partition.effect_method_asset_removeif_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(1)))
    assert(o_asset_after[0][1].equals(new Nat(1)))
    assert(o_asset_after[1][0].equals(new Nat(2)))
    assert(o_asset_after[1][1].equals(new Nat(2)))
    assert(o_asset_after[2][0].equals(new Nat(3)))
    assert(o_asset_after[2][1].equals(new Nat(3)))
  })

  it('effect_method_asset_update', async () => {
    await effect_method_asset_update.effect_method_asset_update.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update.effect_method_asset_update.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].v.equals(new Bytes("")))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].v.equals(new Bytes("")))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].v.equals(new Bytes("")))

    await effect_method_asset_update.effect_method_asset_update.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update.effect_method_asset_update.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].v.equals(new Bytes("")))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].v.equals(new Bytes("")))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(3)))
    assert(my_asset_after[2][1].v.equals(new Bytes("")))
  })

  it('effect_method_asset_update_all_coll_1', async () => {
    await effect_method_asset_update_all_coll_1.effect_method_asset_update_all_coll_1.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_all_coll_1.effect_method_asset_update_all_coll_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))

    await effect_method_asset_update_all_coll_1.effect_method_asset_update_all_coll_1.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_all_coll_1.effect_method_asset_update_all_coll_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(3)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(4)))
  })

  it('effect_method_asset_update_all_coll_2', async () => {
    await effect_method_asset_update_all_coll_2.effect_method_asset_update_all_coll_2.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_all_coll_2.effect_method_asset_update_all_coll_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v.equals(new Nat(0)))
    assert(my_asset_before[0][1].i.equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v.equals(new Nat(1)))
    assert(my_asset_before[1][1].i.equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v.equals(new Nat(2)))
    assert(my_asset_before[2][1].i.equals(new Int(2)))

    await effect_method_asset_update_all_coll_2.effect_method_asset_update_all_coll_2.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_all_coll_2.effect_method_asset_update_all_coll_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v.equals(new Nat(2)))
    assert(my_asset_after[0][1].i.equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v.equals(new Nat(3)))
    assert(my_asset_after[1][1].i.equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v.equals(new Nat(4)))
    assert(my_asset_after[2][1].i.equals(new Int(2)))
  })

  it('effect_method_asset_update_all_view_1', async () => {
    await effect_method_asset_update_all_view_1.effect_method_asset_update_all_view_1.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_all_view_1.effect_method_asset_update_all_view_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))

    await effect_method_asset_update_all_view_1.effect_method_asset_update_all_view_1.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_all_view_1.effect_method_asset_update_all_view_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(4)))
  })

  it('effect_method_asset_update_all_view_2', async () => {
    await effect_method_asset_update_all_view_2.effect_method_asset_update_all_view_2.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_all_view_2.effect_method_asset_update_all_view_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v.equals(new Nat(0)))
    assert(my_asset_before[0][1].i.equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v.equals(new Nat(1)))
    assert(my_asset_before[1][1].i.equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v.equals(new Nat(2)))
    assert(my_asset_before[2][1].i.equals(new Int(2)))

    await effect_method_asset_update_all_view_2.effect_method_asset_update_all_view_2.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_all_view_2.effect_method_asset_update_all_view_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v.equals(new Nat(2)))
    assert(my_asset_after[0][1].i.equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v.equals(new Nat(1)))
    assert(my_asset_after[1][1].i.equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v.equals(new Nat(4)))
    assert(my_asset_after[2][1].i.equals(new Int(2)))
  })

  it('effect_method_asset_update_with_add_aggregate', async () => {
    await effect_method_asset_update_with_add_aggregate.effect_method_asset_update_with_add_aggregate.deploy({ as: alice })

    const o_asset_before = await effect_method_asset_update_with_add_aggregate.effect_method_asset_update_with_add_aggregate.get_o_asset()
    assert(o_asset_before.length == 4)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    assert(o_asset_before[3].equals(new Nat(3)))
    const my_asset_before = await effect_method_asset_update_with_add_aggregate.effect_method_asset_update_with_add_aggregate.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_aggregate.length == 1)
    assert(my_asset_before[0][1].my_aggregate[0].equals(new Nat(0)))

    await effect_method_asset_update_with_add_aggregate.effect_method_asset_update_with_add_aggregate.exec({ as: alice })

    const o_asset_after = await effect_method_asset_update_with_add_aggregate.effect_method_asset_update_with_add_aggregate.get_o_asset()
    assert(o_asset_after.length == 4)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
    const my_asset_after = await effect_method_asset_update_with_add_aggregate.effect_method_asset_update_with_add_aggregate.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_aggregate.length == 4)
    assert(my_asset_after[0][1].my_aggregate[0].equals(new Nat(0)))
    assert(my_asset_after[0][1].my_aggregate[1].equals(new Nat(1)))
    assert(my_asset_after[0][1].my_aggregate[2].equals(new Nat(2)))
    assert(my_asset_after[0][1].my_aggregate[3].equals(new Nat(3)))
  })

  it('effect_method_asset_update_with_add_map', async () => {
    await effect_method_asset_update_with_add_map.effect_method_asset_update_with_add_map.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_with_add_map.effect_method_asset_update_with_add_map.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0][0] == "a")
    assert(my_asset_before[0][1][0][1].equals(new Bytes("ff")))

    await effect_method_asset_update_with_add_map.effect_method_asset_update_with_add_map.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_with_add_map.effect_method_asset_update_with_add_map.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 4)
    assert(my_asset_after[0][1][0][0] == "a")
    assert(my_asset_after[0][1][0][1].equals(new Bytes("ff")))
    assert(my_asset_after[0][1][1][0] == "k")
    assert(my_asset_after[0][1][1][1].equals(new Bytes("00")))
    assert(my_asset_after[0][1][2][0] == "l")
    assert(my_asset_after[0][1][2][1].equals(new Bytes("01")))
    assert(my_asset_after[0][1][3][0] == "m")
    assert(my_asset_after[0][1][3][1].equals(new Bytes("02")))
  })

  it('effect_method_asset_update_with_add_partition', async () => {
    await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.deploy({ as: alice })

    const o_asset_before = await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const my_asset_before = await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_partition.length == 0)

    await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.init({ as: alice })

    const o_asset_init = await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0].equals(new Nat(0)))
    const my_asset_init = await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.get_my_asset()
    assert(my_asset_init.length == 1)
    assert(my_asset_init[0][0] == "my_id")
    assert(my_asset_init[0][1].value.equals(new Int(0)))
    assert(my_asset_init[0][1].my_partition.length == 1)
    assert(my_asset_init[0][1].my_partition[0].equals(new Nat(0)))

    await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.exec({ as: alice })

    const o_asset_after = await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.get_o_asset()
    assert(o_asset_after.length == 4)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
    const my_asset_after = await effect_method_asset_update_with_add_partition.effect_method_asset_update_with_add_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_partition.length == 4)
    assert(my_asset_after[0][1].my_partition[0].equals(new Nat(0)))
    assert(my_asset_after[0][1].my_partition[1].equals(new Nat(1)))
    assert(my_asset_after[0][1].my_partition[2].equals(new Nat(2)))
    assert(my_asset_after[0][1].my_partition[3].equals(new Nat(3)))
  })

  it('effect_method_asset_update_with_add_set', async () => {
    await effect_method_asset_update_with_add_set.effect_method_asset_update_with_add_set.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_with_add_set.effect_method_asset_update_with_add_set.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0] == "a")

    await effect_method_asset_update_with_add_set.effect_method_asset_update_with_add_set.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_with_add_set.effect_method_asset_update_with_add_set.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 4)
    assert(my_asset_after[0][1][0] == "a")
    assert(my_asset_after[0][1][1] == "k")
    assert(my_asset_after[0][1][2] == "l")
    assert(my_asset_after[0][1][3] == "m")
  })

  it('effect_method_asset_update_with_map', async () => {
    await effect_method_asset_update_with_map.effect_method_asset_update_with_map.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_with_map.effect_method_asset_update_with_map.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0][0] == "a")
    assert(my_asset_before[0][1][0][1].equals(new Bytes("ff")))

    await effect_method_asset_update_with_map.effect_method_asset_update_with_map.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_with_map.effect_method_asset_update_with_map.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0][0] == "k")
    assert(my_asset_after[0][1][0][1].equals(new Bytes("00")))
  })

  it('effect_method_asset_update_with_remove_aggregate', async () => {
    await effect_method_asset_update_with_remove_aggregate.effect_method_asset_update_with_remove_aggregate.deploy({ as: alice })

    const o_asset_before = await effect_method_asset_update_with_remove_aggregate.effect_method_asset_update_with_remove_aggregate.get_o_asset()
    assert(o_asset_before.length == 4)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    assert(o_asset_before[3].equals(new Nat(3)))
    const my_asset_before = await effect_method_asset_update_with_remove_aggregate.effect_method_asset_update_with_remove_aggregate.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_aggregate.length == 4)
    assert(my_asset_before[0][1].my_aggregate[0].equals(new Nat(0)))
    assert(my_asset_before[0][1].my_aggregate[1].equals(new Nat(1)))
    assert(my_asset_before[0][1].my_aggregate[2].equals(new Nat(2)))
    assert(my_asset_before[0][1].my_aggregate[3].equals(new Nat(3)))

    await effect_method_asset_update_with_remove_aggregate.effect_method_asset_update_with_remove_aggregate.exec({ as: alice })

    const o_asset_after = await effect_method_asset_update_with_remove_aggregate.effect_method_asset_update_with_remove_aggregate.get_o_asset()
    assert(o_asset_after.length == 4)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
    const my_asset_after = await effect_method_asset_update_with_remove_aggregate.effect_method_asset_update_with_remove_aggregate.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_aggregate.length == 1)
    assert(my_asset_after[0][1].my_aggregate[0].equals(new Nat(0)))
  })

  it('effect_method_asset_update_with_remove_map', async () => {
    await effect_method_asset_update_with_remove_map.effect_method_asset_update_with_remove_map.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_with_remove_map.effect_method_asset_update_with_remove_map.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0][0] == "k")
    assert(my_asset_before[0][1][0][1].equals(new Bytes("00")))
    assert(my_asset_before[0][1][1][0] == "l")
    assert(my_asset_before[0][1][1][1].equals(new Bytes("01")))
    assert(my_asset_before[0][1][2][0] == "m")
    assert(my_asset_before[0][1][2][1].equals(new Bytes("02")))

    await effect_method_asset_update_with_remove_map.effect_method_asset_update_with_remove_map.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_with_remove_map.effect_method_asset_update_with_remove_map.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0][0] == "l")
    assert(my_asset_after[0][1][0][1].equals(new Bytes("01")))
  })

  it('effect_method_asset_update_with_remove_partition', async () => {
    await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.deploy({ as: alice })

    const o_asset_before = await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const my_asset_before = await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_partition.length == 0)

    await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.init({ as: alice })

    const o_asset_init = await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.get_o_asset()
    assert(o_asset_init.length == 4)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    assert(o_asset_init[3].equals(new Nat(3)))
    const my_asset_init = await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.get_my_asset()
    assert(my_asset_init.length == 1)
    assert(my_asset_init[0][0] == "my_id")
    assert(my_asset_init[0][1].value.equals(new Int(0)))
    assert(my_asset_init[0][1].my_partition.length == 4)
    assert(my_asset_init[0][1].my_partition[0].equals(new Nat(0)))
    assert(my_asset_init[0][1].my_partition[1].equals(new Nat(1)))
    assert(my_asset_init[0][1].my_partition[2].equals(new Nat(2)))
    assert(my_asset_init[0][1].my_partition[3].equals(new Nat(3)))

    await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.exec({ as: alice })

    const o_asset_after = await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0].equals(new Nat(0)))
    const my_asset_after = await effect_method_asset_update_with_remove_partition.effect_method_asset_update_with_remove_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_partition.length == 1)
    assert(my_asset_after[0][1].my_partition[0].equals(new Nat(0)))
  })

  it('effect_method_asset_update_with_remove_set', async () => {
    await effect_method_asset_update_with_remove_set.effect_method_asset_update_with_remove_set.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_with_remove_set.effect_method_asset_update_with_remove_set.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0] == "k")
    assert(my_asset_before[0][1][1] == "l")
    assert(my_asset_before[0][1][2] == "m")

    await effect_method_asset_update_with_remove_set.effect_method_asset_update_with_remove_set.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_with_remove_set.effect_method_asset_update_with_remove_set.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0] == "l")
  })

  it('effect_method_asset_update_with_replace_aggregate', async () => {
    await effect_method_asset_update_with_replace_aggregate.effect_method_asset_update_with_replace_aggregate.deploy({ as: alice })

    const o_asset_before = await effect_method_asset_update_with_replace_aggregate.effect_method_asset_update_with_replace_aggregate.get_o_asset()
    assert(o_asset_before.length == 4)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    assert(o_asset_before[3].equals(new Nat(3)))
    const my_asset_before = await effect_method_asset_update_with_replace_aggregate.effect_method_asset_update_with_replace_aggregate.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_aggregate.length == 1)
    assert(my_asset_before[0][1].my_aggregate[0].equals(new Nat(0)))

    await effect_method_asset_update_with_replace_aggregate.effect_method_asset_update_with_replace_aggregate.exec({ as: alice })

    const o_asset_after = await effect_method_asset_update_with_replace_aggregate.effect_method_asset_update_with_replace_aggregate.get_o_asset()
    assert(o_asset_after.length == 4)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
    const my_asset_after = await effect_method_asset_update_with_replace_aggregate.effect_method_asset_update_with_replace_aggregate.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_aggregate.length == 3)
    assert(my_asset_after[0][1].my_aggregate[0].equals(new Nat(1)))
    assert(my_asset_after[0][1].my_aggregate[1].equals(new Nat(2)))
    assert(my_asset_after[0][1].my_aggregate[2].equals(new Nat(3)))
  })

  it('effect_method_asset_update_with_replace_partition', async () => {
    await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.deploy({ as: alice })

    const o_asset_before = await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const my_asset_before = await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].my_partition.length == 0)

    await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.init({ as: alice })

    const o_asset_init = await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0].equals(new Nat(0)))
    const my_asset_init = await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.get_my_asset()
    assert(my_asset_init.length == 1)
    assert(my_asset_init[0][0] == "my_id")
    assert(my_asset_init[0][1].value.equals(new Int(0)))
    assert(my_asset_init[0][1].my_partition.length == 1)
    assert(my_asset_init[0][1].my_partition[0].equals(new Nat(0)))

    await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.exec({ as: alice })

    const o_asset_after = await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.get_o_asset()
    // TODO: Bug
    // assert(o_asset_after.length == 3)
    // assert(o_asset_after[0].equals(new Nat(1)))
    // assert(o_asset_after[1].equals(new Nat(2)))
    // assert(o_asset_after[2].equals(new Nat(3)))
    const my_asset_after = await effect_method_asset_update_with_replace_partition.effect_method_asset_update_with_replace_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "my_id")
    assert(my_asset_after[0][1].value.equals(new Int(3)))
    assert(my_asset_after[0][1].my_partition.length == 3)
    assert(my_asset_after[0][1].my_partition[0].equals(new Nat(1)))
    assert(my_asset_after[0][1].my_partition[1].equals(new Nat(2)))
    assert(my_asset_after[0][1].my_partition[2].equals(new Nat(3)))
  })

  it('effect_method_asset_update_with_set', async () => {
    await effect_method_asset_update_with_set.effect_method_asset_update_with_set.deploy({ as: alice })

    const my_asset_before = await effect_method_asset_update_with_set.effect_method_asset_update_with_set.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0] == "a")

    await effect_method_asset_update_with_set.effect_method_asset_update_with_set.exec({ as: alice })

    const my_asset_after = await effect_method_asset_update_with_set.effect_method_asset_update_with_set.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0] == "k")
  })

  it('effect_transfer_contract', async () => {
    await effect_transfer_contract.effect_transfer_contract.deploy({ as: alice })

    const v_before = await effect_transfer_contract.effect_transfer_contract.get_v();
    assert(v_before.equals(new Int(0)))

    await effect_transfer_contract.effect_transfer_contract.exec(effect_transfer_contract.effect_transfer_contract.get_address(), { amount: new Tez(1), as: alice })

    const v_after = await effect_transfer_contract.effect_transfer_contract.get_v();
    assert(v_after.equals(new Int(1)))
  })

  it('effect_transfer_simple', async () => {
    await effect_transfer_simple.effect_transfer_simple.deploy({ as: alice })

    const balance_before = await alice.get_balance();

    await effect_transfer_simple.effect_transfer_simple.exec(alice.get_address(), { amount: new Tez(1), as: bob })

    const balance_after = await alice.get_balance();
    assert(balance_after.to_big_number().minus(balance_before.to_big_number()).eq(new Tez(1).to_big_number()))
  })

  it('entry_inspector', async () => {
    await entry_inspector.entry_inspector.deploy({ as: alice })
    await entry_token.entry_token.deploy({ as: alice })

    const nbtokens_before = await entry_token.entry_token.get_nbtokens()
    assert(nbtokens_before.equals(new Nat(0)))

    await entry_token.entry_token.setBalance(new Nat(2), { as: alice })

    const nbtokens_after = await entry_token.entry_token.get_nbtokens()
    assert(nbtokens_after.equals(new Nat(2)))


    const total_before = await entry_inspector.entry_inspector.get_total();
    assert(total_before.equals(new Nat(0)))

    await entry_inspector.entry_inspector.exec(entry_token.entry_token.get_address(), { as: alice })

    const total_after = await entry_inspector.entry_inspector.get_total();
    assert(total_after.equals(new Nat(2)))
  })

  it('entry_section_called_by_otherwise', async () => {
    await entry_section_called_by_otherwise.entry_section_called_by_otherwise.deploy({ as: alice })

    await expect_to_fail(async () => {
      await entry_section_called_by_otherwise.entry_section_called_by_otherwise.exec(bob.get_address(), { as: alice })
    }, { string: "NOT_OWNER" })

    await entry_section_called_by_otherwise.entry_section_called_by_otherwise.exec(alice.get_address(), { as: alice })
  })

  it('entry_section_no_transfer_otherwise', async () => {
    await entry_section_no_transfer_otherwise.entry_section_no_transfer_otherwise.deploy({ as: alice })

    await expect_to_fail(async () => {
      await entry_section_no_transfer_otherwise.entry_section_no_transfer_otherwise.exec({ amount: new Tez(1), as: alice })
    }, { string: "INVALID_VALUE" })

    await entry_section_no_transfer_otherwise.entry_section_no_transfer_otherwise.exec({ as: alice })
  })

  it('entry_section_sourced_by_otherwise', async () => {
    await entry_section_sourced_by_otherwise.entry_section_sourced_by_otherwise.deploy({ as: alice })

    await expect_to_fail(async () => {
      await entry_section_sourced_by_otherwise.entry_section_sourced_by_otherwise.exec(bob.get_address(), { as: alice })
    }, { string: "NOT_OWNER" })

    await entry_section_sourced_by_otherwise.entry_section_sourced_by_otherwise.exec(alice.get_address(), { as: alice })
  })

  it('entry_section_state_is_otherwise', async () => {
    await entry_section_state_is_otherwise.entry_section_state_is_otherwise.deploy({ as: alice })

    await entry_section_state_is_otherwise.entry_section_state_is_otherwise.exec({ as: alice })

    await entry_section_state_is_otherwise.entry_section_state_is_otherwise.tr({ as: alice })

    await expect_to_fail(async () => {
      await entry_section_state_is_otherwise.entry_section_state_is_otherwise.exec({ as: alice })
    }, { string: "INVALID_STATE" })
  })

  it('entry_token', async () => {
    await entry_inspector.entry_inspector.deploy({ as: alice })
    await entry_token.entry_token.deploy({ as: alice })

    const nbtokens_before = await entry_token.entry_token.get_nbtokens()
    assert(nbtokens_before.equals(new Nat(0)))

    await entry_token.entry_token.setBalance(new Nat(8), { as: alice })

    const nbtokens_after = await entry_token.entry_token.get_nbtokens()
    assert(nbtokens_after.equals(new Nat(8)))


    const total_before = await entry_inspector.entry_inspector.get_total();
    assert(total_before.equals(new Nat(0)))

    await entry_inspector.entry_inspector.exec(entry_token.entry_token.get_address(), { as: alice })

    const total_after = await entry_inspector.entry_inspector.get_total();
    assert(total_after.equals(new Nat(8)))
  })

  it('entry_without_effect', async () => {
    await entry_without_effect.entry_without_effect.deploy({ as: alice })

    await entry_without_effect.entry_without_effect.exec({ as: alice })
  })

  it('enum_all', async () => {
    await enum_all.enum_all.deploy({ as: alice })

    const r_before = await enum_all.enum_all.get_r()
    assert(r_before.equals(new enum_all.A("mystr")))
    const res_before = await enum_all.enum_all.get_res()
    assert(res_before.equals(new Nat(0)))

    await enum_all.enum_all.exec({ as: alice })

    const r_after = await enum_all.enum_all.get_r()
    assert(r_after.equals(new enum_all.E(new Int(2))))
    const res_after = await enum_all.enum_all.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('enum_key', async () => {
    await enum_key.enum_key.deploy({ as: alice })

    const tvls_before = await enum_key.enum_key.get_tvls()
    assert(tvls_before.length == 4)
    assert(tvls_before[0][0].equals(new enum_key.Tier1()))
    assert(tvls_before[0][1].equals(new Nat(0)))
    assert(tvls_before[1][0].equals(new enum_key.Tier2()))
    assert(tvls_before[1][1].equals(new Nat(0)))
    assert(tvls_before[2][0].equals(new enum_key.Tier3()))
    assert(tvls_before[2][1].equals(new Nat(0)))
    assert(tvls_before[3][0].equals(new enum_key.Tier4()))
    assert(tvls_before[3][1].equals(new Nat(0)))

    await enum_key.enum_key.update(new enum_key.Tier1(), { as: alice })

    const tvls_after = await enum_key.enum_key.get_tvls()
    assert(tvls_after.length == 4)
    assert(tvls_after[0][0].equals(new enum_key.Tier1()))
    assert(tvls_after[0][1].equals(new Nat(0)))
    assert(tvls_after[1][0].equals(new enum_key.Tier2()))
    assert(tvls_after[1][1].equals(new Nat(0)))
    assert(tvls_after[2][0].equals(new enum_key.Tier3()))
    assert(tvls_after[2][1].equals(new Nat(0)))
    assert(tvls_after[3][0].equals(new enum_key.Tier4()))
    assert(tvls_after[3][1].equals(new Nat(0)))
  })

  it('enum_simple', async () => {
    await enum_simple.enum_simple.deploy({ as: alice })

    const res_before = await enum_simple.enum_simple.get_res()
    assert(res_before.equals(new enum_simple.A()))

    await enum_simple.enum_simple.exec({ as: alice })

    const res_after = await enum_simple.enum_simple.get_res()
    assert(res_after.equals(new enum_simple.B()))
  })

  it('enum_with_args', async () => {
    await enum_with_args.enum_with_args.deploy({ as: alice })

    const res_before = await enum_with_args.enum_with_args.get_res()
    assert(res_before.equals(new Nat(0)))

    await enum_with_args.enum_with_args.exec({ as: alice })

    const res_after = await enum_with_args.enum_with_args.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('enum_with_args_multi', async () => {
    await enum_with_args_multi.enum_with_args_multi.deploy({ as: alice })

    const res_before = await enum_with_args_multi.enum_with_args_multi.get_res()
    assert(res_before.equals(new Nat(0)))

    await enum_with_args_multi.enum_with_args_multi.exec({ as: alice })

    const res_after = await enum_with_args_multi.enum_with_args_multi.get_res()
    assert(res_after.equals(new Nat(5)))
  })

  it('enum_without_args', async () => {
    await enum_without_args.enum_without_args.deploy({ as: alice })

    const res_before = await enum_without_args.enum_without_args.get_res()
    assert(res_before.equals(new Nat(0)))
    const r_before = await enum_without_args.enum_without_args.get_r()
    assert(r_before.equals(new enum_without_args.C()))

    await enum_without_args.enum_without_args.exec({ as: alice })

    const res_after = await enum_without_args.enum_without_args.get_res()
    assert(res_after.equals(new Nat(1)))
    const r_after = await enum_without_args.enum_without_args.get_r()
    assert(r_after.equals(new enum_without_args.C()))
  })

  it('event_all', async () => {
    await event_all.event_all.deploy({ as: alice })

    const ret = await event_all.event_all.exec({ as: alice })

    assert(ret.events.length == 1)
    assert(ret.events[0].from.equals(event_all.event_all.get_address()))
    assert(JSON.stringify(ret.events[0].type) == '{"prim":"pair","args":[{"prim":"unit","annots":["%u"]},{"prim":"bool","annots":["%b"]},{"prim":"int","annots":["%i"]},{"prim":"nat","annots":["%n"]},{"prim":"pair","annots":["%r"],"args":[{"prim":"int"},{"prim":"nat"}]},{"prim":"timestamp","annots":["%date_"]},{"prim":"int","annots":["%du"]},{"prim":"string","annots":["%str"]},{"prim":"address","annots":["%addr"]},{"prim":"mutez","annots":["%cur"]},{"prim":"signature","annots":["%sig"]},{"prim":"key","annots":["%k"]},{"prim":"key_hash","annots":["%kh"]},{"prim":"bytes","annots":["%byt"]},{"prim":"chain_id","annots":["%cid"]},{"prim":"set","annots":["%s"],"args":[{"prim":"nat"}]},{"prim":"list","annots":["%l"],"args":[{"prim":"nat"}]},{"prim":"map","annots":["%m"],"args":[{"prim":"nat"},{"prim":"string"}]},{"prim":"option","annots":["%o"],"args":[{"prim":"nat"}]},{"prim":"pair","annots":["%tu"],"args":[{"prim":"nat"},{"prim":"string"}]},{"prim":"or","annots":["%oal"],"args":[{"prim":"nat"},{"prim":"string"}]},{"prim":"or","annots":["%oar"],"args":[{"prim":"nat"},{"prim":"string"}]},{"prim":"pair","annots":["%rr"],"args":[{"prim":"nat","annots":["%f1"]},{"prim":"string","annots":["%f2"]}]},{"prim":"int","annots":["%ee"]},{"prim":"or","annots":["%eee"],"args":[{"prim":"nat","annots":["%xxx"]},{"prim":"string","annots":["%yyy"]}]}]}')
    assert(ret.events[0].tag == "ev")
    assert(JSON.stringify(ret.events[0].payload) == '[{"prim":"Unit"},{"prim":"True"},{"int":"1"},{"int":"2"},{"prim":"Pair","args":[{"int":"4"},{"int":"5"}]},{"int":"1577836800"},{"int":"1"},{"string":"string"},{"bytes":"00000a9768ec413f25958a5a85269a11290493be68d2"},{"int":"1000000"},{"bytes":"b0df895c5a322559c3a3425f29f84999f4037894131b4c72a775e39e630bcc4f0d41756d73f3f10ae91b9c866d54d237c4e4fa12e962a2c958c8953f8b1a3f0b"},{"bytes":"009f38548550132bc0428883d9b6fc89971280f8e4edd81ff190eaafe3b8fe8f0f"},{"bytes":"000a9768ec413f25958a5a85269a11290493be68d2"},{"bytes":"01"},{"bytes":"7a06a770"},[{"int":"1"}],[{"int":"2"}],[{"prim":"Elt","args":[{"int":"3"},{"string":"mystr"}]}],{"prim":"None"},{"prim":"Pair","args":[{"int":"4"},{"string":"mystring"}]},{"prim":"Left","args":[{"int":"5"}]},{"prim":"Right","args":[{"string":"m0"}]},{"prim":"Pair","args":[{"int":"6"},{"string":"m1"}]},{"int":"0"},{"prim":"Left","args":[{"int":"1"}]}]')
  })

  it('event_dup', async () => {
    await event_dup.event_dup.deploy({ as: alice })
    const now = new Date("2020-01-01");

    set_mockup_now(now)

    const ret_even = await event_dup.event_dup.e1(new Nat(2), { as: alice })
    assert(ret_even.events.length == 1)
    assert(ret_even.events[0].from.equals(event_dup.event_dup.get_address()))
    assert(JSON.stringify(ret_even.events[0].type) == '{"prim":"pair","args":[{"prim":"address","annots":["%from_"]},{"prim":"timestamp","annots":["%time"]}]}')
    assert(ret_even.events[0].tag == "even")
    assert(JSON.stringify(ret_even.events[0].payload) == '{"prim":"Pair","args":[{"bytes":"00006b82198cb179e8306c1bedd08f12dc863f328886"},{"int":"1577836800"}]}')

    const ret_odd = await event_dup.event_dup.e1(new Nat(3), { as: alice })
    assert(ret_odd.events.length == 1)
    assert(ret_odd.events[0].from.equals(event_dup.event_dup.get_address()))
    assert(JSON.stringify(ret_odd.events[0].type) == '{"prim":"pair","args":[{"prim":"address","annots":["%from_"]},{"prim":"timestamp","annots":["%time"]}]}')
    assert(ret_odd.events[0].tag == "odd")
    assert(JSON.stringify(ret_odd.events[0].payload) == '{"prim":"Pair","args":[{"bytes":"00006b82198cb179e8306c1bedd08f12dc863f328886"},{"int":"1577836800"}]}')
  })

  it('event_multi', async () => {
    await event_multi.event_multi.deploy({ as: alice })

    const ret = await event_multi.event_multi.exec({ as: alice })
    assert(ret.events.length == 5)
    assert(ret.events[0].from.equals(event_multi.event_multi.get_address()))
    assert(JSON.stringify(ret.events[0].type) == '{"prim":"nat"}')
    assert(ret.events[0].tag == "ev")
    assert(JSON.stringify(ret.events[0].payload) == '{"int":"1"}')
    assert(ret.events[1].from.equals(event_multi.event_multi.get_address()))
    assert(JSON.stringify(ret.events[1].type) == '{"prim":"nat"}')
    assert(ret.events[1].tag == "ev")
    assert(JSON.stringify(ret.events[1].payload) == '{"int":"2"}')
    assert(ret.events[2].from.equals(event_multi.event_multi.get_address()))
    assert(JSON.stringify(ret.events[2].type) == '{"prim":"nat"}')
    assert(ret.events[2].tag == "ev")
    assert(JSON.stringify(ret.events[2].payload) == '{"int":"3"}')
    assert(ret.events[3].from.equals(event_multi.event_multi.get_address()))
    assert(JSON.stringify(ret.events[3].type) == '{"prim":"nat"}')
    assert(ret.events[3].tag == "ev")
    assert(JSON.stringify(ret.events[3].payload) == '{"int":"4"}')
    assert(ret.events[4].from.equals(event_multi.event_multi.get_address()))
    assert(JSON.stringify(ret.events[4].type) == '{"prim":"nat"}')
    assert(ret.events[4].tag == "ev")
    assert(JSON.stringify(ret.events[4].payload) == '{"int":"5"}')
  })

  it('event_simple', async () => {
    await event_simple.event_simple.deploy({ as: alice })
    const now = new Date("2020-01-01");

    set_mockup_now(now)
    const ret = await event_simple.event_simple.exec({ as: alice })

    assert(ret.events.length == 1)
    assert(ret.events[0].from.equals(event_simple.event_simple.get_address()))
    assert(JSON.stringify(ret.events[0].type) == '{"prim":"pair","args":[{"prim":"address","annots":["%from_"]},{"prim":"timestamp","annots":["%time"]}]}')
    assert(ret.events[0].tag == "even")
    assert(JSON.stringify(ret.events[0].payload) == '{"prim":"Pair","args":[{"bytes":"00006b82198cb179e8306c1bedd08f12dc863f328886"},{"int":"1577836800"}]}')
  })

  it('event_single', async () => {
    await event_single.event_single.deploy({ as: alice })

    const ret = await event_single.event_single.e1(new Nat(2), { as: alice })

    assert(ret.events.length == 1)
    assert(ret.events[0].from.equals(event_single.event_single.get_address()))
    assert(JSON.stringify(ret.events[0].type) == '{"prim":"nat"}')
    assert(ret.events[0].tag == "ev")
    assert(JSON.stringify(ret.events[0].payload) == '{"int":"2"}')
  })

  it('exec_letin', async () => {
    await exec_letin.exec_letin.deploy({ as: alice })

    const res_before = await exec_letin.exec_letin.get_res();
    assert(res_before == false)

    await exec_letin.exec_letin.exec({ as: alice })

    const res_after = await exec_letin.exec_letin.get_res();
    assert(res_after == true)
  })

  it('expr_access_asset_field', async () => {
    await expr_access_asset_field.expr_access_asset_field.deploy({ as: alice })

    const my_asset_before = await expr_access_asset_field.expr_access_asset_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_before = await expr_access_asset_field.expr_access_asset_field.get_res();
    assert(res_before.equals(new Int(0)))

    await expr_access_asset_field.expr_access_asset_field.exec({ as: alice })

    const my_asset_after = await expr_access_asset_field.expr_access_asset_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_after = await expr_access_asset_field.expr_access_asset_field.get_res();
    assert(res_after.equals(new Int(2)))
  })

  it('expr_arith_3wc_nat_nat', async () => {
    await expr_arith_3wc_nat_nat.expr_arith_3wc_nat_nat.deploy({ as: alice })

    const v0_before = await expr_arith_3wc_nat_nat.expr_arith_3wc_nat_nat.get_v0()
    assert(v0_before.equals(new Int(0)))
    const v1_before = await expr_arith_3wc_nat_nat.expr_arith_3wc_nat_nat.get_v1()
    assert(v1_before.equals(new Int(0)))
    const v2_before = await expr_arith_3wc_nat_nat.expr_arith_3wc_nat_nat.get_v2()
    assert(v2_before.equals(new Int(0)))

    await expr_arith_3wc_nat_nat.expr_arith_3wc_nat_nat.exec({ as: alice })

    const v0_after = await expr_arith_3wc_nat_nat.expr_arith_3wc_nat_nat.get_v0()
    assert(v0_after.equals(new Int(0)))
    const v1_after = await expr_arith_3wc_nat_nat.expr_arith_3wc_nat_nat.get_v1()
    assert(v1_after.equals(new Int(-1)))
    const v2_after = await expr_arith_3wc_nat_nat.expr_arith_3wc_nat_nat.get_v2()
    assert(v2_after.equals(new Int(1)))
  })

  it('expr_arith_and_bool_bool', async () => {
    await expr_arith_and_bool_bool.expr_arith_and_bool_bool.deploy({ as: alice })

    const res_before = await expr_arith_and_bool_bool.expr_arith_and_bool_bool.get_res()
    assert(res_before == false)

    await expr_arith_and_bool_bool.expr_arith_and_bool_bool.exec({ as: alice })

    const res_after = await expr_arith_and_bool_bool.expr_arith_and_bool_bool.get_res()
    assert(res_after == true)
  })

  it('expr_arith_and_bytes_bytes', async () => {
    await expr_arith_and_bytes_bytes.expr_arith_and_bytes_bytes.deploy({ as: alice })

    const res_before = await expr_arith_and_bytes_bytes.expr_arith_and_bytes_bytes.get_res()
    assert(res_before.equals(new Bytes("")))

    await expr_arith_and_bytes_bytes.expr_arith_and_bytes_bytes.exec({ as: alice })

    const res_after = await expr_arith_and_bytes_bytes.expr_arith_and_bytes_bytes.get_res()
    assert(res_after.equals(new Bytes("01")))

  })

  it('expr_arith_and_int_nat', async () => {
    await expr_arith_and_int_nat.expr_arith_and_int_nat.deploy({ as: alice })

    const res_before = await expr_arith_and_int_nat.expr_arith_and_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_and_int_nat.expr_arith_and_int_nat.exec({ as: alice })

    const res_after = await expr_arith_and_int_nat.expr_arith_and_int_nat.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_arith_and_nat_nat', async () => {
    await expr_arith_and_nat_nat.expr_arith_and_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_and_nat_nat.expr_arith_and_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_and_nat_nat.expr_arith_and_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_and_nat_nat.expr_arith_and_nat_nat.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_arith_div_dur_dur', async () => {
    await expr_arith_div_dur_dur.expr_arith_div_dur_dur.deploy({ as: alice })

    const res_before = await expr_arith_div_dur_dur.expr_arith_div_dur_dur.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_dur_dur.expr_arith_div_dur_dur.exec({ as: alice })

    const res_after = await expr_arith_div_dur_dur.expr_arith_div_dur_dur.get_res()
    assert(res_after.equals(new Rational(2)))
  })

  it('expr_arith_div_int_int', async () => {
    await expr_arith_div_int_int.expr_arith_div_int_int.deploy({ as: alice })

    const res_before = await expr_arith_div_int_int.expr_arith_div_int_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_int_int.expr_arith_div_int_int.exec({ as: alice })

    const res_after = await expr_arith_div_int_int.expr_arith_div_int_int.get_res()
    assert(res_after.equals(new Rational(2)))
  })

  it('expr_arith_div_int_nat', async () => {
    await expr_arith_div_int_nat.expr_arith_div_int_nat.deploy({ as: alice })

    const res_before = await expr_arith_div_int_nat.expr_arith_div_int_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_int_nat.expr_arith_div_int_nat.exec({ as: alice })

    const res_after = await expr_arith_div_int_nat.expr_arith_div_int_nat.get_res()
    assert(res_after.equals(new Rational(2)))
  })

  it('expr_arith_div_int_rat', async () => {
    await expr_arith_div_int_rat.expr_arith_div_int_rat.deploy({ as: alice })

    const res_before = await expr_arith_div_int_rat.expr_arith_div_int_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_int_rat.expr_arith_div_int_rat.exec({ as: alice })

    const res_after = await expr_arith_div_int_rat.expr_arith_div_int_rat.get_res()
    assert(res_after.equals(new Rational(6)))
  })

  it('expr_arith_div_nat_int', async () => {
    await expr_arith_div_nat_int.expr_arith_div_nat_int.deploy({ as: alice })

    const res_before = await expr_arith_div_nat_int.expr_arith_div_nat_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_nat_int.expr_arith_div_nat_int.exec({ as: alice })

    const res_after = await expr_arith_div_nat_int.expr_arith_div_nat_int.get_res()
    assert(res_after.equals(new Rational(2)))
  })

  it('expr_arith_div_nat_nat', async () => {
    await expr_arith_div_nat_nat.expr_arith_div_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_div_nat_nat.expr_arith_div_nat_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_nat_nat.expr_arith_div_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_div_nat_nat.expr_arith_div_nat_nat.get_res()
    assert(res_after.equals(new Rational(2)))
  })

  it('expr_arith_div_nat_rat', async () => {
    await expr_arith_div_nat_rat.expr_arith_div_nat_rat.deploy({ as: alice })

    const res_before = await expr_arith_div_nat_rat.expr_arith_div_nat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_nat_rat.expr_arith_div_nat_rat.exec({ as: alice })

    const res_after = await expr_arith_div_nat_rat.expr_arith_div_nat_rat.get_res()
    assert(res_after.equals(new Rational(6)))
  })

  it('expr_arith_div_rat_int', async () => {
    await expr_arith_div_rat_int.expr_arith_div_rat_int.deploy({ as: alice })

    const res_before = await expr_arith_div_rat_int.expr_arith_div_rat_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_rat_int.expr_arith_div_rat_int.exec({ as: alice })

    const res_after = await expr_arith_div_rat_int.expr_arith_div_rat_int.get_res()
    assert(res_after.equals(new Rational(0.1)))
  })

  it('expr_arith_div_rat_nat', async () => {
    await expr_arith_div_rat_nat.expr_arith_div_rat_nat.deploy({ as: alice })

    const res_before = await expr_arith_div_rat_nat.expr_arith_div_rat_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_rat_nat.expr_arith_div_rat_nat.exec({ as: alice })

    const res_after = await expr_arith_div_rat_nat.expr_arith_div_rat_nat.get_res()
    assert(res_after.equals(new Rational(0.1)))
  })

  it('expr_arith_div_rat_rat', async () => {
    await expr_arith_div_rat_rat.expr_arith_div_rat_rat.deploy({ as: alice })

    const res_before = await expr_arith_div_rat_rat.expr_arith_div_rat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_rat_rat.expr_arith_div_rat_rat.exec({ as: alice })

    const res_after = await expr_arith_div_rat_rat.expr_arith_div_rat_rat.get_res()
    assert(res_after.equals(new Rational(2)))
  })

  it('expr_arith_div_tez_tez', async () => {
    await expr_arith_div_tez_tez.expr_arith_div_tez_tez.deploy({ as: alice })

    const res_before = await expr_arith_div_tez_tez.expr_arith_div_tez_tez.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_div_tez_tez.expr_arith_div_tez_tez.exec({ as: alice })

    const res_after = await expr_arith_div_tez_tez.expr_arith_div_tez_tez.get_res()
    assert(res_after.equals(new Rational(4, new BigNumber(3))))
  })

  it('expr_arith_divmod_int_int', async () => {
    await expr_arith_divmod_int_int.expr_arith_divmod_int_int.deploy({ as: alice })

    const res_before = await expr_arith_divmod_int_int.expr_arith_divmod_int_int.get_res()
    assert(res_before.equals(Option.None()))

    await expr_arith_divmod_int_int.expr_arith_divmod_int_int.exec({ as: alice })

    const res_after = await expr_arith_divmod_int_int.expr_arith_divmod_int_int.get_res()
    assert(res_after.equals(Option.Some([new Int(4), new Nat(1)])))
  })

  it('expr_arith_divmod_int_nat', async () => {
    await expr_arith_divmod_int_nat.expr_arith_divmod_int_nat.deploy({ as: alice })

    const res_before = await expr_arith_divmod_int_nat.expr_arith_divmod_int_nat.get_res()
    assert(res_before.equals(Option.None()))

    await expr_arith_divmod_int_nat.expr_arith_divmod_int_nat.exec({ as: alice })

    const res_after = await expr_arith_divmod_int_nat.expr_arith_divmod_int_nat.get_res()
    assert(res_after.equals(Option.Some([new Int(4), new Nat(1)])))
  })

  it('expr_arith_divmod_nat_int', async () => {
    await expr_arith_divmod_nat_int.expr_arith_divmod_nat_int.deploy({ as: alice })

    const res_before = await expr_arith_divmod_nat_int.expr_arith_divmod_nat_int.get_res()
    assert(res_before.equals(Option.None()))

    await expr_arith_divmod_nat_int.expr_arith_divmod_nat_int.exec({ as: alice })

    const res_after = await expr_arith_divmod_nat_int.expr_arith_divmod_nat_int.get_res()
    assert(res_after.equals(Option.Some([new Int(4), new Nat(1)])))
  })

  it('expr_arith_divmod_nat_nat', async () => {
    await expr_arith_divmod_nat_nat.expr_arith_divmod_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_divmod_nat_nat.expr_arith_divmod_nat_nat.get_res()
    assert(res_before.equals(Option.None()))

    await expr_arith_divmod_nat_nat.expr_arith_divmod_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_divmod_nat_nat.expr_arith_divmod_nat_nat.get_res()
    assert(res_after.equals(Option.Some([new Nat(4), new Nat(1)])))
  })

  it('expr_arith_divmod_tez_nat', async () => {
    await expr_arith_divmod_tez_nat.expr_arith_divmod_tez_nat.deploy({ as: alice })

    const res_before = await expr_arith_divmod_tez_nat.expr_arith_divmod_tez_nat.get_res()
    assert(res_before.equals(Option.None()))

    await expr_arith_divmod_tez_nat.expr_arith_divmod_tez_nat.exec({ as: alice })

    const res_after = await expr_arith_divmod_tez_nat.expr_arith_divmod_tez_nat.get_res()
    assert(res_after.equals(Option.Some([new Tez(4.5), new Tez(0)])))
  })

  it('expr_arith_divmod_tez_tez', async () => {
    await expr_arith_divmod_tez_tez.expr_arith_divmod_tez_tez.deploy({ as: alice })

    const res_before = await expr_arith_divmod_tez_tez.expr_arith_divmod_tez_tez.get_res()
    assert(res_before.equals(Option.None()))

    await expr_arith_divmod_tez_tez.expr_arith_divmod_tez_tez.exec({ as: alice })

    const res_after = await expr_arith_divmod_tez_tez.expr_arith_divmod_tez_tez.get_res()
    assert(res_after.equals(Option.Some([new Nat(4), new Tez(1)])))
  })

  it('expr_arith_ediv_dur_dur', async () => {
    await expr_arith_ediv_dur_dur.expr_arith_ediv_dur_dur.deploy({ as: alice })

    const res_before = await expr_arith_ediv_dur_dur.expr_arith_ediv_dur_dur.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_ediv_dur_dur.expr_arith_ediv_dur_dur.exec({ as: alice })

    const res_after = await expr_arith_ediv_dur_dur.expr_arith_ediv_dur_dur.get_res()
    assert(res_after.equals(new Int(8)))
  })

  it('expr_arith_ediv_dur_int', async () => {
    await expr_arith_ediv_dur_int.expr_arith_ediv_dur_int.deploy({ as: alice })

    const res_before = await expr_arith_ediv_dur_int.expr_arith_ediv_dur_int.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_ediv_dur_int.expr_arith_ediv_dur_int.exec({ as: alice })

    const res_after = await expr_arith_ediv_dur_int.expr_arith_ediv_dur_int.get_res()
    assert(res_after.equals(new Duration("1h")))
  })

  it('expr_arith_ediv_dur_nat', async () => {
    await expr_arith_ediv_dur_nat.expr_arith_ediv_dur_nat.deploy({ as: alice })

    const res_before = await expr_arith_ediv_dur_nat.expr_arith_ediv_dur_nat.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_ediv_dur_nat.expr_arith_ediv_dur_nat.exec({ as: alice })

    const res_after = await expr_arith_ediv_dur_nat.expr_arith_ediv_dur_nat.get_res()
    assert(res_after.equals(new Duration("1h")))
  })

  it('expr_arith_ediv_int_int', async () => {
    await expr_arith_ediv_int_int.expr_arith_ediv_int_int.deploy({ as: alice })

    const res_before = await expr_arith_ediv_int_int.expr_arith_ediv_int_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_ediv_int_int.expr_arith_ediv_int_int.exec({ as: alice })

    const res_after = await expr_arith_ediv_int_int.expr_arith_ediv_int_int.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_arith_ediv_int_nat', async () => {
    await expr_arith_ediv_int_nat.expr_arith_ediv_int_nat.deploy({ as: alice })

    const res_before = await expr_arith_ediv_int_nat.expr_arith_ediv_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_ediv_int_nat.expr_arith_ediv_int_nat.exec({ as: alice })

    const res_after = await expr_arith_ediv_int_nat.expr_arith_ediv_int_nat.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_arith_ediv_nat_int', async () => {
    await expr_arith_ediv_nat_int.expr_arith_ediv_nat_int.deploy({ as: alice })

    const res_before = await expr_arith_ediv_nat_int.expr_arith_ediv_nat_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_ediv_nat_int.expr_arith_ediv_nat_int.exec({ as: alice })

    const res_after = await expr_arith_ediv_nat_int.expr_arith_ediv_nat_int.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_arith_ediv_nat_nat', async () => {
    await expr_arith_ediv_nat_nat.expr_arith_ediv_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_ediv_nat_nat.expr_arith_ediv_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_ediv_nat_nat.expr_arith_ediv_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_ediv_nat_nat.expr_arith_ediv_nat_nat.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('expr_arith_ediv_tez_nat', async () => {
    await expr_arith_ediv_tez_nat.expr_arith_ediv_tez_nat.deploy({ as: alice })

    const res_before = await expr_arith_ediv_tez_nat.expr_arith_ediv_tez_nat.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_arith_ediv_tez_nat.expr_arith_ediv_tez_nat.exec({ as: alice })

    const res_after = await expr_arith_ediv_tez_nat.expr_arith_ediv_tez_nat.get_res()
    assert(res_after.equals(new Tez(1000, "mutez")))
  })

  it('expr_arith_ediv_tez_tez', async () => {
    await expr_arith_ediv_tez_tez.expr_arith_ediv_tez_tez.deploy({ as: alice })

    const res_before = await expr_arith_ediv_tez_tez.expr_arith_ediv_tez_tez.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_ediv_tez_tez.expr_arith_ediv_tez_tez.exec({ as: alice })

    const res_after = await expr_arith_ediv_tez_tez.expr_arith_ediv_tez_tez.get_res()
    assert(res_after.equals(new Int(1000000)))
  })

  it('expr_arith_lsl_bytes_nat', async () => {
    await expr_arith_lsl_bytes_nat.expr_arith_lsl_bytes_nat.deploy({ as: alice })

    const res_before = await expr_arith_lsl_bytes_nat.expr_arith_lsl_bytes_nat.get_res()
    assert(res_before.equals(new Bytes("")))

    await expr_arith_lsl_bytes_nat.expr_arith_lsl_bytes_nat.exec({ as: alice })

    const res_after = await expr_arith_lsl_bytes_nat.expr_arith_lsl_bytes_nat.get_res()
    assert(res_after.equals(new Bytes("0008")))
  })

  it('expr_arith_lsl_nat_nat', async () => {
    await expr_arith_lsl_nat_nat.expr_arith_lsl_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_lsl_nat_nat.expr_arith_lsl_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_lsl_nat_nat.expr_arith_lsl_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_lsl_nat_nat.expr_arith_lsl_nat_nat.get_res()
    assert(res_after.equals(new Nat(8)))
  })

  it('expr_arith_lsr_bytes_nat', async () => {
    await expr_arith_lsr_bytes_nat.expr_arith_lsr_bytes_nat.deploy({ as: alice })

    const res_before = await expr_arith_lsr_bytes_nat.expr_arith_lsr_bytes_nat.get_res()
    assert(res_before.equals(new Bytes("")))

    await expr_arith_lsr_bytes_nat.expr_arith_lsr_bytes_nat.exec({ as: alice })

    const res_after = await expr_arith_lsr_bytes_nat.expr_arith_lsr_bytes_nat.get_res()
    assert(res_after.equals(new Bytes("02")))
  })

  it('expr_arith_lsr_nat_nat', async () => {
    await expr_arith_lsr_nat_nat.expr_arith_lsr_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_lsr_nat_nat.expr_arith_lsr_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_lsr_nat_nat.expr_arith_lsr_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_lsr_nat_nat.expr_arith_lsr_nat_nat.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('expr_arith_minus_date_date', async () => {
    await expr_arith_minus_date_date.expr_arith_minus_date_date.deploy({ as: alice })

    const res_before = await expr_arith_minus_date_date.expr_arith_minus_date_date.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_minus_date_date.expr_arith_minus_date_date.exec({ as: alice })

    const res_after = await expr_arith_minus_date_date.expr_arith_minus_date_date.get_res()
    assert(res_after.equals(new Duration("365d")))
  })

  it('expr_arith_minus_date_date_neg', async () => {
    await expr_arith_minus_date_date_neg.expr_arith_minus_date_date_neg.deploy({ as: alice })

    const res_before = await expr_arith_minus_date_date_neg.expr_arith_minus_date_date_neg.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_minus_date_date_neg.expr_arith_minus_date_date_neg.exec({ as: alice })

    // const res_after = await expr_arith_minus_date_date_neg.expr_arith_minus_date_date_neg.get_res()
    // assert(res_after.equals(new Duration("-31536000")))
  })

  it('expr_arith_minus_date_dur', async () => {
    await expr_arith_minus_date_dur.expr_arith_minus_date_dur.deploy({ as: alice })

    const res_before = await expr_arith_minus_date_dur.expr_arith_minus_date_dur.get_res()
    assert(res_before.toISOString() == "2020-01-01T00:00:00.000Z")

    await expr_arith_minus_date_dur.expr_arith_minus_date_dur.exec({ as: alice })

    const res_after = await expr_arith_minus_date_dur.expr_arith_minus_date_dur.get_res()
    assert(res_after.toISOString() == "2019-12-31T18:30:00.000Z")
  })

  it('expr_arith_minus_dur_dur', async () => {
    await expr_arith_minus_dur_dur.expr_arith_minus_dur_dur.deploy({ as: alice })

    const res_before = await expr_arith_minus_dur_dur.expr_arith_minus_dur_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_minus_dur_dur.expr_arith_minus_dur_dur.exec({ as: alice })

    const res_after = await expr_arith_minus_dur_dur.expr_arith_minus_dur_dur.get_res()
    assert(res_after.equals(new Duration("20h")))
  })

  it('expr_arith_minus_int_int', async () => {
    await expr_arith_minus_int_int.expr_arith_minus_int_int.deploy({ as: alice })

    const res_before = await expr_arith_minus_int_int.expr_arith_minus_int_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_minus_int_int.expr_arith_minus_int_int.exec({ as: alice })

    const res_after = await expr_arith_minus_int_int.expr_arith_minus_int_int.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_arith_minus_int_nat', async () => {
    await expr_arith_minus_int_nat.expr_arith_minus_int_nat.deploy({ as: alice })

    const res_before = await expr_arith_minus_int_nat.expr_arith_minus_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_minus_int_nat.expr_arith_minus_int_nat.exec({ as: alice })

    const res_after = await expr_arith_minus_int_nat.expr_arith_minus_int_nat.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_arith_minus_int_rat', async () => {
    await expr_arith_minus_int_rat.expr_arith_minus_int_rat.deploy({ as: alice })

    const res_before = await expr_arith_minus_int_rat.expr_arith_minus_int_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_minus_int_rat.expr_arith_minus_int_rat.exec({ as: alice })

    const res_after = await expr_arith_minus_int_rat.expr_arith_minus_int_rat.get_res()
    assert(res_after.equals(new Rational(2.5)))
  })

  it('expr_arith_minus_nat_int', async () => {
    await expr_arith_minus_nat_int.expr_arith_minus_nat_int.deploy({ as: alice })

    const res_before = await expr_arith_minus_nat_int.expr_arith_minus_nat_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_minus_nat_int.expr_arith_minus_nat_int.exec({ as: alice })

    const res_after = await expr_arith_minus_nat_int.expr_arith_minus_nat_int.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_arith_minus_nat_nat', async () => {
    await expr_arith_minus_nat_nat.expr_arith_minus_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_minus_nat_nat.expr_arith_minus_nat_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_minus_nat_nat.expr_arith_minus_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_minus_nat_nat.expr_arith_minus_nat_nat.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_arith_minus_nat_rat', async () => {
    await expr_arith_minus_nat_rat.expr_arith_minus_nat_rat.deploy({ as: alice })

    const res_before = await expr_arith_minus_nat_rat.expr_arith_minus_nat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_minus_nat_rat.expr_arith_minus_nat_rat.exec({ as: alice })

    const res_after = await expr_arith_minus_nat_rat.expr_arith_minus_nat_rat.get_res()
    assert(res_after.equals(new Rational(2.5)))
  })

  it('expr_arith_minus_rat_int', async () => {
    await expr_arith_minus_rat_int.expr_arith_minus_rat_int.deploy({ as: alice })

    const res_before = await expr_arith_minus_rat_int.expr_arith_minus_rat_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_minus_rat_int.expr_arith_minus_rat_int.exec({ as: alice })

    const res_after = await expr_arith_minus_rat_int.expr_arith_minus_rat_int.get_res()
    assert(res_after.equals(new Rational(-2.5)))
  })

  it('expr_arith_minus_rat_nat', async () => {
    await expr_arith_minus_rat_nat.expr_arith_minus_rat_nat.deploy({ as: alice })

    const res_before = await expr_arith_minus_rat_nat.expr_arith_minus_rat_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_minus_rat_nat.expr_arith_minus_rat_nat.exec({ as: alice })

    const res_after = await expr_arith_minus_rat_nat.expr_arith_minus_rat_nat.get_res()
    assert(res_after.equals(new Rational(-2.5)))
  })

  it('expr_arith_minus_rat_rat', async () => {
    await expr_arith_minus_rat_rat.expr_arith_minus_rat_rat.deploy({ as: alice })

    const res_before = await expr_arith_minus_rat_rat.expr_arith_minus_rat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_minus_rat_rat.expr_arith_minus_rat_rat.exec({ as: alice })

    const res_after = await expr_arith_minus_rat_rat.expr_arith_minus_rat_rat.get_res()
    assert(res_after.equals(new Rational(0.3)))
  })

  it('expr_arith_minus_tez_tez', async () => {
    await expr_arith_minus_tez_tez.expr_arith_minus_tez_tez.deploy({ as: alice })

    const res_before = await expr_arith_minus_tez_tez.expr_arith_minus_tez_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_arith_minus_tez_tez.expr_arith_minus_tez_tez.exec({ as: alice })

    const res_after = await expr_arith_minus_tez_tez.expr_arith_minus_tez_tez.get_res()
    assert(res_after.equals(new Tez(1)))
  })

  it('expr_arith_mod_int_int', async () => {
    await expr_arith_mod_int_int.expr_arith_mod_int_int.deploy({ as: alice })

    const res_before = await expr_arith_mod_int_int.expr_arith_mod_int_int.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_mod_int_int.expr_arith_mod_int_int.exec({ as: alice })

    const res_after = await expr_arith_mod_int_int.expr_arith_mod_int_int.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_arith_mod_int_nat', async () => {
    await expr_arith_mod_int_nat.expr_arith_mod_int_nat.deploy({ as: alice })

    const res_before = await expr_arith_mod_int_nat.expr_arith_mod_int_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_mod_int_nat.expr_arith_mod_int_nat.exec({ as: alice })

    const res_after = await expr_arith_mod_int_nat.expr_arith_mod_int_nat.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_arith_mod_nat_int', async () => {
    await expr_arith_mod_nat_int.expr_arith_mod_nat_int.deploy({ as: alice })

    const res_before = await expr_arith_mod_nat_int.expr_arith_mod_nat_int.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_mod_nat_int.expr_arith_mod_nat_int.exec({ as: alice })

    const res_after = await expr_arith_mod_nat_int.expr_arith_mod_nat_int.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_arith_mod_nat_nat', async () => {
    await expr_arith_mod_nat_nat.expr_arith_mod_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_mod_nat_nat.expr_arith_mod_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_mod_nat_nat.expr_arith_mod_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_mod_nat_nat.expr_arith_mod_nat_nat.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_arith_mod_tez_tez', async () => {
    await expr_arith_mod_tez_tez.expr_arith_mod_tez_tez.deploy({ as: alice })

    const res_before = await expr_arith_mod_tez_tez.expr_arith_mod_tez_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_arith_mod_tez_tez.expr_arith_mod_tez_tez.exec({ as: alice })

    const res_after = await expr_arith_mod_tez_tez.expr_arith_mod_tez_tez.get_res()
    assert(res_after.equals(new Tez(1)))
  })

  it('expr_arith_mult_int_dur', async () => {
    await expr_arith_mult_int_dur.expr_arith_mult_int_dur.deploy({ as: alice })

    const res_before = await expr_arith_mult_int_dur.expr_arith_mult_int_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_mult_int_dur.expr_arith_mult_int_dur.exec({ as: alice })

    const res_after = await expr_arith_mult_int_dur.expr_arith_mult_int_dur.get_res()
    assert(res_after.equals(new Duration("16h")))
  })

  it('expr_arith_mult_int_int', async () => {
    await expr_arith_mult_int_int.expr_arith_mult_int_int.deploy({ as: alice })

    const res_before = await expr_arith_mult_int_int.expr_arith_mult_int_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_mult_int_int.expr_arith_mult_int_int.exec({ as: alice })

    const res_after = await expr_arith_mult_int_int.expr_arith_mult_int_int.get_res()
    assert(res_after.equals(new Int(8)))
  })

  it('expr_arith_mult_int_nat', async () => {
    await expr_arith_mult_int_nat.expr_arith_mult_int_nat.deploy({ as: alice })

    const res_before = await expr_arith_mult_int_nat.expr_arith_mult_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_mult_int_nat.expr_arith_mult_int_nat.exec({ as: alice })

    const res_after = await expr_arith_mult_int_nat.expr_arith_mult_int_nat.get_res()
    assert(res_after.equals(new Int(8)))
  })

  it('expr_arith_mult_int_rat', async () => {
    await expr_arith_mult_int_rat.expr_arith_mult_int_rat.deploy({ as: alice })

    const res_before = await expr_arith_mult_int_rat.expr_arith_mult_int_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_mult_int_rat.expr_arith_mult_int_rat.exec({ as: alice })

    const res_after = await expr_arith_mult_int_rat.expr_arith_mult_int_rat.get_res()
    assert(res_after.equals(new Rational(1.5)))
  })

  it('expr_arith_mult_int_tez', async () => {
    await expr_arith_mult_int_tez.expr_arith_mult_int_tez.deploy({ as: alice })

    const res_before = await expr_arith_mult_int_tez.expr_arith_mult_int_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_arith_mult_int_tez.expr_arith_mult_int_tez.exec({ as: alice })

    const res_after = await expr_arith_mult_int_tez.expr_arith_mult_int_tez.get_res()
    assert(res_after.equals(new Tez(2)))
  })

  it('expr_arith_mult_nat_dur', async () => {
    await expr_arith_mult_nat_dur.expr_arith_mult_nat_dur.deploy({ as: alice })

    const res_before = await expr_arith_mult_nat_dur.expr_arith_mult_nat_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_mult_nat_dur.expr_arith_mult_nat_dur.exec({ as: alice })

    const res_after = await expr_arith_mult_nat_dur.expr_arith_mult_nat_dur.get_res()
    assert(res_after.equals(new Duration("16h")))
  })

  it('expr_arith_mult_nat_int', async () => {
    await expr_arith_mult_nat_int.expr_arith_mult_nat_int.deploy({ as: alice })

    const res_before = await expr_arith_mult_nat_int.expr_arith_mult_nat_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_mult_nat_int.expr_arith_mult_nat_int.exec({ as: alice })

    const res_after = await expr_arith_mult_nat_int.expr_arith_mult_nat_int.get_res()
    assert(res_after.equals(new Int(8)))
  })

  it('expr_arith_mult_nat_nat', async () => {
    await expr_arith_mult_nat_nat.expr_arith_mult_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_mult_nat_nat.expr_arith_mult_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_mult_nat_nat.expr_arith_mult_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_mult_nat_nat.expr_arith_mult_nat_nat.get_res()
    assert(res_after.equals(new Nat(8)))
  })

  it('expr_arith_mult_nat_rat', async () => {
    await expr_arith_mult_nat_rat.expr_arith_mult_nat_rat.deploy({ as: alice })

    const res_before = await expr_arith_mult_nat_rat.expr_arith_mult_nat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_mult_nat_rat.expr_arith_mult_nat_rat.exec({ as: alice })

    const res_after = await expr_arith_mult_nat_rat.expr_arith_mult_nat_rat.get_res()
    assert(res_after.equals(new Rational(1.5)))
  })

  it('expr_arith_mult_nat_tez', async () => {
    await expr_arith_mult_nat_tez.expr_arith_mult_nat_tez.deploy({ as: alice })

    const res_before = await expr_arith_mult_nat_tez.expr_arith_mult_nat_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_arith_mult_nat_tez.expr_arith_mult_nat_tez.exec({ as: alice })

    const res_after = await expr_arith_mult_nat_tez.expr_arith_mult_nat_tez.get_res()
    assert(res_after.equals(new Tez(2)))
  })

  it('expr_arith_mult_rat_dur', async () => {
    await expr_arith_mult_rat_dur.expr_arith_mult_rat_dur.deploy({ as: alice })

    const res_before = await expr_arith_mult_rat_dur.expr_arith_mult_rat_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_mult_rat_dur.expr_arith_mult_rat_dur.exec({ as: alice })

    const res_after = await expr_arith_mult_rat_dur.expr_arith_mult_rat_dur.get_res()
    assert(res_after.equals(new Duration("30m")))
  })

  it('expr_arith_mult_rat_int', async () => {
    await expr_arith_mult_rat_int.expr_arith_mult_rat_int.deploy({ as: alice })

    const res_before = await expr_arith_mult_rat_int.expr_arith_mult_rat_int.get_res()
    assert(res_before.equals(new Rational(0.0)))

    await expr_arith_mult_rat_int.expr_arith_mult_rat_int.exec({ as: alice })

    const res_after = await expr_arith_mult_rat_int.expr_arith_mult_rat_int.get_res()
    assert(res_after.equals(new Rational(1.5)))
  })

  it('expr_arith_mult_rat_nat', async () => {
    await expr_arith_mult_rat_nat.expr_arith_mult_rat_nat.deploy({ as: alice })

    const res_before = await expr_arith_mult_rat_nat.expr_arith_mult_rat_nat.get_res()
    assert(res_before.equals(new Rational(0.0)))

    await expr_arith_mult_rat_nat.expr_arith_mult_rat_nat.exec({ as: alice })

    const res_after = await expr_arith_mult_rat_nat.expr_arith_mult_rat_nat.get_res()
    assert(res_after.equals(new Rational(1.5)))
  })

  it('expr_arith_mult_rat_rat', async () => {
    await expr_arith_mult_rat_rat.expr_arith_mult_rat_rat.deploy({ as: alice })

    const res_before = await expr_arith_mult_rat_rat.expr_arith_mult_rat_rat.get_res()
    assert(res_before.equals(new Rational(0.0)))

    await expr_arith_mult_rat_rat.expr_arith_mult_rat_rat.exec({ as: alice })

    const res_after = await expr_arith_mult_rat_rat.expr_arith_mult_rat_rat.get_res()
    assert(res_after.equals(new Rational(0.05)))
  })

  it('expr_arith_mult_rat_tez', async () => {
    await expr_arith_mult_rat_tez.expr_arith_mult_rat_tez.deploy({ as: alice })

    const res_before = await expr_arith_mult_rat_tez.expr_arith_mult_rat_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_arith_mult_rat_tez.expr_arith_mult_rat_tez.exec({ as: alice })

    const res_after = await expr_arith_mult_rat_tez.expr_arith_mult_rat_tez.get_res()
    assert(res_after.equals(new Tez(0.5)))
  })

  it('expr_arith_mult_tez_nat', async () => {
    await expr_arith_mult_tez_nat.expr_arith_mult_tez_nat.deploy({ as: alice })

    const res_before = await expr_arith_mult_tez_nat.expr_arith_mult_tez_nat.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_arith_mult_tez_nat.expr_arith_mult_tez_nat.exec({ as: alice })

    const res_after = await expr_arith_mult_tez_nat.expr_arith_mult_tez_nat.get_res()
    assert(res_after.equals(new Tez(2)))
  })

  it('expr_arith_not_bool', async () => {
    await expr_arith_not_bool.expr_arith_not_bool.deploy({ as: alice })

    const res_before = await expr_arith_not_bool.expr_arith_not_bool.get_res()
    assert(res_before == false)

    await expr_arith_not_bool.expr_arith_not_bool.exec({ as: alice })

    const res_after = await expr_arith_not_bool.expr_arith_not_bool.get_res()
    assert(res_after == true)
  })

  it('expr_arith_not_bytes', async () => {
    await expr_arith_not_bytes.expr_arith_not_bytes.deploy({ as: alice })

    const res_before = await expr_arith_not_bytes.expr_arith_not_bytes.get_res()
    assert(res_before.equals(new Bytes("")))

    await expr_arith_not_bytes.expr_arith_not_bytes.exec({ as: alice })

    const res_after = await expr_arith_not_bytes.expr_arith_not_bytes.get_res()
    assert(res_after.equals(new Bytes("fe")))
  })

  it('expr_arith_not_int', async () => {
    await expr_arith_not_int.expr_arith_not_int.deploy({ as: alice })

    const res_before = await expr_arith_not_int.expr_arith_not_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_not_int.expr_arith_not_int.exec({ as: alice })

    const res_after = await expr_arith_not_int.expr_arith_not_int.get_res()
    assert(res_after.equals(new Int(-3)))
  })

  it('expr_arith_not_nat', async () => {
    await expr_arith_not_nat.expr_arith_not_nat.deploy({ as: alice })

    const res_before = await expr_arith_not_nat.expr_arith_not_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_not_nat.expr_arith_not_nat.exec({ as: alice })

    const res_after = await expr_arith_not_nat.expr_arith_not_nat.get_res()
    assert(res_after.equals(new Int(-3)))
  })

  it('expr_arith_or_bool_bool', async () => {
    await expr_arith_or_bool_bool.expr_arith_or_bool_bool.deploy({ as: alice })

    const res_before = await expr_arith_or_bool_bool.expr_arith_or_bool_bool.get_res()
    assert(res_before == false)

    await expr_arith_or_bool_bool.expr_arith_or_bool_bool.exec({ as: alice })

    const res_after = await expr_arith_or_bool_bool.expr_arith_or_bool_bool.get_res()
    assert(res_after == true)
  })

  it('expr_arith_or_bytes_bytes', async () => {
    await expr_arith_or_bytes_bytes.expr_arith_or_bytes_bytes.deploy({ as: alice })

    const res_before = await expr_arith_or_bytes_bytes.expr_arith_or_bytes_bytes.get_res()
    assert(res_before.equals(new Bytes("")))

    await expr_arith_or_bytes_bytes.expr_arith_or_bytes_bytes.exec({ as: alice })

    const res_after = await expr_arith_or_bytes_bytes.expr_arith_or_bytes_bytes.get_res()
    assert(res_after.equals(new Bytes("03")))
  })

  it('expr_arith_or_nat_nat', async () => {
    await expr_arith_or_nat_nat.expr_arith_or_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_or_nat_nat.expr_arith_or_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_or_nat_nat.expr_arith_or_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_or_nat_nat.expr_arith_or_nat_nat.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_arith_plus_date_dur', async () => {
    await expr_arith_plus_date_dur.expr_arith_plus_date_dur.deploy({ as: alice })

    const res_before = await expr_arith_plus_date_dur.expr_arith_plus_date_dur.get_res()
    assert(res_before.toISOString() == "2020-01-01T00:00:00.000Z")

    await expr_arith_plus_date_dur.expr_arith_plus_date_dur.exec({ as: alice })

    const res_after = await expr_arith_plus_date_dur.expr_arith_plus_date_dur.get_res()
    assert(res_after.toISOString() == "2020-01-01T04:00:00.000Z")
  })

  it('expr_arith_plus_dur_date', async () => {
    await expr_arith_plus_dur_date.expr_arith_plus_dur_date.deploy({ as: alice })

    const res_before = await expr_arith_plus_dur_date.expr_arith_plus_dur_date.get_res()
    assert(res_before.toISOString() == "2020-01-01T00:00:00.000Z")

    await expr_arith_plus_dur_date.expr_arith_plus_dur_date.exec({ as: alice })

    const res_after = await expr_arith_plus_dur_date.expr_arith_plus_dur_date.get_res()
    assert(res_after.toISOString() == "2020-01-01T04:00:00.000Z")
  })

  it('expr_arith_plus_dur_dur', async () => {
    await expr_arith_plus_dur_dur.expr_arith_plus_dur_dur.deploy({ as: alice })

    const res_before = await expr_arith_plus_dur_dur.expr_arith_plus_dur_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_arith_plus_dur_dur.expr_arith_plus_dur_dur.exec({ as: alice })

    const res_after = await expr_arith_plus_dur_dur.expr_arith_plus_dur_dur.get_res()
    assert(res_after.equals(new Duration("28h")))
  })

  it('expr_arith_plus_int_int', async () => {
    await expr_arith_plus_int_int.expr_arith_plus_int_int.deploy({ as: alice })

    const res_before = await expr_arith_plus_int_int.expr_arith_plus_int_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_plus_int_int.expr_arith_plus_int_int.exec({ as: alice })

    const res_after = await expr_arith_plus_int_int.expr_arith_plus_int_int.get_res()
    assert(res_after.equals(new Int(6)))
  })

  it('expr_arith_plus_int_nat', async () => {
    await expr_arith_plus_int_nat.expr_arith_plus_int_nat.deploy({ as: alice })

    const res_before = await expr_arith_plus_int_nat.expr_arith_plus_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_plus_int_nat.expr_arith_plus_int_nat.exec({ as: alice })

    const res_after = await expr_arith_plus_int_nat.expr_arith_plus_int_nat.get_res()
    assert(res_after.equals(new Int(6)))
  })

  it('expr_arith_plus_int_rat', async () => {
    await expr_arith_plus_int_rat.expr_arith_plus_int_rat.deploy({ as: alice })

    const res_before = await expr_arith_plus_int_rat.expr_arith_plus_int_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_plus_int_rat.expr_arith_plus_int_rat.exec({ as: alice })

    const res_after = await expr_arith_plus_int_rat.expr_arith_plus_int_rat.get_res()
    assert(res_after.equals(new Rational(3.5)))
  })

  it('expr_arith_plus_nat_int', async () => {
    await expr_arith_plus_nat_int.expr_arith_plus_nat_int.deploy({ as: alice })

    const res_before = await expr_arith_plus_nat_int.expr_arith_plus_nat_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_plus_nat_int.expr_arith_plus_nat_int.exec({ as: alice })

    const res_after = await expr_arith_plus_nat_int.expr_arith_plus_nat_int.get_res()
    assert(res_after.equals(new Int(6)))
  })

  it('expr_arith_plus_nat_nat', async () => {
    await expr_arith_plus_nat_nat.expr_arith_plus_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_plus_nat_nat.expr_arith_plus_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_plus_nat_nat.expr_arith_plus_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_plus_nat_nat.expr_arith_plus_nat_nat.get_res()
    assert(res_after.equals(new Nat(6)))
  })

  it('expr_arith_plus_nat_rat', async () => {
    await expr_arith_plus_nat_rat.expr_arith_plus_nat_rat.deploy({ as: alice })

    const res_before = await expr_arith_plus_nat_rat.expr_arith_plus_nat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_plus_nat_rat.expr_arith_plus_nat_rat.exec({ as: alice })

    const res_after = await expr_arith_plus_nat_rat.expr_arith_plus_nat_rat.get_res()
    assert(res_after.equals(new Rational(3.5)))
  })

  it('expr_arith_plus_rat_int', async () => {
    await expr_arith_plus_rat_int.expr_arith_plus_rat_int.deploy({ as: alice })

    const res_before = await expr_arith_plus_rat_int.expr_arith_plus_rat_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_plus_rat_int.expr_arith_plus_rat_int.exec({ as: alice })

    const res_after = await expr_arith_plus_rat_int.expr_arith_plus_rat_int.get_res()
    assert(res_after.equals(new Rational(3.5)))
  })

  it('expr_arith_plus_rat_nat', async () => {
    await expr_arith_plus_rat_nat.expr_arith_plus_rat_nat.deploy({ as: alice })

    const res_before = await expr_arith_plus_rat_nat.expr_arith_plus_rat_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_plus_rat_nat.expr_arith_plus_rat_nat.exec({ as: alice })

    const res_after = await expr_arith_plus_rat_nat.expr_arith_plus_rat_nat.get_res()
    assert(res_after.equals(new Rational(3.5)))
  })

  it('expr_arith_plus_rat_rat', async () => {
    await expr_arith_plus_rat_rat.expr_arith_plus_rat_rat.deploy({ as: alice })

    const res_before = await expr_arith_plus_rat_rat.expr_arith_plus_rat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_plus_rat_rat.expr_arith_plus_rat_rat.exec({ as: alice })

    const res_after = await expr_arith_plus_rat_rat.expr_arith_plus_rat_rat.get_res()
    assert(res_after.equals(new Rational(0.7)))
  })

  it('expr_arith_plus_str_str', async () => {
    await expr_arith_plus_str_str.expr_arith_plus_str_str.deploy({ as: alice })

    const res_before = await expr_arith_plus_str_str.expr_arith_plus_str_str.get_res()
    assert(res_before == "")

    await expr_arith_plus_str_str.expr_arith_plus_str_str.exec({ as: alice })

    const res_after = await expr_arith_plus_str_str.expr_arith_plus_str_str.get_res()
    assert(res_after == "ab")
  })

  it('expr_arith_plus_tez_tez', async () => {
    await expr_arith_plus_tez_tez.expr_arith_plus_tez_tez.deploy({ as: alice })

    const res_before = await expr_arith_plus_tez_tez.expr_arith_plus_tez_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_arith_plus_tez_tez.expr_arith_plus_tez_tez.exec({ as: alice })

    const res_after = await expr_arith_plus_tez_tez.expr_arith_plus_tez_tez.get_res()
    assert(res_after.equals(new Tez(3)))
  })

  it('expr_arith_uminus_int', async () => {
    await expr_arith_uminus_int.expr_arith_uminus_int.deploy({ as: alice })

    const res_before = await expr_arith_uminus_int.expr_arith_uminus_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_arith_uminus_int.expr_arith_uminus_int.exec({ as: alice })

    const res_after = await expr_arith_uminus_int.expr_arith_uminus_int.get_res()
    assert(res_after.equals(new Int(-1)))
  })

  it('expr_arith_uminus_rat', async () => {
    await expr_arith_uminus_rat.expr_arith_uminus_rat.deploy({ as: alice })

    const res_before = await expr_arith_uminus_rat.expr_arith_uminus_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_arith_uminus_rat.expr_arith_uminus_rat.exec({ as: alice })

    const res_after = await expr_arith_uminus_rat.expr_arith_uminus_rat.get_res()
    assert(res_after.equals(new Rational(-1, new BigNumber(3))))
  })

  it('expr_arith_xor_bool_bool', async () => {
    await expr_arith_xor_bool_bool.expr_arith_xor_bool_bool.deploy({ as: alice })

    const res_before = await expr_arith_xor_bool_bool.expr_arith_xor_bool_bool.get_res()
    assert(res_before == false)

    await expr_arith_xor_bool_bool.expr_arith_xor_bool_bool.exec({ as: alice })

    const res_after = await expr_arith_xor_bool_bool.expr_arith_xor_bool_bool.get_res()
    assert(res_after == true)
  })

  it('expr_arith_xor_bytes_bytes', async () => {
    await expr_arith_xor_bytes_bytes.expr_arith_xor_bytes_bytes.deploy({ as: alice })

    const res_before = await expr_arith_xor_bytes_bytes.expr_arith_xor_bytes_bytes.get_res()
    assert(res_before.equals(new Bytes("")))

    await expr_arith_xor_bytes_bytes.expr_arith_xor_bytes_bytes.exec({ as: alice })

    const res_after = await expr_arith_xor_bytes_bytes.expr_arith_xor_bytes_bytes.get_res()
    assert(res_after.equals(new Bytes("02")))
  })

  it('expr_arith_xor_nat_nat', async () => {
    await expr_arith_xor_nat_nat.expr_arith_xor_nat_nat.deploy({ as: alice })

    const res_before = await expr_arith_xor_nat_nat.expr_arith_xor_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_arith_xor_nat_nat.expr_arith_xor_nat_nat.exec({ as: alice })

    const res_after = await expr_arith_xor_nat_nat.expr_arith_xor_nat_nat.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_cmp_eq_addr_addr', async () => {
    await expr_cmp_eq_addr_addr.expr_cmp_eq_addr_addr.deploy({ as: alice })

    const res_before = await expr_cmp_eq_addr_addr.expr_cmp_eq_addr_addr.get_res()
    assert(res_before == false)

    await expr_cmp_eq_addr_addr.expr_cmp_eq_addr_addr.exec({ as: alice })

    const res_after = await expr_cmp_eq_addr_addr.expr_cmp_eq_addr_addr.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_bool_bool', async () => {
    await expr_cmp_eq_bool_bool.expr_cmp_eq_bool_bool.deploy({ as: alice })

    const res_before = await expr_cmp_eq_bool_bool.expr_cmp_eq_bool_bool.get_res()
    assert(res_before == false)

    await expr_cmp_eq_bool_bool.expr_cmp_eq_bool_bool.exec({ as: alice })

    const res_after = await expr_cmp_eq_bool_bool.expr_cmp_eq_bool_bool.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_date_date', async () => {
    await expr_cmp_eq_date_date.expr_cmp_eq_date_date.deploy({ as: alice })

    const res_before = await expr_cmp_eq_date_date.expr_cmp_eq_date_date.get_res()
    assert(res_before == false)

    await expr_cmp_eq_date_date.expr_cmp_eq_date_date.exec({ as: alice })

    const res_after = await expr_cmp_eq_date_date.expr_cmp_eq_date_date.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_dur_dur', async () => {
    await expr_cmp_eq_dur_dur.expr_cmp_eq_dur_dur.deploy({ as: alice })

    const res_before = await expr_cmp_eq_dur_dur.expr_cmp_eq_dur_dur.get_res()
    assert(res_before == false)

    await expr_cmp_eq_dur_dur.expr_cmp_eq_dur_dur.exec({ as: alice })

    const res_after = await expr_cmp_eq_dur_dur.expr_cmp_eq_dur_dur.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_int_int', async () => {
    await expr_cmp_eq_int_int.expr_cmp_eq_int_int.deploy({ as: alice })

    const res_before = await expr_cmp_eq_int_int.expr_cmp_eq_int_int.get_res()
    assert(res_before == false)

    await expr_cmp_eq_int_int.expr_cmp_eq_int_int.exec({ as: alice })

    const res_after = await expr_cmp_eq_int_int.expr_cmp_eq_int_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_int_nat', async () => {
    await expr_cmp_eq_int_nat.expr_cmp_eq_int_nat.deploy({ as: alice })

    const res_before = await expr_cmp_eq_int_nat.expr_cmp_eq_int_nat.get_res()
    assert(res_before == false)

    await expr_cmp_eq_int_nat.expr_cmp_eq_int_nat.exec({ as: alice })

    const res_after = await expr_cmp_eq_int_nat.expr_cmp_eq_int_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_int_rat', async () => {
    await expr_cmp_eq_int_rat.expr_cmp_eq_int_rat.deploy({ as: alice })

    const res_before = await expr_cmp_eq_int_rat.expr_cmp_eq_int_rat.get_res()
    assert(res_before == false)

    await expr_cmp_eq_int_rat.expr_cmp_eq_int_rat.exec({ as: alice })

    const res_after = await expr_cmp_eq_int_rat.expr_cmp_eq_int_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_nat_int', async () => {
    await expr_cmp_eq_nat_int.expr_cmp_eq_nat_int.deploy({ as: alice })

    const res_before = await expr_cmp_eq_nat_int.expr_cmp_eq_nat_int.get_res()
    assert(res_before == false)

    await expr_cmp_eq_nat_int.expr_cmp_eq_nat_int.exec({ as: alice })

    const res_after = await expr_cmp_eq_nat_int.expr_cmp_eq_nat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_nat_nat', async () => {
    await expr_cmp_eq_nat_nat.expr_cmp_eq_nat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_eq_nat_nat.expr_cmp_eq_nat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_eq_nat_nat.expr_cmp_eq_nat_nat.exec({ as: alice })

    const res_after = await expr_cmp_eq_nat_nat.expr_cmp_eq_nat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_nat_rat', async () => {
    await expr_cmp_eq_nat_rat.expr_cmp_eq_nat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_eq_nat_rat.expr_cmp_eq_nat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_eq_nat_rat.expr_cmp_eq_nat_rat.exec({ as: alice })

    const res_after = await expr_cmp_eq_nat_rat.expr_cmp_eq_nat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_rat_int', async () => {
    await expr_cmp_eq_rat_int.expr_cmp_eq_rat_int.deploy({ as: alice })

    const res_before = await expr_cmp_eq_rat_int.expr_cmp_eq_rat_int.get_res()
    assert(res_before == false)

    await expr_cmp_eq_rat_int.expr_cmp_eq_rat_int.exec({ as: alice })

    const res_after = await expr_cmp_eq_rat_int.expr_cmp_eq_rat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_rat_nat', async () => {
    await expr_cmp_eq_rat_nat.expr_cmp_eq_rat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_eq_rat_nat.expr_cmp_eq_rat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_eq_rat_nat.expr_cmp_eq_rat_nat.exec({ as: alice })

    const res_after = await expr_cmp_eq_rat_nat.expr_cmp_eq_rat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_rat_rat', async () => {
    await expr_cmp_eq_rat_rat.expr_cmp_eq_rat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_eq_rat_rat.expr_cmp_eq_rat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_eq_rat_rat.expr_cmp_eq_rat_rat.exec({ as: alice })

    const res_after = await expr_cmp_eq_rat_rat.expr_cmp_eq_rat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_str_str', async () => {
    await expr_cmp_eq_str_str.expr_cmp_eq_str_str.deploy({ as: alice })

    const res_before = await expr_cmp_eq_str_str.expr_cmp_eq_str_str.get_res()
    assert(res_before == false)

    await expr_cmp_eq_str_str.expr_cmp_eq_str_str.exec({ as: alice })

    const res_after = await expr_cmp_eq_str_str.expr_cmp_eq_str_str.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_eq_tez_tez', async () => {
    await expr_cmp_eq_tez_tez.expr_cmp_eq_tez_tez.deploy({ as: alice })

    const res_before = await expr_cmp_eq_tez_tez.expr_cmp_eq_tez_tez.get_res()
    assert(res_before == false)

    await expr_cmp_eq_tez_tez.expr_cmp_eq_tez_tez.exec({ as: alice })

    const res_after = await expr_cmp_eq_tez_tez.expr_cmp_eq_tez_tez.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_addr_addr', async () => {
    await expr_cmp_ge_addr_addr.expr_cmp_ge_addr_addr.deploy({ as: alice })

    const res_before = await expr_cmp_ge_addr_addr.expr_cmp_ge_addr_addr.get_res()
    assert(res_before == false)

    await expr_cmp_ge_addr_addr.expr_cmp_ge_addr_addr.exec({ as: alice })

    const res_after = await expr_cmp_ge_addr_addr.expr_cmp_ge_addr_addr.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_date_date', async () => {
    await expr_cmp_ge_date_date.expr_cmp_ge_date_date.deploy({ as: alice })

    const res_before = await expr_cmp_ge_date_date.expr_cmp_ge_date_date.get_res()
    assert(res_before == false)

    await expr_cmp_ge_date_date.expr_cmp_ge_date_date.exec({ as: alice })

    const res_after = await expr_cmp_ge_date_date.expr_cmp_ge_date_date.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_dur_dur', async () => {
    await expr_cmp_ge_dur_dur.expr_cmp_ge_dur_dur.deploy({ as: alice })

    const res_before = await expr_cmp_ge_dur_dur.expr_cmp_ge_dur_dur.get_res()
    assert(res_before == false)

    await expr_cmp_ge_dur_dur.expr_cmp_ge_dur_dur.exec({ as: alice })

    const res_after = await expr_cmp_ge_dur_dur.expr_cmp_ge_dur_dur.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_int_int', async () => {
    await expr_cmp_ge_int_int.expr_cmp_ge_int_int.deploy({ as: alice })

    const res_before = await expr_cmp_ge_int_int.expr_cmp_ge_int_int.get_res()
    assert(res_before == false)

    await expr_cmp_ge_int_int.expr_cmp_ge_int_int.exec({ as: alice })

    const res_after = await expr_cmp_ge_int_int.expr_cmp_ge_int_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_int_nat', async () => {
    await expr_cmp_ge_int_nat.expr_cmp_ge_int_nat.deploy({ as: alice })

    const res_before = await expr_cmp_ge_int_nat.expr_cmp_ge_int_nat.get_res()
    assert(res_before == false)

    await expr_cmp_ge_int_nat.expr_cmp_ge_int_nat.exec({ as: alice })

    const res_after = await expr_cmp_ge_int_nat.expr_cmp_ge_int_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_int_rat', async () => {
    await expr_cmp_ge_int_rat.expr_cmp_ge_int_rat.deploy({ as: alice })

    const res_before = await expr_cmp_ge_int_rat.expr_cmp_ge_int_rat.get_res()
    assert(res_before == false)

    await expr_cmp_ge_int_rat.expr_cmp_ge_int_rat.exec({ as: alice })

    const res_after = await expr_cmp_ge_int_rat.expr_cmp_ge_int_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_nat_int', async () => {
    await expr_cmp_ge_nat_int.expr_cmp_ge_nat_int.deploy({ as: alice })

    const res_before = await expr_cmp_ge_nat_int.expr_cmp_ge_nat_int.get_res()
    assert(res_before == false)

    await expr_cmp_ge_nat_int.expr_cmp_ge_nat_int.exec({ as: alice })

    const res_after = await expr_cmp_ge_nat_int.expr_cmp_ge_nat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_nat_nat', async () => {
    await expr_cmp_ge_nat_nat.expr_cmp_ge_nat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_ge_nat_nat.expr_cmp_ge_nat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_ge_nat_nat.expr_cmp_ge_nat_nat.exec({ as: alice })

    const res_after = await expr_cmp_ge_nat_nat.expr_cmp_ge_nat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_nat_rat', async () => {
    await expr_cmp_ge_nat_rat.expr_cmp_ge_nat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_ge_nat_rat.expr_cmp_ge_nat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_ge_nat_rat.expr_cmp_ge_nat_rat.exec({ as: alice })

    const res_after = await expr_cmp_ge_nat_rat.expr_cmp_ge_nat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_rat_int', async () => {
    await expr_cmp_ge_rat_int.expr_cmp_ge_rat_int.deploy({ as: alice })

    const res_before = await expr_cmp_ge_rat_int.expr_cmp_ge_rat_int.get_res()
    assert(res_before == false)

    await expr_cmp_ge_rat_int.expr_cmp_ge_rat_int.exec({ as: alice })

    const res_after = await expr_cmp_ge_rat_int.expr_cmp_ge_rat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_rat_nat', async () => {
    await expr_cmp_ge_rat_nat.expr_cmp_ge_rat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_ge_rat_nat.expr_cmp_ge_rat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_ge_rat_nat.expr_cmp_ge_rat_nat.exec({ as: alice })

    const res_after = await expr_cmp_ge_rat_nat.expr_cmp_ge_rat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_rat_rat', async () => {
    await expr_cmp_ge_rat_rat.expr_cmp_ge_rat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_ge_rat_rat.expr_cmp_ge_rat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_ge_rat_rat.expr_cmp_ge_rat_rat.exec({ as: alice })

    const res_after = await expr_cmp_ge_rat_rat.expr_cmp_ge_rat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_str_str', async () => {
    await expr_cmp_ge_str_str.expr_cmp_ge_str_str.deploy({ as: alice })

    const res_before = await expr_cmp_ge_str_str.expr_cmp_ge_str_str.get_res()
    assert(res_before == false)

    await expr_cmp_ge_str_str.expr_cmp_ge_str_str.exec({ as: alice })

    const res_after = await expr_cmp_ge_str_str.expr_cmp_ge_str_str.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ge_tez_tez', async () => {
    await expr_cmp_ge_tez_tez.expr_cmp_ge_tez_tez.deploy({ as: alice })

    const res_before = await expr_cmp_ge_tez_tez.expr_cmp_ge_tez_tez.get_res()
    assert(res_before == false)

    await expr_cmp_ge_tez_tez.expr_cmp_ge_tez_tez.exec({ as: alice })

    const res_after = await expr_cmp_ge_tez_tez.expr_cmp_ge_tez_tez.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_addr_addr', async () => {
    await expr_cmp_gt_addr_addr.expr_cmp_gt_addr_addr.deploy({ as: alice })

    const res_before = await expr_cmp_gt_addr_addr.expr_cmp_gt_addr_addr.get_res()
    assert(res_before == false)

    await expr_cmp_gt_addr_addr.expr_cmp_gt_addr_addr.exec({ as: alice })

    const res_after = await expr_cmp_gt_addr_addr.expr_cmp_gt_addr_addr.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_date_date', async () => {
    await expr_cmp_gt_date_date.expr_cmp_gt_date_date.deploy({ as: alice })

    const res_before = await expr_cmp_gt_date_date.expr_cmp_gt_date_date.get_res()
    assert(res_before == false)

    await expr_cmp_gt_date_date.expr_cmp_gt_date_date.exec({ as: alice })

    const res_after = await expr_cmp_gt_date_date.expr_cmp_gt_date_date.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_dur_dur', async () => {
    await expr_cmp_gt_dur_dur.expr_cmp_gt_dur_dur.deploy({ as: alice })

    const res_before = await expr_cmp_gt_dur_dur.expr_cmp_gt_dur_dur.get_res()
    assert(res_before == false)

    await expr_cmp_gt_dur_dur.expr_cmp_gt_dur_dur.exec({ as: alice })

    const res_after = await expr_cmp_gt_dur_dur.expr_cmp_gt_dur_dur.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_int_int', async () => {
    await expr_cmp_gt_int_int.expr_cmp_gt_int_int.deploy({ as: alice })

    const res_before = await expr_cmp_gt_int_int.expr_cmp_gt_int_int.get_res()
    assert(res_before == false)

    await expr_cmp_gt_int_int.expr_cmp_gt_int_int.exec({ as: alice })

    const res_after = await expr_cmp_gt_int_int.expr_cmp_gt_int_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_int_nat', async () => {
    await expr_cmp_gt_int_nat.expr_cmp_gt_int_nat.deploy({ as: alice })

    const res_before = await expr_cmp_gt_int_nat.expr_cmp_gt_int_nat.get_res()
    assert(res_before == false)

    await expr_cmp_gt_int_nat.expr_cmp_gt_int_nat.exec({ as: alice })

    const res_after = await expr_cmp_gt_int_nat.expr_cmp_gt_int_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_int_rat', async () => {
    await expr_cmp_gt_int_rat.expr_cmp_gt_int_rat.deploy({ as: alice })

    const res_before = await expr_cmp_gt_int_rat.expr_cmp_gt_int_rat.get_res()
    assert(res_before == false)

    await expr_cmp_gt_int_rat.expr_cmp_gt_int_rat.exec({ as: alice })

    const res_after = await expr_cmp_gt_int_rat.expr_cmp_gt_int_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_nat_int', async () => {
    await expr_cmp_gt_nat_int.expr_cmp_gt_nat_int.deploy({ as: alice })

    const res_before = await expr_cmp_gt_nat_int.expr_cmp_gt_nat_int.get_res()
    assert(res_before == false)

    await expr_cmp_gt_nat_int.expr_cmp_gt_nat_int.exec({ as: alice })

    const res_after = await expr_cmp_gt_nat_int.expr_cmp_gt_nat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_nat_nat', async () => {
    await expr_cmp_gt_nat_nat.expr_cmp_gt_nat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_gt_nat_nat.expr_cmp_gt_nat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_gt_nat_nat.expr_cmp_gt_nat_nat.exec({ as: alice })

    const res_after = await expr_cmp_gt_nat_nat.expr_cmp_gt_nat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_nat_rat', async () => {
    await expr_cmp_gt_nat_rat.expr_cmp_gt_nat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_gt_nat_rat.expr_cmp_gt_nat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_gt_nat_rat.expr_cmp_gt_nat_rat.exec({ as: alice })

    const res_after = await expr_cmp_gt_nat_rat.expr_cmp_gt_nat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_rat_int', async () => {
    await expr_cmp_gt_rat_int.expr_cmp_gt_rat_int.deploy({ as: alice })

    const res_before = await expr_cmp_gt_rat_int.expr_cmp_gt_rat_int.get_res()
    assert(res_before == false)

    await expr_cmp_gt_rat_int.expr_cmp_gt_rat_int.exec({ as: alice })

    const res_after = await expr_cmp_gt_rat_int.expr_cmp_gt_rat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_rat_nat', async () => {
    await expr_cmp_gt_rat_nat.expr_cmp_gt_rat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_gt_rat_nat.expr_cmp_gt_rat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_gt_rat_nat.expr_cmp_gt_rat_nat.exec({ as: alice })

    const res_after = await expr_cmp_gt_rat_nat.expr_cmp_gt_rat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_rat_rat', async () => {
    await expr_cmp_gt_rat_rat.expr_cmp_gt_rat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_gt_rat_rat.expr_cmp_gt_rat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_gt_rat_rat.expr_cmp_gt_rat_rat.exec({ as: alice })

    const res_after = await expr_cmp_gt_rat_rat.expr_cmp_gt_rat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_str_str', async () => {
    await expr_cmp_gt_str_str.expr_cmp_gt_str_str.deploy({ as: alice })

    const res_before = await expr_cmp_gt_str_str.expr_cmp_gt_str_str.get_res()
    assert(res_before == false)

    await expr_cmp_gt_str_str.expr_cmp_gt_str_str.exec({ as: alice })

    const res_after = await expr_cmp_gt_str_str.expr_cmp_gt_str_str.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_gt_tez_tez', async () => {
    await expr_cmp_gt_tez_tez.expr_cmp_gt_tez_tez.deploy({ as: alice })

    const res_before = await expr_cmp_gt_tez_tez.expr_cmp_gt_tez_tez.get_res()
    assert(res_before == false)

    await expr_cmp_gt_tez_tez.expr_cmp_gt_tez_tez.exec({ as: alice })

    const res_after = await expr_cmp_gt_tez_tez.expr_cmp_gt_tez_tez.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_addr_addr', async () => {
    await expr_cmp_le_addr_addr.expr_cmp_le_addr_addr.deploy({ as: alice })

    const res_before = await expr_cmp_le_addr_addr.expr_cmp_le_addr_addr.get_res()
    assert(res_before == false)

    await expr_cmp_le_addr_addr.expr_cmp_le_addr_addr.exec({ as: alice })

    const res_after = await expr_cmp_le_addr_addr.expr_cmp_le_addr_addr.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_date_date', async () => {
    await expr_cmp_le_date_date.expr_cmp_le_date_date.deploy({ as: alice })

    const res_before = await expr_cmp_le_date_date.expr_cmp_le_date_date.get_res()
    assert(res_before == false)

    await expr_cmp_le_date_date.expr_cmp_le_date_date.exec({ as: alice })

    const res_after = await expr_cmp_le_date_date.expr_cmp_le_date_date.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_dur_dur', async () => {
    await expr_cmp_le_dur_dur.expr_cmp_le_dur_dur.deploy({ as: alice })

    const res_before = await expr_cmp_le_dur_dur.expr_cmp_le_dur_dur.get_res()
    assert(res_before == false)

    await expr_cmp_le_dur_dur.expr_cmp_le_dur_dur.exec({ as: alice })

    const res_after = await expr_cmp_le_dur_dur.expr_cmp_le_dur_dur.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_int_int', async () => {
    await expr_cmp_le_int_int.expr_cmp_le_int_int.deploy({ as: alice })

    const res_before = await expr_cmp_le_int_int.expr_cmp_le_int_int.get_res()
    assert(res_before == false)

    await expr_cmp_le_int_int.expr_cmp_le_int_int.exec({ as: alice })

    const res_after = await expr_cmp_le_int_int.expr_cmp_le_int_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_int_nat', async () => {
    await expr_cmp_le_int_nat.expr_cmp_le_int_nat.deploy({ as: alice })

    const res_before = await expr_cmp_le_int_nat.expr_cmp_le_int_nat.get_res()
    assert(res_before == false)

    await expr_cmp_le_int_nat.expr_cmp_le_int_nat.exec({ as: alice })

    const res_after = await expr_cmp_le_int_nat.expr_cmp_le_int_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_int_rat', async () => {
    await expr_cmp_le_int_rat.expr_cmp_le_int_rat.deploy({ as: alice })

    const res_before = await expr_cmp_le_int_rat.expr_cmp_le_int_rat.get_res()
    assert(res_before == false)

    await expr_cmp_le_int_rat.expr_cmp_le_int_rat.exec({ as: alice })

    const res_after = await expr_cmp_le_int_rat.expr_cmp_le_int_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_nat_int', async () => {
    await expr_cmp_le_nat_int.expr_cmp_le_nat_int.deploy({ as: alice })

    const res_before = await expr_cmp_le_nat_int.expr_cmp_le_nat_int.get_res()
    assert(res_before == false)

    await expr_cmp_le_nat_int.expr_cmp_le_nat_int.exec({ as: alice })

    const res_after = await expr_cmp_le_nat_int.expr_cmp_le_nat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_nat_nat', async () => {
    await expr_cmp_le_nat_nat.expr_cmp_le_nat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_le_nat_nat.expr_cmp_le_nat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_le_nat_nat.expr_cmp_le_nat_nat.exec({ as: alice })

    const res_after = await expr_cmp_le_nat_nat.expr_cmp_le_nat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_nat_rat', async () => {
    await expr_cmp_le_nat_rat.expr_cmp_le_nat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_le_nat_rat.expr_cmp_le_nat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_le_nat_rat.expr_cmp_le_nat_rat.exec({ as: alice })

    const res_after = await expr_cmp_le_nat_rat.expr_cmp_le_nat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_rat_int', async () => {
    await expr_cmp_le_rat_int.expr_cmp_le_rat_int.deploy({ as: alice })

    const res_before = await expr_cmp_le_rat_int.expr_cmp_le_rat_int.get_res()
    assert(res_before == false)

    await expr_cmp_le_rat_int.expr_cmp_le_rat_int.exec({ as: alice })

    const res_after = await expr_cmp_le_rat_int.expr_cmp_le_rat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_rat_nat', async () => {
    await expr_cmp_le_rat_nat.expr_cmp_le_rat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_le_rat_nat.expr_cmp_le_rat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_le_rat_nat.expr_cmp_le_rat_nat.exec({ as: alice })

    const res_after = await expr_cmp_le_rat_nat.expr_cmp_le_rat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_rat_rat', async () => {
    await expr_cmp_le_rat_rat.expr_cmp_le_rat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_le_rat_rat.expr_cmp_le_rat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_le_rat_rat.expr_cmp_le_rat_rat.exec({ as: alice })

    const res_after = await expr_cmp_le_rat_rat.expr_cmp_le_rat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_str_str', async () => {
    await expr_cmp_le_str_str.expr_cmp_le_str_str.deploy({ as: alice })

    const res_before = await expr_cmp_le_str_str.expr_cmp_le_str_str.get_res()
    assert(res_before == false)

    await expr_cmp_le_str_str.expr_cmp_le_str_str.exec({ as: alice })

    const res_after = await expr_cmp_le_str_str.expr_cmp_le_str_str.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_le_tez_tez', async () => {
    await expr_cmp_le_tez_tez.expr_cmp_le_tez_tez.deploy({ as: alice })

    const res_before = await expr_cmp_le_tez_tez.expr_cmp_le_tez_tez.get_res()
    assert(res_before == false)

    await expr_cmp_le_tez_tez.expr_cmp_le_tez_tez.exec({ as: alice })

    const res_after = await expr_cmp_le_tez_tez.expr_cmp_le_tez_tez.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_addr_addr', async () => {
    await expr_cmp_lt_addr_addr.expr_cmp_lt_addr_addr.deploy({ as: alice })

    const res_before = await expr_cmp_lt_addr_addr.expr_cmp_lt_addr_addr.get_res()
    assert(res_before == false)

    await expr_cmp_lt_addr_addr.expr_cmp_lt_addr_addr.exec({ as: alice })

    const res_after = await expr_cmp_lt_addr_addr.expr_cmp_lt_addr_addr.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_date_date', async () => {
    await expr_cmp_lt_date_date.expr_cmp_lt_date_date.deploy({ as: alice })

    const res_before = await expr_cmp_lt_date_date.expr_cmp_lt_date_date.get_res()
    assert(res_before == false)

    await expr_cmp_lt_date_date.expr_cmp_lt_date_date.exec({ as: alice })

    const res_after = await expr_cmp_lt_date_date.expr_cmp_lt_date_date.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_dur_dur', async () => {
    await expr_cmp_lt_dur_dur.expr_cmp_lt_dur_dur.deploy({ as: alice })

    const res_before = await expr_cmp_lt_dur_dur.expr_cmp_lt_dur_dur.get_res()
    assert(res_before == false)

    await expr_cmp_lt_dur_dur.expr_cmp_lt_dur_dur.exec({ as: alice })

    const res_after = await expr_cmp_lt_dur_dur.expr_cmp_lt_dur_dur.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_int_int', async () => {
    await expr_cmp_lt_int_int.expr_cmp_lt_int_int.deploy({ as: alice })

    const res_before = await expr_cmp_lt_int_int.expr_cmp_lt_int_int.get_res()
    assert(res_before == false)

    await expr_cmp_lt_int_int.expr_cmp_lt_int_int.exec({ as: alice })

    const res_after = await expr_cmp_lt_int_int.expr_cmp_lt_int_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_int_nat', async () => {
    await expr_cmp_lt_int_nat.expr_cmp_lt_int_nat.deploy({ as: alice })

    const res_before = await expr_cmp_lt_int_nat.expr_cmp_lt_int_nat.get_res()
    assert(res_before == false)

    await expr_cmp_lt_int_nat.expr_cmp_lt_int_nat.exec({ as: alice })

    const res_after = await expr_cmp_lt_int_nat.expr_cmp_lt_int_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_int_rat', async () => {
    await expr_cmp_lt_int_rat.expr_cmp_lt_int_rat.deploy({ as: alice })

    const res_before = await expr_cmp_lt_int_rat.expr_cmp_lt_int_rat.get_res()
    assert(res_before == false)

    await expr_cmp_lt_int_rat.expr_cmp_lt_int_rat.exec({ as: alice })

    const res_after = await expr_cmp_lt_int_rat.expr_cmp_lt_int_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_nat_int', async () => {
    await expr_cmp_lt_nat_int.expr_cmp_lt_nat_int.deploy({ as: alice })

    const res_before = await expr_cmp_lt_nat_int.expr_cmp_lt_nat_int.get_res()
    assert(res_before == false)

    await expr_cmp_lt_nat_int.expr_cmp_lt_nat_int.exec({ as: alice })

    const res_after = await expr_cmp_lt_nat_int.expr_cmp_lt_nat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_nat_nat', async () => {
    await expr_cmp_lt_nat_nat.expr_cmp_lt_nat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_lt_nat_nat.expr_cmp_lt_nat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_lt_nat_nat.expr_cmp_lt_nat_nat.exec({ as: alice })

    const res_after = await expr_cmp_lt_nat_nat.expr_cmp_lt_nat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_nat_rat', async () => {
    await expr_cmp_lt_nat_rat.expr_cmp_lt_nat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_lt_nat_rat.expr_cmp_lt_nat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_lt_nat_rat.expr_cmp_lt_nat_rat.exec({ as: alice })

    const res_after = await expr_cmp_lt_nat_rat.expr_cmp_lt_nat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_rat_int', async () => {
    await expr_cmp_lt_rat_int.expr_cmp_lt_rat_int.deploy({ as: alice })

    const res_before = await expr_cmp_lt_rat_int.expr_cmp_lt_rat_int.get_res()
    assert(res_before == false)

    await expr_cmp_lt_rat_int.expr_cmp_lt_rat_int.exec({ as: alice })

    const res_after = await expr_cmp_lt_rat_int.expr_cmp_lt_rat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_rat_nat', async () => {
    await expr_cmp_lt_rat_nat.expr_cmp_lt_rat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_lt_rat_nat.expr_cmp_lt_rat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_lt_rat_nat.expr_cmp_lt_rat_nat.exec({ as: alice })

    const res_after = await expr_cmp_lt_rat_nat.expr_cmp_lt_rat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_rat_rat', async () => {
    await expr_cmp_lt_rat_rat.expr_cmp_lt_rat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_lt_rat_rat.expr_cmp_lt_rat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_lt_rat_rat.expr_cmp_lt_rat_rat.exec({ as: alice })

    const res_after = await expr_cmp_lt_rat_rat.expr_cmp_lt_rat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_str_str', async () => {
    await expr_cmp_lt_str_str.expr_cmp_lt_str_str.deploy({ as: alice })

    const res_before = await expr_cmp_lt_str_str.expr_cmp_lt_str_str.get_res()
    assert(res_before == false)

    await expr_cmp_lt_str_str.expr_cmp_lt_str_str.exec({ as: alice })

    const res_after = await expr_cmp_lt_str_str.expr_cmp_lt_str_str.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_lt_tez_tez', async () => {
    await expr_cmp_lt_tez_tez.expr_cmp_lt_tez_tez.deploy({ as: alice })

    const res_before = await expr_cmp_lt_tez_tez.expr_cmp_lt_tez_tez.get_res()
    assert(res_before == false)

    await expr_cmp_lt_tez_tez.expr_cmp_lt_tez_tez.exec({ as: alice })

    const res_after = await expr_cmp_lt_tez_tez.expr_cmp_lt_tez_tez.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_addr_addr', async () => {
    await expr_cmp_ne_addr_addr.expr_cmp_ne_addr_addr.deploy({ as: alice })

    const res_before = await expr_cmp_ne_addr_addr.expr_cmp_ne_addr_addr.get_res()
    assert(res_before == false)

    await expr_cmp_ne_addr_addr.expr_cmp_ne_addr_addr.exec({ as: alice })

    const res_after = await expr_cmp_ne_addr_addr.expr_cmp_ne_addr_addr.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_bool_bool', async () => {
    await expr_cmp_ne_bool_bool.expr_cmp_ne_bool_bool.deploy({ as: alice })

    const res_before = await expr_cmp_ne_bool_bool.expr_cmp_ne_bool_bool.get_res()
    assert(res_before == false)

    await expr_cmp_ne_bool_bool.expr_cmp_ne_bool_bool.exec({ as: alice })

    const res_after = await expr_cmp_ne_bool_bool.expr_cmp_ne_bool_bool.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_date_date', async () => {
    await expr_cmp_ne_date_date.expr_cmp_ne_date_date.deploy({ as: alice })

    const res_before = await expr_cmp_ne_date_date.expr_cmp_ne_date_date.get_res()
    assert(res_before == false)

    await expr_cmp_ne_date_date.expr_cmp_ne_date_date.exec({ as: alice })

    const res_after = await expr_cmp_ne_date_date.expr_cmp_ne_date_date.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_dur_dur', async () => {
    await expr_cmp_ne_dur_dur.expr_cmp_ne_dur_dur.deploy({ as: alice })

    const res_before = await expr_cmp_ne_dur_dur.expr_cmp_ne_dur_dur.get_res()
    assert(res_before == false)

    await expr_cmp_ne_dur_dur.expr_cmp_ne_dur_dur.exec({ as: alice })

    const res_after = await expr_cmp_ne_dur_dur.expr_cmp_ne_dur_dur.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_int_int', async () => {
    await expr_cmp_ne_int_int.expr_cmp_ne_int_int.deploy({ as: alice })

    const res_before = await expr_cmp_ne_int_int.expr_cmp_ne_int_int.get_res()
    assert(res_before == false)

    await expr_cmp_ne_int_int.expr_cmp_ne_int_int.exec({ as: alice })

    const res_after = await expr_cmp_ne_int_int.expr_cmp_ne_int_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_int_nat', async () => {
    await expr_cmp_ne_int_nat.expr_cmp_ne_int_nat.deploy({ as: alice })

    const res_before = await expr_cmp_ne_int_nat.expr_cmp_ne_int_nat.get_res()
    assert(res_before == false)

    await expr_cmp_ne_int_nat.expr_cmp_ne_int_nat.exec({ as: alice })

    const res_after = await expr_cmp_ne_int_nat.expr_cmp_ne_int_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_int_rat', async () => {
    await expr_cmp_ne_int_rat.expr_cmp_ne_int_rat.deploy({ as: alice })

    const res_before = await expr_cmp_ne_int_rat.expr_cmp_ne_int_rat.get_res()
    assert(res_before == false)

    await expr_cmp_ne_int_rat.expr_cmp_ne_int_rat.exec({ as: alice })

    const res_after = await expr_cmp_ne_int_rat.expr_cmp_ne_int_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_nat_int', async () => {
    await expr_cmp_ne_nat_int.expr_cmp_ne_nat_int.deploy({ as: alice })

    const res_before = await expr_cmp_ne_nat_int.expr_cmp_ne_nat_int.get_res()
    assert(res_before == false)

    await expr_cmp_ne_nat_int.expr_cmp_ne_nat_int.exec({ as: alice })

    const res_after = await expr_cmp_ne_nat_int.expr_cmp_ne_nat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_nat_nat', async () => {
    await expr_cmp_ne_nat_nat.expr_cmp_ne_nat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_ne_nat_nat.expr_cmp_ne_nat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_ne_nat_nat.expr_cmp_ne_nat_nat.exec({ as: alice })

    const res_after = await expr_cmp_ne_nat_nat.expr_cmp_ne_nat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_nat_rat', async () => {
    await expr_cmp_ne_nat_rat.expr_cmp_ne_nat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_ne_nat_rat.expr_cmp_ne_nat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_ne_nat_rat.expr_cmp_ne_nat_rat.exec({ as: alice })

    const res_after = await expr_cmp_ne_nat_rat.expr_cmp_ne_nat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_rat_int', async () => {
    await expr_cmp_ne_rat_int.expr_cmp_ne_rat_int.deploy({ as: alice })

    const res_before = await expr_cmp_ne_rat_int.expr_cmp_ne_rat_int.get_res()
    assert(res_before == false)

    await expr_cmp_ne_rat_int.expr_cmp_ne_rat_int.exec({ as: alice })

    const res_after = await expr_cmp_ne_rat_int.expr_cmp_ne_rat_int.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_rat_nat', async () => {
    await expr_cmp_ne_rat_nat.expr_cmp_ne_rat_nat.deploy({ as: alice })

    const res_before = await expr_cmp_ne_rat_nat.expr_cmp_ne_rat_nat.get_res()
    assert(res_before == false)

    await expr_cmp_ne_rat_nat.expr_cmp_ne_rat_nat.exec({ as: alice })

    const res_after = await expr_cmp_ne_rat_nat.expr_cmp_ne_rat_nat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_rat_rat', async () => {
    await expr_cmp_ne_rat_rat.expr_cmp_ne_rat_rat.deploy({ as: alice })

    const res_before = await expr_cmp_ne_rat_rat.expr_cmp_ne_rat_rat.get_res()
    assert(res_before == false)

    await expr_cmp_ne_rat_rat.expr_cmp_ne_rat_rat.exec({ as: alice })

    const res_after = await expr_cmp_ne_rat_rat.expr_cmp_ne_rat_rat.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_str_str', async () => {
    await expr_cmp_ne_str_str.expr_cmp_ne_str_str.deploy({ as: alice })

    const res_before = await expr_cmp_ne_str_str.expr_cmp_ne_str_str.get_res()
    assert(res_before == false)

    await expr_cmp_ne_str_str.expr_cmp_ne_str_str.exec({ as: alice })

    const res_after = await expr_cmp_ne_str_str.expr_cmp_ne_str_str.get_res()
    assert(res_after == true)
  })

  it('expr_cmp_ne_tez_tez', async () => {
    await expr_cmp_ne_tez_tez.expr_cmp_ne_tez_tez.deploy({ as: alice })

    const res_before = await expr_cmp_ne_tez_tez.expr_cmp_ne_tez_tez.get_res()
    assert(res_before == false)

    await expr_cmp_ne_tez_tez.expr_cmp_ne_tez_tez.exec({ as: alice })

    const res_after = await expr_cmp_ne_tez_tez.expr_cmp_ne_tez_tez.get_res()
    assert(res_after == true)
  })

  it('expr_control_fold', async () => {
    await expr_control_fold.expr_control_fold.deploy({ as: alice })

    const res_before = await expr_control_fold.expr_control_fold.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_control_fold.expr_control_fold.exec({ as: alice })

    const res_after = await expr_control_fold.expr_control_fold.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_control_if_else_int_int', async () => {
    await expr_control_if_else_int_int.expr_control_if_else_int_int.deploy({ as: alice })

    const res_before = await expr_control_if_else_int_int.expr_control_if_else_int_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_control_if_else_int_int.expr_control_if_else_int_int.exec({ as: alice })

    const res_after = await expr_control_if_else_int_int.expr_control_if_else_int_int.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_control_if_else_int_nat', async () => {
    await expr_control_if_else_int_nat.expr_control_if_else_int_nat.deploy({ as: alice })

    const res_before = await expr_control_if_else_int_nat.expr_control_if_else_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_control_if_else_int_nat.expr_control_if_else_int_nat.exec({ as: alice })

    const res_after = await expr_control_if_else_int_nat.expr_control_if_else_int_nat.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_control_if_else_int_rat', async () => {
    await expr_control_if_else_int_rat.expr_control_if_else_int_rat.deploy({ as: alice })

    const res_before = await expr_control_if_else_int_rat.expr_control_if_else_int_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_control_if_else_int_rat.expr_control_if_else_int_rat.exec({ as: alice })

    const res_after = await expr_control_if_else_int_rat.expr_control_if_else_int_rat.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('expr_control_if_else_nat_int', async () => {
    await expr_control_if_else_nat_int.expr_control_if_else_nat_int.deploy({ as: alice })

    const res_before = await expr_control_if_else_nat_int.expr_control_if_else_nat_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_control_if_else_nat_int.expr_control_if_else_nat_int.exec({ as: alice })

    const res_after = await expr_control_if_else_nat_int.expr_control_if_else_nat_int.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_control_if_else_nat_nat', async () => {
    await expr_control_if_else_nat_nat.expr_control_if_else_nat_nat.deploy({ as: alice })

    const res_before = await expr_control_if_else_nat_nat.expr_control_if_else_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_control_if_else_nat_nat.expr_control_if_else_nat_nat.exec({ as: alice })

    const res_after = await expr_control_if_else_nat_nat.expr_control_if_else_nat_nat.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_control_if_else_nat_rat', async () => {
    await expr_control_if_else_nat_rat.expr_control_if_else_nat_rat.deploy({ as: alice })

    const res_before = await expr_control_if_else_nat_rat.expr_control_if_else_nat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_control_if_else_nat_rat.expr_control_if_else_nat_rat.exec({ as: alice })

    const res_after = await expr_control_if_else_nat_rat.expr_control_if_else_nat_rat.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('expr_control_if_else_rat_int', async () => {
    await expr_control_if_else_rat_int.expr_control_if_else_rat_int.deploy({ as: alice })

    const res_before = await expr_control_if_else_rat_int.expr_control_if_else_rat_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_control_if_else_rat_int.expr_control_if_else_rat_int.exec({ as: alice })

    const res_after = await expr_control_if_else_rat_int.expr_control_if_else_rat_int.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_control_if_else_rat_nat', async () => {
    await expr_control_if_else_rat_nat.expr_control_if_else_rat_nat.deploy({ as: alice })

    const res_before = await expr_control_if_else_rat_nat.expr_control_if_else_rat_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_control_if_else_rat_nat.expr_control_if_else_rat_nat.exec({ as: alice })

    const res_after = await expr_control_if_else_rat_nat.expr_control_if_else_rat_nat.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_control_if_else_rat_rat', async () => {
    await expr_control_if_else_rat_rat.expr_control_if_else_rat_rat.deploy({ as: alice })

    const res_before = await expr_control_if_else_rat_rat.expr_control_if_else_rat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_control_if_else_rat_rat.expr_control_if_else_rat_rat.exec({ as: alice })

    const res_after = await expr_control_if_else_rat_rat.expr_control_if_else_rat_rat.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_control_match_list', async () => {
    await expr_control_match_list.expr_control_match_list.deploy({ as: alice })

    const res_before = await expr_control_match_list.expr_control_match_list.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_control_match_list.expr_control_match_list.exec({ as: alice })

    const res_after = await expr_control_match_list.expr_control_match_list.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_control_match_option', async () => {
    await expr_control_match_option.expr_control_match_option.deploy({ as: alice })

    const res_before = await expr_control_match_option.expr_control_match_option.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_control_match_option.expr_control_match_option.exec({ as: alice })

    const res_after = await expr_control_match_option.expr_control_match_option.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_control_match_or', async () => {
    await expr_control_match_or.expr_control_match_or.deploy({ as: alice })

    const a_before = await expr_control_match_or.expr_control_match_or.get_a()
    assert(a_before.equals(new Nat(0)))
    const b_before = await expr_control_match_or.expr_control_match_or.get_b()
    assert(b_before.equals(new Int(0)))

    await expr_control_match_or.expr_control_match_or.exec({ as: alice })

    const a_after = await expr_control_match_or.expr_control_match_or.get_a()
    assert(a_after.equals(new Nat(2)))
    const b_after = await expr_control_match_or.expr_control_match_or.get_b()
    assert(b_after.equals(new Int(3)))
  })

  it('expr_control_matchwith', async () => {
    await expr_control_matchwith.expr_control_matchwith.deploy({ as: alice })

    const res_before = await expr_control_matchwith.expr_control_matchwith.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_control_matchwith.expr_control_matchwith.exec({ as: alice })

    const res_after = await expr_control_matchwith.expr_control_matchwith.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_control_matchwith_with_int_rat', async () => {
    await expr_control_matchwith_with_int_rat.expr_control_matchwith_with_int_rat.deploy({ as: alice })

    const res_before = await expr_control_matchwith_with_int_rat.expr_control_matchwith_with_int_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_control_matchwith_with_int_rat.expr_control_matchwith_with_int_rat.exec({ as: alice })

    const res_after = await expr_control_matchwith_with_int_rat.expr_control_matchwith_with_int_rat.get_res()
    assert(res_after.equals(new Rational(3)))
  })

  it('expr_control_matchwith_with_nat_int', async () => {
    await expr_control_matchwith_with_nat_int.expr_control_matchwith_with_nat_int.deploy({ as: alice })

    const res_before = await expr_control_matchwith_with_nat_int.expr_control_matchwith_with_nat_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_control_matchwith_with_nat_int.expr_control_matchwith_with_nat_int.exec({ as: alice })

    const res_after = await expr_control_matchwith_with_nat_int.expr_control_matchwith_with_nat_int.get_res()
    assert(res_after.equals(new Int(3)))
  })

  it('expr_control_matchwith_with_nat_rat', async () => {
    await expr_control_matchwith_with_nat_rat.expr_control_matchwith_with_nat_rat.deploy({ as: alice })

    const res_before = await expr_control_matchwith_with_nat_rat.expr_control_matchwith_with_nat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_control_matchwith_with_nat_rat.expr_control_matchwith_with_nat_rat.exec({ as: alice })

    const res_after = await expr_control_matchwith_with_nat_rat.expr_control_matchwith_with_nat_rat.get_res()
    assert(res_after.equals(new Rational(3)))
  })

  it('expr_cst_balance', async () => {
    await expr_cst_balance.expr_cst_balance.deploy({ amount: new Tez(1), as: alice })

    const res_before = await expr_cst_balance.expr_cst_balance.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_cst_balance.expr_cst_balance.exec({ as: alice })

    const res_after = await expr_cst_balance.expr_cst_balance.get_res()
    assert(res_after.equals(new Tez(1)))
  })

  it('expr_cst_caller', async () => {
    await expr_cst_caller.expr_cst_caller.deploy({ as: alice })

    const res_before = await expr_cst_caller.expr_cst_caller.get_res()
    assert(res_before.equals(new Address("tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg")))

    await expr_cst_caller.expr_cst_caller.exec({ as: alice })

    const res_after = await expr_cst_caller.expr_cst_caller.get_res()
    assert(res_after.equals(alice.get_address()))
  })

  it('expr_cst_level', async () => {
    await expr_cst_level.expr_cst_level.deploy({ as: alice })

    const level = await get_mockup_level()
    const res_before = await expr_cst_level.expr_cst_level.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_cst_level.expr_cst_level.exec({ as: alice })

    const res_after = await expr_cst_level.expr_cst_level.get_res()
    assert(res_after.equals(new Nat(level).plus(new Nat(1))))
  })

  it('expr_cst_min_block_time', async () => {
    await expr_cst_min_block_time.expr_cst_min_block_time.deploy({ as: alice })

    const res_before = await expr_cst_min_block_time.expr_cst_min_block_time.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_cst_min_block_time.expr_cst_min_block_time.exec({ as: alice })

    const res_after = await expr_cst_min_block_time.expr_cst_min_block_time.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_cst_now', async () => {
    await expr_cst_now.expr_cst_now.deploy({ as: alice })

    const now = get_mockup_now();
    const res_before = await expr_cst_now.expr_cst_now.get_res()
    assert(res_before.toISOString() == new Date("1970-01-01").toISOString())

    await expr_cst_now.expr_cst_now.exec({ as: alice })

    const res_after = await expr_cst_now.expr_cst_now.get_res()
    assert(res_after.toISOString() == now.toISOString())
  })

  it('expr_cst_self_address', async () => {
    await expr_cst_self_address.expr_cst_self_address.deploy({ as: alice })

    const res_before = await expr_cst_self_address.expr_cst_self_address.get_res()
    assert(res_before.equals(new Address("tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg")))

    await expr_cst_self_address.expr_cst_self_address.exec({ as: alice })

    const res_after = await expr_cst_self_address.expr_cst_self_address.get_res()
    assert(res_after.equals(expr_cst_self_address.expr_cst_self_address.get_address()))
  })

  it('expr_cst_self_chain_id', async () => {
    await expr_cst_self_chain_id.expr_cst_self_chain_id.deploy({ as: alice })

    const chain_id = await get_chain_id();
    const res_before = await expr_cst_self_chain_id.expr_cst_self_chain_id.get_res()
    assert(res_before.equals(new Chain_id("NetXdQprcVkpaWU")))

    await expr_cst_self_chain_id.expr_cst_self_chain_id.exec({ as: alice })

    const res_after = await expr_cst_self_chain_id.expr_cst_self_chain_id.get_res()
    assert(res_after.equals(chain_id))
  })

  it('expr_cst_source', async () => {
    await expr_cst_source.expr_cst_source.deploy({ as: alice })

    const res_before = await expr_cst_source.expr_cst_source.get_res()
    assert(res_before.equals(new Address("tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg")))

    await expr_cst_source.expr_cst_source.exec({ as: alice })

    const res_after = await expr_cst_source.expr_cst_source.get_res()
    assert(res_after.equals(alice.get_address()))
  })

  it('expr_cst_total_voting_power', async () => {
    await expr_cst_total_voting_power.expr_cst_total_voting_power.deploy({ as: alice })

    const res_before = await expr_cst_total_voting_power.expr_cst_total_voting_power.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_cst_total_voting_power.expr_cst_total_voting_power.exec({ as: alice })

    const res_after = await expr_cst_total_voting_power.expr_cst_total_voting_power.get_res()
    assert(res_after.equals(new Nat("20000000000000")))
  })

  it('expr_cst_transferred', async () => {
    await expr_cst_transferred.expr_cst_transferred.deploy({ as: alice })

    const res_before = await expr_cst_transferred.expr_cst_transferred.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_cst_transferred.expr_cst_transferred.exec({ amount: new Tez(1), as: alice })

    const res_after = await expr_cst_transferred.expr_cst_transferred.get_res()
    assert(res_after.equals(new Tez(1)))
  })

  it('expr_fail_some_none', async () => {
    await expr_fail_some_none.expr_fail_some_none.deploy({ as: alice })

    await expr_fail_some_none.expr_fail_some_none.exec({ as: alice })
  })

  it('expr_fail_some_some', async () => {
    await expr_fail_some_some.expr_fail_some_some.deploy({ as: alice })

    await expect_to_fail(async () => {
      await expr_fail_some_some.expr_fail_some_some.exec({ as: bob });
    }, { "string": "ERROR" });

  })

  it('expr_fun_abs_int', async () => {
    await expr_fun_abs_int.expr_fun_abs_int.deploy({ as: alice })

    const res_before = await expr_fun_abs_int.expr_fun_abs_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_fun_abs_int.expr_fun_abs_int.exec({ as: alice })

    const res_after = await expr_fun_abs_int.expr_fun_abs_int.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_fun_abs_nat', async () => {
    await expr_fun_abs_nat.expr_fun_abs_nat.deploy({ as: alice })

    const res_before = await expr_fun_abs_nat.expr_fun_abs_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_fun_abs_nat.expr_fun_abs_nat.exec({ as: alice })

    const res_after = await expr_fun_abs_nat.expr_fun_abs_nat.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_fun_abs_rat', async () => {
    await expr_fun_abs_rat.expr_fun_abs_rat.deploy({ as: alice })

    const rn_before = await expr_fun_abs_rat.expr_fun_abs_rat.get_rn()
    assert(rn_before.equals(new Rational(0)))
    const rp_before = await expr_fun_abs_rat.expr_fun_abs_rat.get_rp()
    assert(rp_before.equals(new Rational(0)))

    await expr_fun_abs_rat.expr_fun_abs_rat.exec({ as: alice })

    const rn_after = await expr_fun_abs_rat.expr_fun_abs_rat.get_rn()
    assert(rn_after.equals(new Rational(0.5)))
    const rp_after = await expr_fun_abs_rat.expr_fun_abs_rat.get_rp()
    assert(rp_after.equals(new Rational(0.5)))
  })

  it('expr_fun_address_to_contract', async () => {
    await expr_fun_address_to_contract.expr_fun_address_to_contract.deploy({ as: alice })

    const res_before = await expr_fun_address_to_contract.expr_fun_address_to_contract.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_fun_address_to_contract.expr_fun_address_to_contract.exec({ as: alice })

    const res_after = await expr_fun_address_to_contract.expr_fun_address_to_contract.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_fun_address_to_contract_unit', async () => {
    await expr_fun_address_to_contract_unit.expr_fun_address_to_contract_unit.deploy({ amount: new Tez(1), as: alice })

    await expr_fun_address_to_contract_unit.expr_fun_address_to_contract_unit.exec(alice.get_address(), { as: alice })
  })

  it('expr_fun_bytes_to_int', async () => {
    await expr_fun_bytes_to_int.expr_fun_bytes_to_int.deploy({ as: alice })

    const res_before = await expr_fun_bytes_to_int.expr_fun_bytes_to_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_fun_bytes_to_int.expr_fun_bytes_to_int.exec(new Bytes("02"), { as: alice })

    const res_after = await expr_fun_bytes_to_int.expr_fun_bytes_to_int.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_fun_bytes_to_nat', async () => {
    await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.deploy({ as: alice })
    const res_init = await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.get_res();
    assert(res_init.equals(new Nat(0)), "Invalid Value")
    await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.exec(new Bytes(""), { as: alice })
    const res_empty = await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.get_res();
    assert(res_empty.equals(new Nat(0)), "Invalid Value")
    await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.exec(new Bytes("00"), { as: alice })
    const res_00 = await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.get_res();
    assert(res_00.equals(new Nat(0)), "Invalid Value")
    await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.exec(new Bytes("86"), { as: alice })
    const res_86 = await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.get_res();
    assert(res_86.equals(new Nat(134)), "Invalid Value")
    await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.exec(new Bytes("abcd"), { as: alice })
    const res_abcd = await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.get_res();
    assert(res_abcd.equals(new Nat(new BigNumber("43981"))), "Invalid Value")
    await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.exec(new Bytes("123456789abcdef0"), { as: alice })
    const res_123456789abcdef0 = await expr_fun_bytes_to_nat.expr_fun_bytes_to_nat.get_res();
    assert(res_123456789abcdef0.equals(new Nat(new BigNumber("1311768467463790320"))), "Invalid Value")
  })

  it('expr_fun_ceil', async () => {
    await expr_fun_ceil.expr_fun_ceil.deploy({ as: alice })

    const r0_before = await expr_fun_ceil.expr_fun_ceil.get_r0()
    assert(r0_before.equals(new Int(0)))
    const r1_before = await expr_fun_ceil.expr_fun_ceil.get_r1()
    assert(r1_before.equals(new Int(0)))

    await expr_fun_ceil.expr_fun_ceil.exec({ as: alice })

    const r0_after = await expr_fun_ceil.expr_fun_ceil.get_r0()
    assert(r0_after.equals(new Int(2)))
    const r1_after = await expr_fun_ceil.expr_fun_ceil.get_r1()
    assert(r1_after.equals(new Int(-1)))
  })

  it('expr_fun_concat_byt', async () => {
    await expr_fun_concat_byt.expr_fun_concat_byt.deploy({ as: alice })

    const res_before = await expr_fun_concat_byt.expr_fun_concat_byt.get_res()
    assert(res_before.equals(new Bytes("00")))

    await expr_fun_concat_byt.expr_fun_concat_byt.exec({ as: alice })

    const res_after = await expr_fun_concat_byt.expr_fun_concat_byt.get_res()
    assert(res_after.equals(new Bytes("12ef")))
  })

  it('expr_fun_concat_list_byt', async () => {
    await expr_fun_concat_list_byt.expr_fun_concat_list_byt.deploy({ as: alice })

    const res_before = await expr_fun_concat_list_byt.expr_fun_concat_list_byt.get_res()
    assert(res_before.equals(new Bytes("00")))

    await expr_fun_concat_list_byt.expr_fun_concat_list_byt.exec({ as: alice })

    const res_after = await expr_fun_concat_list_byt.expr_fun_concat_list_byt.get_res()
    assert(res_after.equals(new Bytes("12ef")))
  })

  it('expr_fun_concat_list_str', async () => {
    await expr_fun_concat_list_str.expr_fun_concat_list_str.deploy({ as: alice })

    const res_before = await expr_fun_concat_list_str.expr_fun_concat_list_str.get_res()
    assert(res_before == "")

    await expr_fun_concat_list_str.expr_fun_concat_list_str.exec({ as: alice })

    const res_after = await expr_fun_concat_list_str.expr_fun_concat_list_str.get_res()
    assert(res_after == "abcdef")
  })

  it('expr_fun_concat_str', async () => {
    await expr_fun_concat_str.expr_fun_concat_str.deploy({ as: alice })

    const res_before = await expr_fun_concat_str.expr_fun_concat_str.get_res()
    assert(res_before == "")

    await expr_fun_concat_str.expr_fun_concat_str.exec({ as: alice })

    const res_after = await expr_fun_concat_str.expr_fun_concat_str.get_res()
    assert(res_after == "abcdef")
  })

  it('expr_fun_exp_horner', async () => {
    await expr_fun_exp_horner.expr_fun_exp_horner.deploy({ as: alice })

    const res_before = await expr_fun_exp_horner.expr_fun_exp_horner.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_exp_horner.expr_fun_exp_horner.exec(new Rational(0.55), new Nat(20), { as: alice })

    const res_0 = await expr_fun_exp_horner.expr_fun_exp_horner.get_res()
    assert(res_0.toString() == "1.73325301786739523682")
  })

  it('expr_fun_floor', async () => {
    await expr_fun_floor.expr_fun_floor.deploy({ as: alice })

    const r0_before = await expr_fun_floor.expr_fun_floor.get_r0()
    assert(r0_before.equals(new Int(0)))
    const r1_before = await expr_fun_floor.expr_fun_floor.get_r1()
    assert(r1_before.equals(new Int(0)))

    await expr_fun_floor.expr_fun_floor.exec({ as: alice })

    const r0_after = await expr_fun_floor.expr_fun_floor.get_r0()
    assert(r0_after.equals(new Int(1)))
    const r1_after = await expr_fun_floor.expr_fun_floor.get_r1()
    assert(r1_after.equals(new Int(-2)))
  })

  it('expr_fun_get_denominator', async () => {
    await expr_fun_get_denominator.expr_fun_get_denominator.deploy({ as: alice })
    const v = new Rational(1, new BigNumber(2));
    const res_before = await expr_fun_get_denominator.expr_fun_get_denominator.get_res();
    assert(res_before.equals(new Nat(0)), "Invalid Value")
    await expr_fun_get_denominator.expr_fun_get_denominator.exec(v, { as: alice })
    const res_after = await expr_fun_get_denominator.expr_fun_get_denominator.get_res();
    assert(res_after.equals(new Nat(2)), "Invalid Value")
  })

  it('expr_fun_get_numerator', async () => {
    await expr_fun_get_numerator.expr_fun_get_numerator.deploy({ as: alice })
    const v = new Rational(1, new BigNumber(2));
    const res_before = await expr_fun_get_numerator.expr_fun_get_numerator.get_res();
    assert(res_before.equals(new Int(0)), "Invalid Value")
    await expr_fun_get_numerator.expr_fun_get_numerator.exec(v, { as: alice })
    const res_after = await expr_fun_get_numerator.expr_fun_get_numerator.get_res();
    assert(res_after.equals(new Int(1)), "Invalid Value")
  })

  it('expr_fun_int_to_bytes', async () => {
    await expr_fun_int_to_bytes.expr_fun_int_to_bytes.deploy({ as: alice })

    const res_before = await expr_fun_int_to_bytes.expr_fun_int_to_bytes.get_res()
    assert(res_before.equals(new Bytes("")))

    await expr_fun_int_to_bytes.expr_fun_int_to_bytes.exec(new Int(2), { as: alice })

    const res_after = await expr_fun_int_to_bytes.expr_fun_int_to_bytes.get_res()
    assert(res_after.equals(new Bytes("02")))
  })

  it('expr_fun_int_to_nat', async () => {
    await expr_fun_int_to_nat.expr_fun_int_to_nat.deploy({ as: alice })

    const res_before = await expr_fun_int_to_nat.expr_fun_int_to_nat.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_int_to_nat.expr_fun_int_to_nat.exec({ as: alice })

    const res_after = await expr_fun_int_to_nat.expr_fun_int_to_nat.get_res()
    assert(res_after.equals(Option.Some(new Nat(2))))
  })

  it('expr_fun_key_hash_to_contract', async () => {
    await expr_fun_key_hash_to_contract.expr_fun_key_hash_to_contract.deploy({ amount: new Tez(1), as: alice })

    await expr_fun_key_hash_to_contract.expr_fun_key_hash_to_contract.exec(alice.get_public_key(), { as: alice })
  })

  it('expr_fun_length_bytes', async () => {
    await expr_fun_length_bytes.expr_fun_length_bytes.deploy({ as: alice })

    const res_before = await expr_fun_length_bytes.expr_fun_length_bytes.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_fun_length_bytes.expr_fun_length_bytes.exec({ as: alice })

    const res_after = await expr_fun_length_bytes.expr_fun_length_bytes.get_res()
    assert(res_after.equals(new Nat(4)))
  })

  it('expr_fun_length_str', async () => {
    await expr_fun_length_str.expr_fun_length_str.deploy({ as: alice })

    const res_before = await expr_fun_length_str.expr_fun_length_str.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_fun_length_str.expr_fun_length_str.exec({ as: alice })

    const res_after = await expr_fun_length_str.expr_fun_length_str.get_res()
    assert(res_after.equals(new Nat(6)))
  })

  it('expr_fun_make_event', async () => {
    await expr_fun_make_event.expr_fun_make_event.deploy({ as: alice })

    const ret = await expr_fun_make_event.expr_fun_make_event.exec({ as: alice });

    assert(ret.events.length == 1)
    assert(ret.events[0].from.equals(expr_fun_make_event.expr_fun_make_event.get_address()))
    assert(JSON.stringify(ret.events[0].type) == '{"prim":"nat"}')
    assert(ret.events[0].tag == "sample")
    assert(JSON.stringify(ret.events[0].payload) == '{"int":"2"}')
  })

  it('expr_fun_make_operation', async () => {
    await expr_fun_make_operation.expr_fun_make_operation.deploy({ amount: new Tez(1), as: alice })

    const balance_before = await alice.get_balance();

    await expr_fun_make_operation.expr_fun_make_operation.exec(alice.get_address(), { as: bob });

    const balance_after = await alice.get_balance();
    assert(balance_after.to_big_number().minus(balance_before.to_big_number()).eq(new Tez(1).to_big_number()))
  })

  it('expr_fun_max_date', async () => {
    await expr_fun_max_date.expr_fun_max_date.deploy({ as: alice })

    const res_before = await expr_fun_max_date.expr_fun_max_date.get_res()
    assert(res_before.toISOString() == '2020-01-01T00:00:00.000Z')

    await expr_fun_max_date.expr_fun_max_date.exec({ as: alice })

    const res_after = await expr_fun_max_date.expr_fun_max_date.get_res()
    assert(res_after.toISOString() == '2020-01-02T00:00:00.000Z')
  })

  it('expr_fun_max_dur', async () => {
    await expr_fun_max_dur.expr_fun_max_dur.deploy({ as: alice })

    const res_before = await expr_fun_max_dur.expr_fun_max_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_fun_max_dur.expr_fun_max_dur.exec({ as: alice })

    const res_after = await expr_fun_max_dur.expr_fun_max_dur.get_res()
    assert(res_after.equals(new Duration("1h")))
  })

  it('expr_fun_max_int_int', async () => {
    await expr_fun_max_int_int.expr_fun_max_int_int.deploy({ as: alice })

    const res_before = await expr_fun_max_int_int.expr_fun_max_int_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_fun_max_int_int.expr_fun_max_int_int.exec({ as: alice })

    const res_after = await expr_fun_max_int_int.expr_fun_max_int_int.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_fun_max_int_nat', async () => {
    await expr_fun_max_int_nat.expr_fun_max_int_nat.deploy({ as: alice })

    const res_before = await expr_fun_max_int_nat.expr_fun_max_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_fun_max_int_nat.expr_fun_max_int_nat.exec({ as: alice })

    const res_after = await expr_fun_max_int_nat.expr_fun_max_int_nat.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_fun_max_int_rat', async () => {
    await expr_fun_max_int_rat.expr_fun_max_int_rat.deploy({ as: alice })

    const res_before = await expr_fun_max_int_rat.expr_fun_max_int_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_max_int_rat.expr_fun_max_int_rat.exec({ as: alice })

    const res_after = await expr_fun_max_int_rat.expr_fun_max_int_rat.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('expr_fun_max_nat_int', async () => {
    await expr_fun_max_nat_int.expr_fun_max_nat_int.deploy({ as: alice })

    const res_before = await expr_fun_max_nat_int.expr_fun_max_nat_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_fun_max_nat_int.expr_fun_max_nat_int.exec({ as: alice })

    const res_after = await expr_fun_max_nat_int.expr_fun_max_nat_int.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('expr_fun_max_nat_nat', async () => {
    await expr_fun_max_nat_nat.expr_fun_max_nat_nat.deploy({ as: alice })

    const res_before = await expr_fun_max_nat_nat.expr_fun_max_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_fun_max_nat_nat.expr_fun_max_nat_nat.exec({ as: alice })

    const res_after = await expr_fun_max_nat_nat.expr_fun_max_nat_nat.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('expr_fun_max_nat_rat', async () => {
    await expr_fun_max_nat_rat.expr_fun_max_nat_rat.deploy({ as: alice })

    const res_before = await expr_fun_max_nat_rat.expr_fun_max_nat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_max_nat_rat.expr_fun_max_nat_rat.exec({ as: alice })

    const res_after = await expr_fun_max_nat_rat.expr_fun_max_nat_rat.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('expr_fun_max_rat_int', async () => {
    await expr_fun_max_rat_int.expr_fun_max_rat_int.deploy({ as: alice })

    const res_before = await expr_fun_max_rat_int.expr_fun_max_rat_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_max_rat_int.expr_fun_max_rat_int.exec({ as: alice })

    const res_after = await expr_fun_max_rat_int.expr_fun_max_rat_int.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('expr_fun_max_rat_nat', async () => {
    await expr_fun_max_rat_nat.expr_fun_max_rat_nat.deploy({ as: alice })

    const res_before = await expr_fun_max_rat_nat.expr_fun_max_rat_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_max_rat_nat.expr_fun_max_rat_nat.exec({ as: alice })

    const res_after = await expr_fun_max_rat_nat.expr_fun_max_rat_nat.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('expr_fun_max_rat_rat', async () => {
    await expr_fun_max_rat_rat.expr_fun_max_rat_rat.deploy({ as: alice })

    const res_before = await expr_fun_max_rat_rat.expr_fun_max_rat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_max_rat_rat.expr_fun_max_rat_rat.exec({ as: alice })

    const res_after = await expr_fun_max_rat_rat.expr_fun_max_rat_rat.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_fun_max_tez', async () => {
    await expr_fun_max_tez.expr_fun_max_tez.deploy({ as: alice })

    const res_before = await expr_fun_max_tez.expr_fun_max_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_fun_max_tez.expr_fun_max_tez.exec({ as: alice })

    const res_after = await expr_fun_max_tez.expr_fun_max_tez.get_res()
    assert(res_after.equals(new Tez(2)))
  })

  it('expr_fun_min_date', async () => {
    await expr_fun_min_date.expr_fun_min_date.deploy({ as: alice })

    const res_before = await expr_fun_min_date.expr_fun_min_date.get_res()
    assert(res_before.toISOString() == '2020-01-01T00:00:00.000Z')

    await expr_fun_min_date.expr_fun_min_date.exec({ as: alice })

    const res_after = await expr_fun_min_date.expr_fun_min_date.get_res()
    assert(res_after.toISOString() == '2019-01-01T00:00:00.000Z')
  })

  it('expr_fun_min_dur', async () => {
    await expr_fun_min_dur.expr_fun_min_dur.deploy({ as: alice })

    const res_before = await expr_fun_min_dur.expr_fun_min_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_fun_min_dur.expr_fun_min_dur.exec({ as: alice })

    const res_after = await expr_fun_min_dur.expr_fun_min_dur.get_res()
    assert(res_after.equals(new Duration("1s")))
  })

  it('expr_fun_min_int_int', async () => {
    await expr_fun_min_int_int.expr_fun_min_int_int.deploy({ as: alice })

    const res_before = await expr_fun_min_int_int.expr_fun_min_int_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_fun_min_int_int.expr_fun_min_int_int.exec({ as: alice })

    const res_after = await expr_fun_min_int_int.expr_fun_min_int_int.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_fun_min_int_nat', async () => {
    await expr_fun_min_int_nat.expr_fun_min_int_nat.deploy({ as: alice })

    const res_before = await expr_fun_min_int_nat.expr_fun_min_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_fun_min_int_nat.expr_fun_min_int_nat.exec({ as: alice })

    const res_after = await expr_fun_min_int_nat.expr_fun_min_int_nat.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_fun_min_int_rat', async () => {
    await expr_fun_min_int_rat.expr_fun_min_int_rat.deploy({ as: alice })

    const res_before = await expr_fun_min_int_rat.expr_fun_min_int_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_min_int_rat.expr_fun_min_int_rat.exec({ as: alice })

    const res_after = await expr_fun_min_int_rat.expr_fun_min_int_rat.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_fun_min_nat_int', async () => {
    await expr_fun_min_nat_int.expr_fun_min_nat_int.deploy({ as: alice })

    const res_before = await expr_fun_min_nat_int.expr_fun_min_nat_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_fun_min_nat_int.expr_fun_min_nat_int.exec({ as: alice })

    const res_after = await expr_fun_min_nat_int.expr_fun_min_nat_int.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_fun_min_nat_nat', async () => {
    await expr_fun_min_nat_nat.expr_fun_min_nat_nat.deploy({ as: alice })

    const res_before = await expr_fun_min_nat_nat.expr_fun_min_nat_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_fun_min_nat_nat.expr_fun_min_nat_nat.exec({ as: alice })

    const res_after = await expr_fun_min_nat_nat.expr_fun_min_nat_nat.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_fun_min_nat_rat', async () => {
    await expr_fun_min_nat_rat.expr_fun_min_nat_rat.deploy({ as: alice })

    const res_before = await expr_fun_min_nat_rat.expr_fun_min_nat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_min_nat_rat.expr_fun_min_nat_rat.exec({ as: alice })

    const res_after = await expr_fun_min_nat_rat.expr_fun_min_nat_rat.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_fun_min_rat_int', async () => {
    await expr_fun_min_rat_int.expr_fun_min_rat_int.deploy({ as: alice })

    const res_before = await expr_fun_min_rat_int.expr_fun_min_rat_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_min_rat_int.expr_fun_min_rat_int.exec({ as: alice })

    const res_after = await expr_fun_min_rat_int.expr_fun_min_rat_int.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_fun_min_rat_nat', async () => {
    await expr_fun_min_rat_nat.expr_fun_min_rat_nat.deploy({ as: alice })

    const res_before = await expr_fun_min_rat_nat.expr_fun_min_rat_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_min_rat_nat.expr_fun_min_rat_nat.exec({ as: alice })

    const res_after = await expr_fun_min_rat_nat.expr_fun_min_rat_nat.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_fun_min_rat_rat', async () => {
    await expr_fun_min_rat_rat.expr_fun_min_rat_rat.deploy({ as: alice })

    const res_before = await expr_fun_min_rat_rat.expr_fun_min_rat_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_fun_min_rat_rat.expr_fun_min_rat_rat.exec({ as: alice })

    const res_after = await expr_fun_min_rat_rat.expr_fun_min_rat_rat.get_res()
    assert(res_after.equals(new Rational(0.3)))
  })

  it('expr_fun_min_tez', async () => {
    await expr_fun_min_tez.expr_fun_min_tez.deploy({ as: alice })

    const res_before = await expr_fun_min_tez.expr_fun_min_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_fun_min_tez.expr_fun_min_tez.exec({ as: alice })

    const res_after = await expr_fun_min_tez.expr_fun_min_tez.get_res()
    assert(res_after.equals(new Tez(1)))
  })

  it('expr_fun_nat_to_bytes', async () => {
    await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.deploy({ as: alice })
    const res_init = await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.get_res();
    assert(res_init.equals(new Bytes("")), "Invalid Value")
    await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.exec(new Nat(0), { as: alice })
    const res_zero = await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.get_res();
    assert(res_zero.equals(new Bytes("")), "Invalid Value")
    await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.exec(new Nat(134), { as: alice })
    const res_86 = await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.get_res();
    assert(res_86.equals(new Bytes("86")), "Invalid Value")
    await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.exec(new Nat(new BigNumber("43981")), { as: alice })
    const res_abcd = await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.get_res();
    assert(res_abcd.equals(new Bytes("abcd")), "Invalid Value")
    await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.exec(new Nat(new BigNumber("1311768467463790320")), { as: alice })
    const res_123456789abcdef0 = await expr_fun_nat_to_bytes.expr_fun_nat_to_bytes.get_res();
    assert(res_123456789abcdef0.equals(new Bytes("123456789abcdef0")), "Invalid Value")
  })

  it('expr_fun_nat_to_string', async () => {
    await expr_fun_nat_to_string.expr_fun_nat_to_string.deploy({ as: alice })

    const res_before = await expr_fun_nat_to_string.expr_fun_nat_to_string.get_res()
    assert(res_before == "")

    await expr_fun_nat_to_string.expr_fun_nat_to_string.exec(new Nat(42), { as: alice })

    const res_42 = await expr_fun_nat_to_string.expr_fun_nat_to_string.get_res()
    assert(res_42 == "42")

    await expr_fun_nat_to_string.expr_fun_nat_to_string.exec(new Nat(0), { as: alice })

    const res_0 = await expr_fun_nat_to_string.expr_fun_nat_to_string.get_res()
    assert(res_0 == "0")
  })

  it('expr_fun_opt_get_some', async () => {
    await expr_fun_opt_get_some.expr_fun_opt_get_some.deploy({ as: alice })

    const res_before = await expr_fun_opt_get_some.expr_fun_opt_get_some.get_res()
    assert(res_before == false)

    await expr_fun_opt_get_some.expr_fun_opt_get_some.exec({ as: alice })

    const res_after = await expr_fun_opt_get_some.expr_fun_opt_get_some.get_res()
    assert(res_after == true)
  })

  it('expr_fun_opt_is_none', async () => {
    await expr_fun_opt_is_none.expr_fun_opt_is_none.deploy({ as: alice })

    const res_before = await expr_fun_opt_is_none.expr_fun_opt_is_none.get_res()
    assert(res_before == false)

    await expr_fun_opt_is_none.expr_fun_opt_is_none.exec({ as: alice })

    const res_after = await expr_fun_opt_is_none.expr_fun_opt_is_none.get_res()
    assert(res_after == true)
  })

  it('expr_fun_opt_is_some', async () => {
    await expr_fun_opt_is_some.expr_fun_opt_is_some.deploy({ as: alice })

    const res_before = await expr_fun_opt_is_some.expr_fun_opt_is_some.get_res()
    assert(res_before == false)

    await expr_fun_opt_is_some.expr_fun_opt_is_some.exec({ as: alice })

    const res_after = await expr_fun_opt_is_some.expr_fun_opt_is_some.get_res()
    assert(res_after == true)
  })

  it('expr_fun_opt_require_some', async () => {
    await expr_fun_opt_require_some.expr_fun_opt_require_some.deploy({ as: alice })

    const res_before = await expr_fun_opt_require_some.expr_fun_opt_require_some.get_res()
    assert(res_before == false)

    await expr_fun_opt_require_some.expr_fun_opt_require_some.exec({ as: alice })

    const res_after = await expr_fun_opt_require_some.expr_fun_opt_require_some.get_res()
    assert(res_after == true)
  })

  it('expr_fun_pack_complex', async () => {
    await expr_fun_pack_complex.expr_fun_pack_complex.deploy({ as: alice })

    const chain_id = await get_chain_id();
    const ty: MichelineType = { "prim": "pair", args: [{ prim: "nat" }, { prim: "string" }, { prim: "chain_id" }] }
    const data: Micheline = { "prim": "Pair", args: [{ int: "1" }, { string: "test" }, chain_id.to_mich()] }
    const ref = pack(data, ty)

    const res_before = await expr_fun_pack_complex.expr_fun_pack_complex.get_res()
    assert(res_before.equals(new Bytes("00")))

    await expr_fun_pack_complex.expr_fun_pack_complex.exec({ as: alice })

    const res_after = await expr_fun_pack_complex.expr_fun_pack_complex.get_res()
    assert(res_after.equals(ref))
  })

  it('expr_fun_pack_lit_tuple', async () => {
    await expr_fun_pack_lit_tuple.expr_fun_pack_lit_tuple.deploy({ as: alice })

    const ty: MichelineType = { "prim": "pair", args: [{ prim: "nat" }, { prim: "string" }] }
    const data: Micheline = { "prim": "Pair", args: [{ int: "1" }, { string: "test" }] }
    const ref = pack(data, ty)

    const res_before = await expr_fun_pack_lit_tuple.expr_fun_pack_lit_tuple.get_res()
    assert(res_before.equals(new Bytes("00")))

    await expr_fun_pack_lit_tuple.expr_fun_pack_lit_tuple.exec({ as: alice })

    const res_after = await expr_fun_pack_lit_tuple.expr_fun_pack_lit_tuple.get_res()
    assert(res_after.equals(ref))
  })

  it('expr_fun_pack_string', async () => {
    await expr_fun_pack_string.expr_fun_pack_string.deploy({ as: alice })

    const ty: MichelineType = { prim: "string" }
    const data: Micheline = { string: "archetype" }
    const ref = pack(data, ty)

    const res_before = await expr_fun_pack_string.expr_fun_pack_string.get_res()
    assert(res_before.equals(new Bytes("00")))

    await expr_fun_pack_string.expr_fun_pack_string.exec({ as: alice })

    const res_after = await expr_fun_pack_string.expr_fun_pack_string.get_res()
    assert(res_after.equals(ref))
  })

  it('expr_fun_setdelegate', async () => {
    await expr_fun_setdelegate.expr_fun_setdelegate.deploy({ as: alice })

    // await expr_fun_setdelegate.expr_fun_setdelegate.exec(alice.get_public_key(), { as: alice })
  })

  it('expr_fun_simplify_rational', async () => {
    await expr_fun_simplify_rational.expr_fun_simplify_rational.deploy({ as: alice })
    const res_before = await expr_fun_simplify_rational.expr_fun_simplify_rational.get_res();
    assert(res_before.equals(new Rational(0)), "Invalid Value")
    {
      const v = new Rational(36, new BigNumber(48))
      await expr_fun_simplify_rational.expr_fun_simplify_rational.exec(v, { as: alice })
      const res = await expr_fun_simplify_rational.expr_fun_simplify_rational.get_res();
      assert(res.equals(new Rational(3, new BigNumber(4))))
    }
    {
      const v = new Rational(-36, new BigNumber(48))
      await expr_fun_simplify_rational.expr_fun_simplify_rational.exec(v, { as: alice })
      const res = await expr_fun_simplify_rational.expr_fun_simplify_rational.get_res();
      assert(res.equals(new Rational(-3, new BigNumber(4))))
    }
    {
      const v = new Rational(28, new BigNumber(140))
      await expr_fun_simplify_rational.expr_fun_simplify_rational.exec(v, { as: alice })
      const res = await expr_fun_simplify_rational.expr_fun_simplify_rational.get_res();
      assert(res.equals(new Rational(1, new BigNumber(5))))
    }
  })

  it('expr_fun_slice_byt', async () => {
    await expr_fun_slice_byt.expr_fun_slice_byt.deploy({ as: alice })

    const res_before = await expr_fun_slice_byt.expr_fun_slice_byt.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_slice_byt.expr_fun_slice_byt.exec({ as: alice })

    const res_after = await expr_fun_slice_byt.expr_fun_slice_byt.get_res()
    assert(res_after.equals(Option.Some(new Bytes("cdef"))))
  })

  it('expr_fun_slice_str', async () => {
    await expr_fun_slice_str.expr_fun_slice_str.deploy({ as: alice })

    const res_before = await expr_fun_slice_str.expr_fun_slice_str.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_slice_str.expr_fun_slice_str.exec({ as: alice })

    const res_after = await expr_fun_slice_str.expr_fun_slice_str.get_res()
    assert(res_after.equals(Option.Some<string>("bc")))
  })

  it('expr_fun_sub_mutez', async () => {
    await expr_fun_sub_mutez.expr_fun_sub_mutez.deploy({ as: alice })

    const res_before = await expr_fun_sub_mutez.expr_fun_sub_mutez.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_sub_mutez.expr_fun_sub_mutez.exec({ as: alice })

    const res_after = await expr_fun_sub_mutez.expr_fun_sub_mutez.get_res()
    assert(res_after.equals(Option.Some(new Tez(1))))
  })

  it('expr_fun_sub_nat', async () => {
    await expr_fun_sub_nat.expr_fun_sub_nat.deploy({ as: alice })

    const res_before = await expr_fun_sub_nat.expr_fun_sub_nat.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_sub_nat.expr_fun_sub_nat.exec({ as: alice })

    const res_after = await expr_fun_sub_nat.expr_fun_sub_nat.get_res()
    assert(res_after.equals(Option.Some(new Nat(1))))
  })

  it('expr_fun_sub_nat_zero', async () => {
    await expr_fun_sub_nat_zero.expr_fun_sub_nat_zero.deploy({ as: alice })

    const res_before = await expr_fun_sub_nat_zero.expr_fun_sub_nat_zero.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_sub_nat_zero.expr_fun_sub_nat_zero.exec({ as: alice })

    const res_after = await expr_fun_sub_nat_zero.expr_fun_sub_nat_zero.get_res()
    assert(res_after.equals(Option.Some(new Nat(0))))
  })

  it('expr_fun_unpack_bool', async () => {
    await expr_fun_unpack_bool.expr_fun_unpack_bool.deploy({ as: alice })

    const res_before = await expr_fun_unpack_bool.expr_fun_unpack_bool.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_unpack_bool.expr_fun_unpack_bool.exec({ as: alice })

    const res_after = await expr_fun_unpack_bool.expr_fun_unpack_bool.get_res()
    assert(res_after.equals(Option.Some<boolean>(true)))
  })

  it('expr_fun_unpack_complex', async () => {
    await expr_fun_unpack_complex.expr_fun_unpack_complex.deploy({ as: alice })

    const chain_id = await get_chain_id();
    const ty: MichelineType = { "prim": "pair", args: [{ prim: "nat" }, { prim: "string" }, { prim: "chain_id" }] }
    const data: Micheline = { "prim": "Pair", args: [{ int: "1" }, { string: "test" }, chain_id.to_mich()] }
    const ref = pack(data, ty)

    const res_before = await expr_fun_unpack_complex.expr_fun_unpack_complex.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_unpack_complex.expr_fun_unpack_complex.exec(ref, { as: alice })

    const res_after = await expr_fun_unpack_complex.expr_fun_unpack_complex.get_res()
    assert(res_after.equals(Option.Some([new Nat(1), "test", chain_id])))
  })

  it('expr_fun_unpack_string', async () => {
    await expr_fun_unpack_string.expr_fun_unpack_string.deploy({ as: alice })

    const res_before = await expr_fun_unpack_string.expr_fun_unpack_string.get_res()
    assert(res_before.equals(Option.None()))

    await expr_fun_unpack_string.expr_fun_unpack_string.exec({ as: alice })

    const res_after = await expr_fun_unpack_string.expr_fun_unpack_string.get_res()
    assert(res_after.equals(Option.Some<string>("archetype")))
  })

  it('expr_instr_rec_1_0', async () => {
    await expr_instr_rec_1_0.expr_instr_rec_1_0.deploy({ as: alice })

    const r_before = await expr_instr_rec_1_0.expr_instr_rec_1_0.get_r();
    assert(r_before.m.length == 0)

    await expr_instr_rec_1_0.expr_instr_rec_1_0.exec({ as: alice })

    const r_after = await expr_instr_rec_1_0.expr_instr_rec_1_0.get_r();
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_2_0', async () => {
    await expr_instr_rec_2_0.expr_instr_rec_2_0.deploy({ as: alice })

    const r_before = await expr_instr_rec_2_0.expr_instr_rec_2_0.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.m.length == 0)

    await expr_instr_rec_2_0.expr_instr_rec_2_0.exec({ as: alice })

    const r_after = await expr_instr_rec_2_0.expr_instr_rec_2_0.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_2_1', async () => {
    await expr_instr_rec_2_1.expr_instr_rec_2_1.deploy({ as: alice })

    const r_before = await expr_instr_rec_2_1.expr_instr_rec_2_1.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.m.length == 0)

    await expr_instr_rec_2_1.expr_instr_rec_2_1.exec({ as: alice })

    const r_after = await expr_instr_rec_2_1.expr_instr_rec_2_1.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_3_0', async () => {
    await expr_instr_rec_3_0.expr_instr_rec_3_0.deploy({ as: alice })

    const r_before = await expr_instr_rec_3_0.expr_instr_rec_3_0.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.a == "")
    assert(r_before.m.length == 0)

    await expr_instr_rec_3_0.expr_instr_rec_3_0.exec({ as: alice })

    const r_after = await expr_instr_rec_3_0.expr_instr_rec_3_0.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.a == "")
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_3_1', async () => {
    await expr_instr_rec_3_1.expr_instr_rec_3_1.deploy({ as: alice })

    const r_before = await expr_instr_rec_3_1.expr_instr_rec_3_1.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.a == "")
    assert(r_before.m.length == 0)

    await expr_instr_rec_3_1.expr_instr_rec_3_1.exec({ as: alice })

    const r_after = await expr_instr_rec_3_1.expr_instr_rec_3_1.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.a == "")
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_3_2', async () => {
    await expr_instr_rec_3_2.expr_instr_rec_3_2.deploy({ as: alice })

    const r_before = await expr_instr_rec_3_2.expr_instr_rec_3_2.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.a == "")
    assert(r_before.m.length == 0)

    await expr_instr_rec_3_2.expr_instr_rec_3_2.exec({ as: alice })

    const r_after = await expr_instr_rec_3_2.expr_instr_rec_3_2.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.a == "")
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_4_0', async () => {
    await expr_instr_rec_4_0.expr_instr_rec_4_0.deploy({ as: alice })

    const r_before = await expr_instr_rec_4_0.expr_instr_rec_4_0.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.a == "")
    assert(r_before.b.equals(new Int(2)))
    assert(r_before.m.length == 0)

    await expr_instr_rec_4_0.expr_instr_rec_4_0.exec({ as: alice })

    const r_after = await expr_instr_rec_4_0.expr_instr_rec_4_0.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.a == "")
    assert(r_after.b.equals(new Int(2)))
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_4_1', async () => {
    await expr_instr_rec_4_1.expr_instr_rec_4_1.deploy({ as: alice })

    const r_before = await expr_instr_rec_4_1.expr_instr_rec_4_1.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.a == "")
    assert(r_before.b.equals(new Int(2)))
    assert(r_before.m.length == 0)

    await expr_instr_rec_4_1.expr_instr_rec_4_1.exec({ as: alice })

    const r_after = await expr_instr_rec_4_1.expr_instr_rec_4_1.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.a == "")
    assert(r_after.b.equals(new Int(2)))
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_4_2', async () => {
    await expr_instr_rec_4_2.expr_instr_rec_4_2.deploy({ as: alice })

    const r_before = await expr_instr_rec_4_2.expr_instr_rec_4_2.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.a == "")
    assert(r_before.b.equals(new Int(2)))
    assert(r_before.m.length == 0)

    await expr_instr_rec_4_2.expr_instr_rec_4_2.exec({ as: alice })

    const r_after = await expr_instr_rec_4_2.expr_instr_rec_4_2.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.a == "")
    assert(r_after.b.equals(new Int(2)))
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_4_3', async () => {
    await expr_instr_rec_4_3.expr_instr_rec_4_3.deploy({ as: alice })

    const r_before = await expr_instr_rec_4_3.expr_instr_rec_4_3.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.a == "")
    assert(r_before.b.equals(new Int(2)))
    assert(r_before.m.length == 0)

    await expr_instr_rec_4_3.expr_instr_rec_4_3.exec({ as: alice })

    const r_after = await expr_instr_rec_4_3.expr_instr_rec_4_3.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.a == "")
    assert(r_after.b.equals(new Int(2)))
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(1)))
    assert(r_after.m[0][1] == "str")
  })

  it('expr_instr_rec_rollback', async () => {
    await expr_instr_rec_rollback.expr_instr_rec_rollback.deploy({ as: alice })

    const r_before = await expr_instr_rec_rollback.expr_instr_rec_rollback.get_r();
    assert(r_before.id.equals(new Nat(0)))
    assert(r_before.a == "init")
    assert(r_before.b.equals(new Int(2)))
    assert(r_before.m.length == 0)

    await expr_instr_rec_rollback.expr_instr_rec_rollback.exec({ as: alice })

    const r_after = await expr_instr_rec_rollback.expr_instr_rec_rollback.get_r();
    assert(r_after.id.equals(new Nat(0)))
    assert(r_after.a == "init")
    assert(r_after.b.equals(new Int(2)))
    assert(r_after.m.length == 1)
    assert(r_after.m[0][0].equals(new Nat(0)))
    assert(r_after.m[0][1] == "init")
  })

  it('expr_lambda', async () => {
    await expr_lambda.expr_lambda.deploy({ as: alice })

    const res_0_before = await expr_lambda.expr_lambda.get_res_0()
    assert(res_0_before.equals(new Int(0)))
    const res_1_before = await expr_lambda.expr_lambda.get_res_1()
    assert(res_1_before.equals(new Int(0)))
    const res_2_before = await expr_lambda.expr_lambda.get_res_2()
    assert(res_2_before.equals(new Int(0)))
    const res_3_before = await expr_lambda.expr_lambda.get_res_3()
    assert(res_3_before.equals(new Int(0)))

    await expr_lambda.expr_lambda.exec({ as: alice })

    const res_0_after = await expr_lambda.expr_lambda.get_res_0()
    assert(res_0_after.equals(new Int(1)))
    const res_1_after = await expr_lambda.expr_lambda.get_res_1()
    assert(res_1_after.equals(new Int(1)))
    const res_2_after = await expr_lambda.expr_lambda.get_res_2()
    assert(res_2_after.equals(new Int(1)))
    const res_3_after = await expr_lambda.expr_lambda.get_res_3()
    assert(res_3_after.equals(new Int(1)))
  })

  it('expr_lambda2', async () => {
    await expr_lambda2.expr_lambda2.deploy({ as: alice })

    const res_before = await expr_lambda2.expr_lambda2.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_lambda2.expr_lambda2.exec({ as: alice })

    const res_after = await expr_lambda2.expr_lambda2.get_res()
    assert(res_after.equals(new Nat(5)))
  })

  it('expr_list_concat', async () => {
    await expr_list_concat.expr_list_concat.deploy({ as: alice })

    const res_before = await expr_list_concat.expr_list_concat.get_res()
    assert(res_before.length == 0)

    await expr_list_concat.expr_list_concat.exec({ as: alice })

    const res_after = await expr_list_concat.expr_list_concat.get_res()
    assert(res_after.length == 6)
    assert(res_after[0] == "1")
    assert(res_after[1] == "2")
    assert(res_after[2] == "3")
    assert(res_after[3] == "4")
    assert(res_after[4] == "5")
    assert(res_after[5] == "6")
  })

  it('expr_list_contains', async () => {
    await expr_list_contains.expr_list_contains.deploy({ as: alice })

    const res_before = await expr_list_contains.expr_list_contains.get_res()
    assert(res_before == false)

    await expr_list_contains.expr_list_contains.exec({ as: alice })

    const res_after = await expr_list_contains.expr_list_contains.get_res()
    assert(res_after == true)
  })

  it('expr_list_head', async () => {
    await expr_list_head.expr_list_head.deploy({ as: alice })
    const res_init = await expr_list_head.expr_list_head.get_res();
    assert(res_init.length == 0, "Invalid Value")
    await expr_list_head.expr_list_head.exec([], new Nat(3), { as: alice })
    const res_a = await expr_list_head.expr_list_head.get_res();
    assert(res_a.length == 0, "Invalid Value")
    await expr_list_head.expr_list_head.exec(["a", "b", "c"], new Nat(0), { as: alice })
    const res_b = await expr_list_head.expr_list_head.get_res();
    assert(res_b.length == 0, "Invalid Value")
    await expr_list_head.expr_list_head.exec(["a", "b", "c"], new Nat(2), { as: alice })
    const res_c = await expr_list_head.expr_list_head.get_res();
    assert(res_c.length == 2, "Invalid Value")
    assert(res_c[0] == "a", "Invalid Value")
    assert(res_c[1] == "b", "Invalid Value")
    await expr_list_head.expr_list_head.exec(["a", "b", "c"], new Nat(3), { as: alice })
    const res_d = await expr_list_head.expr_list_head.get_res();
    assert(res_d.length == 3, "Invalid Value")
    assert(res_d[0] == "a", "Invalid Value")
    assert(res_d[1] == "b", "Invalid Value")
    assert(res_d[2] == "c", "Invalid Value")
    await expr_list_head.expr_list_head.exec(["a", "b", "c"], new Nat(4), { as: alice })
    const res_e = await expr_list_head.expr_list_head.get_res();
    assert(res_e.length == 3, "Invalid Value")
    assert(res_e[0] == "a", "Invalid Value")
    assert(res_e[1] == "b", "Invalid Value")
    assert(res_e[2] == "c", "Invalid Value")
  })

  it('expr_list_length', async () => {
    await expr_list_length.expr_list_length.deploy({ as: alice })

    const res_before = await expr_list_length.expr_list_length.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_list_length.expr_list_length.exec({ as: alice })

    const res_after = await expr_list_length.expr_list_length.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_list_lit', async () => {
    await expr_list_lit.expr_list_lit.deploy({ as: alice })

    const res_before = await expr_list_lit.expr_list_lit.get_res()
    assert(res_before.length == 0)

    await expr_list_lit.expr_list_lit.exec({ as: alice })

    const res_after = await expr_list_lit.expr_list_lit.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] == "1")
    assert(res_after[1] == "2")
    assert(res_after[2] == "3")
  })

  it('expr_list_map', async () => {
    await expr_list_map.expr_list_map.deploy({ as: alice })

    const res_before = await expr_list_map.expr_list_map.get_res()
    assert(res_before.length == 0)

    await expr_list_map.expr_list_map.exec({ as: alice })

    const res_after = await expr_list_map.expr_list_map.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(3)))
    assert(res_after[2].equals(new Nat(4)))
  })

  it('expr_list_map_string_nat', async () => {
    await expr_list_map_string_nat.expr_list_map_string_nat.deploy({ as: alice })

    const res_before = await expr_list_map_string_nat.expr_list_map_string_nat.get_res()
    assert(res_before.length == 0)

    await expr_list_map_string_nat.expr_list_map_string_nat.exec({ as: alice })

    const res_after = await expr_list_map_string_nat.expr_list_map_string_nat.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(3)))
    assert(res_after[2].equals(new Nat(4)))
  })

  it('expr_list_nth', async () => {
    await expr_list_nth.expr_list_nth.deploy({ as: alice })

    const res_before = await expr_list_nth.expr_list_nth.get_res()
    assert(res_before == "")

    await expr_list_nth.expr_list_nth.exec({ as: alice })

    const res_after = await expr_list_nth.expr_list_nth.get_res()
    assert(res_after == "2")
  })

  it('expr_list_prepend', async () => {
    await expr_list_prepend.expr_list_prepend.deploy({ as: alice })

    const res_before = await expr_list_prepend.expr_list_prepend.get_res()
    assert(res_before.length == 0)

    await expr_list_prepend.expr_list_prepend.exec({ as: alice })

    const res_after = await expr_list_prepend.expr_list_prepend.get_res()
    assert(res_after.length == 4)
    assert(res_after[0] = "0")
    assert(res_after[1] = "1")
    assert(res_after[2] = "2")
    assert(res_after[3] = "3")
  })

  it('expr_list_reverse', async () => {
    await expr_list_reverse.expr_list_reverse.deploy({ as: alice })

    const res_before = await expr_list_reverse.expr_list_reverse.get_res()
    assert(res_before.length == 0)

    await expr_list_reverse.expr_list_reverse.exec({ as: alice })

    const res_after = await expr_list_reverse.expr_list_reverse.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] = "3")
    assert(res_after[1] = "2")
    assert(res_after[2] = "1")
  })

  it('expr_list_tail', async () => {
    await expr_list_tail.expr_list_tail.deploy({ as: alice })
    const res_init = await expr_list_tail.expr_list_tail.get_res();
    assert(res_init.length == 0, "Invalid Value")
    await expr_list_tail.expr_list_tail.exec([], new Nat(3), { as: alice })
    const res_a = await expr_list_tail.expr_list_tail.get_res();
    assert(res_a.length == 0, "Invalid Value")
    await expr_list_tail.expr_list_tail.exec(["a", "b", "c"], new Nat(0), { as: alice })
    const res_b = await expr_list_tail.expr_list_tail.get_res();
    assert(res_b.length == 0, "Invalid Value")
    await expr_list_tail.expr_list_tail.exec(["a", "b", "c"], new Nat(2), { as: alice })
    const res_c = await expr_list_tail.expr_list_tail.get_res();
    assert(res_c.length == 2, "Invalid Value")
    assert(res_c[0] == "b", "Invalid Value")
    assert(res_c[1] == "c", "Invalid Value")
    await expr_list_tail.expr_list_tail.exec(["a", "b", "c"], new Nat(3), { as: alice })
    const res_d = await expr_list_tail.expr_list_tail.get_res();
    assert(res_d.length == 3, "Invalid Value")
    assert(res_d[0] == "a", "Invalid Value")
    assert(res_d[1] == "b", "Invalid Value")
    assert(res_d[2] == "c", "Invalid Value")
    await expr_list_tail.expr_list_tail.exec(["a", "b", "c"], new Nat(4), { as: alice })
    const res_e = await expr_list_tail.expr_list_tail.get_res();
    assert(res_e.length == 3, "Invalid Value")
    assert(res_e[0] == "a", "Invalid Value")
    assert(res_e[1] == "b", "Invalid Value")
    assert(res_e[2] == "c", "Invalid Value")
  })

  it('expr_lit_addr', async () => {
    await expr_lit_addr.expr_lit_addr.deploy({ as: alice })

    const res_before = await expr_lit_addr.expr_lit_addr.get_res()
    assert(res_before.equals(new Address("tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg")))

    await expr_lit_addr.expr_lit_addr.exec({ as: alice })

    const res_after = await expr_lit_addr.expr_lit_addr.get_res()
    assert(res_after.equals(new Address("tz1aazS5ms5cbGkb6FN1wvWmN7yrMTTcr6wB")))
  })

  it('expr_lit_bytes', async () => {
    await expr_lit_bytes.expr_lit_bytes.deploy({ as: alice })

    const res_before = await expr_lit_bytes.expr_lit_bytes.get_res()
    assert(res_before.equals(new Bytes("00")))

    await expr_lit_bytes.expr_lit_bytes.exec({ as: alice })

    const res_after = await expr_lit_bytes.expr_lit_bytes.get_res()
    assert(res_after.equals(new Bytes("1f")))
  })

  it('expr_lit_cur_mtz', async () => {
    await expr_lit_cur_mtz.expr_lit_cur_mtz.deploy({ as: alice })

    const res_before = await expr_lit_cur_mtz.expr_lit_cur_mtz.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_lit_cur_mtz.expr_lit_cur_mtz.exec({ as: alice })

    const res_after = await expr_lit_cur_mtz.expr_lit_cur_mtz.get_res()
    assert(res_after.equals(new Tez(1000, "mutez")))
  })

  it('expr_lit_cur_tz', async () => {
    await expr_lit_cur_tz.expr_lit_cur_tz.deploy({ as: alice })

    const res_before = await expr_lit_cur_tz.expr_lit_cur_tz.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_lit_cur_tz.expr_lit_cur_tz.exec({ as: alice })

    const res_after = await expr_lit_cur_tz.expr_lit_cur_tz.get_res()
    assert(res_after.equals(new Tez(1)))
  })

  it('expr_lit_cur_utz', async () => {
    await expr_lit_cur_utz.expr_lit_cur_utz.deploy({ as: alice })

    const res_before = await expr_lit_cur_utz.expr_lit_cur_utz.get_res()
    assert(res_before.equals(new Tez(0)))

    await expr_lit_cur_utz.expr_lit_cur_utz.exec({ as: alice })

    const res_after = await expr_lit_cur_utz.expr_lit_cur_utz.get_res()
    assert(res_after.equals(new Tez(1, "mutez")))
  })

  it('expr_lit_date_0', async () => {
    await expr_lit_date_0.expr_lit_date_0.deploy({ as: alice })

    const res_before = await expr_lit_date_0.expr_lit_date_0.get_res()
    assert(res_before.toISOString() == '1970-01-01T00:00:00.000Z')

    await expr_lit_date_0.expr_lit_date_0.exec({ as: alice })

    const res_after = await expr_lit_date_0.expr_lit_date_0.get_res()
    assert(res_after.toISOString() == '2019-01-01T00:00:00.000Z')
  })

  it('expr_lit_date_1', async () => {
    await expr_lit_date_1.expr_lit_date_1.deploy({ as: alice })

    const res_before = await expr_lit_date_1.expr_lit_date_1.get_res()
    assert(res_before.toISOString() == '1970-01-01T00:00:00.000Z')

    await expr_lit_date_1.expr_lit_date_1.exec({ as: alice })

    const res_after = await expr_lit_date_1.expr_lit_date_1.get_res()
    assert(res_after.toISOString() == '2019-01-01T01:02:03.000Z')
  })

  it('expr_lit_date_2', async () => {
    await expr_lit_date_2.expr_lit_date_2.deploy({ as: alice })

    const res_before = await expr_lit_date_2.expr_lit_date_2.get_res()
    assert(res_before.toISOString() == '1970-01-01T00:00:00.000Z')

    await expr_lit_date_2.expr_lit_date_2.exec({ as: alice })

    const res_after = await expr_lit_date_2.expr_lit_date_2.get_res()
    assert(res_after.toISOString() == '2019-01-01T01:02:03.000Z')
  })

  it('expr_lit_date_3', async () => {
    await expr_lit_date_3.expr_lit_date_3.deploy({ as: alice })

    const res_before = await expr_lit_date_3.expr_lit_date_3.get_res()
    assert(res_before.toISOString() == '1970-01-01T00:00:00.000Z')

    await expr_lit_date_3.expr_lit_date_3.exec({ as: alice })

    const res_after = await expr_lit_date_3.expr_lit_date_3.get_res()
    assert(res_after.toISOString() == '2018-12-31T23:00:00.000Z')
  })

  it('expr_lit_date_4', async () => {
    await expr_lit_date_4.expr_lit_date_4.deploy({ as: alice })

    const res_before = await expr_lit_date_4.expr_lit_date_4.get_res()
    assert(res_before.toISOString() == '1970-01-01T00:00:00.000Z')

    await expr_lit_date_4.expr_lit_date_4.exec({ as: alice })

    const res_after = await expr_lit_date_4.expr_lit_date_4.get_res()
    assert(res_after.toISOString() == '2019-01-01T05:30:00.000Z')
  })

  it('expr_lit_dur', async () => {
    await expr_lit_dur.expr_lit_dur.deploy({ as: alice })

    const res_before = await expr_lit_dur.expr_lit_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await expr_lit_dur.expr_lit_dur.exec({ as: alice })

    const res_after = await expr_lit_dur.expr_lit_dur.get_res()
    assert(res_after.equals(new Duration("3w8d4h34m18s")))
  })

  it('expr_lit_int', async () => {
    await expr_lit_int.expr_lit_int.deploy({ as: alice })

    const res_before = await expr_lit_int.expr_lit_int.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_lit_int.expr_lit_int.exec({ as: alice })

    const res_after = await expr_lit_int.expr_lit_int.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('expr_lit_int_neg', async () => {
    await expr_lit_int_neg.expr_lit_int_neg.deploy({ as: alice })

    const res_before = await expr_lit_int_neg.expr_lit_int_neg.get_res()
    assert(res_before.equals(new Int(0)))

    await expr_lit_int_neg.expr_lit_int_neg.exec({ as: alice })

    const res_after = await expr_lit_int_neg.expr_lit_int_neg.get_res()
    assert(res_after.equals(new Int(-1)))
  })

  it('expr_lit_nat', async () => {
    await expr_lit_nat.expr_lit_nat.deploy({ as: alice })

    const res_before = await expr_lit_nat.expr_lit_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_lit_nat.expr_lit_nat.exec({ as: alice })

    const res_after = await expr_lit_nat.expr_lit_nat.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_lit_opt_none', async () => {
    await expr_lit_opt_none.expr_lit_opt_none.deploy({ as: alice })

    const res_before = await expr_lit_opt_none.expr_lit_opt_none.get_res()
    assert(res_before.equals(Option.None()))

    await expr_lit_opt_none.expr_lit_opt_none.exec({ as: alice })

    const res_after = await expr_lit_opt_none.expr_lit_opt_none.get_res()
    assert(res_after.equals(Option.None()))
  })

  it('expr_lit_opt_some', async () => {
    await expr_lit_opt_some.expr_lit_opt_some.deploy({ as: alice })

    const res_before = await expr_lit_opt_some.expr_lit_opt_some.get_res()
    assert(res_before.equals(Option.None()))

    await expr_lit_opt_some.expr_lit_opt_some.exec({ as: alice })

    const res_after = await expr_lit_opt_some.expr_lit_opt_some.get_res()
    assert(res_after.equals(Option.Some<Nat>(new Nat(0))))
  })

  it('expr_lit_or_left', async () => {
    await expr_lit_or_left.expr_lit_or_left.deploy({ as: alice })

    const res_before = await expr_lit_or_left.expr_lit_or_left.get_res()
    assert(res_before.equals(Or.Left(new Nat(0))))

    await expr_lit_or_left.expr_lit_or_left.exec({ as: alice })

    const res_after = await expr_lit_or_left.expr_lit_or_left.get_res()
    assert(res_after.equals(Or.Left(new Nat(1))))
  })

  it('expr_lit_or_right', async () => {
    await expr_lit_or_right.expr_lit_or_right.deploy({ as: alice })

    const res_before = await expr_lit_or_right.expr_lit_or_right.get_res()
    assert(res_before.equals(Or.Right(new Int(0))))

    await expr_lit_or_right.expr_lit_or_right.exec({ as: alice })

    const res_after = await expr_lit_or_right.expr_lit_or_right.get_res()
    assert(res_after.equals(Or.Right(new Int(1))))
  })

  it('expr_lit_rat_dec', async () => {
    await expr_lit_rat_dec.expr_lit_rat_dec.deploy({ as: alice })

    const res_before = await expr_lit_rat_dec.expr_lit_rat_dec.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_lit_rat_dec.expr_lit_rat_dec.exec({ as: alice })

    const res_after = await expr_lit_rat_dec.expr_lit_rat_dec.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_lit_rat_dec_neg', async () => {
    await expr_lit_rat_dec_neg.expr_lit_rat_dec_neg.deploy({ as: alice })

    const res_before = await expr_lit_rat_dec_neg.expr_lit_rat_dec_neg.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_lit_rat_dec_neg.expr_lit_rat_dec_neg.exec({ as: alice })

    const res_after = await expr_lit_rat_dec_neg.expr_lit_rat_dec_neg.get_res()
    assert(res_after.equals(new Rational(-0.5)))
  })

  it('expr_lit_rat_div', async () => {
    await expr_lit_rat_div.expr_lit_rat_div.deploy({ as: alice })

    const res_before = await expr_lit_rat_div.expr_lit_rat_div.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_lit_rat_div.expr_lit_rat_div.exec({ as: alice })

    const res_after = await expr_lit_rat_div.expr_lit_rat_div.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('expr_lit_rat_div_neg', async () => {
    await expr_lit_rat_div_neg.expr_lit_rat_div_neg.deploy({ as: alice })

    const res_before = await expr_lit_rat_div_neg.expr_lit_rat_div_neg.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_lit_rat_div_neg.expr_lit_rat_div_neg.exec({ as: alice })

    const res_after = await expr_lit_rat_div_neg.expr_lit_rat_div_neg.get_res()
    assert(res_after.equals(new Rational(-0.5)))
  })

  it('expr_lit_str', async () => {
    await expr_lit_str.expr_lit_str.deploy({ as: alice })

    const res_before = await expr_lit_str.expr_lit_str.get_res()
    assert(res_before == "")

    await expr_lit_str.expr_lit_str.exec({ as: alice })

    const res_after = await expr_lit_str.expr_lit_str.get_res()
    assert(res_after == "a")
  })

  it('expr_lit_tuple', async () => {
    await expr_lit_tuple.expr_lit_tuple.deploy({ as: alice })

    const res_before = await expr_lit_tuple.expr_lit_tuple.get_res()
    assert(res_before[0].equals(new Int(0)))
    assert(res_before[1].equals(new Int(0)))

    await expr_lit_tuple.expr_lit_tuple.exec({ as: alice })

    const res_after = await expr_lit_tuple.expr_lit_tuple.get_res()
    assert(res_after[0].equals(new Int(1)))
    assert(res_after[1].equals(new Int(2)))
  })

  it('expr_lit_unit', async () => {
    await expr_lit_unit.expr_lit_unit.deploy({ as: alice })

    const res_before = await expr_lit_unit.expr_lit_unit.get_res()
    assert(res_before.equals(new Unit()))

    await expr_lit_unit.expr_lit_unit.exec({ as: alice })

    const res_after = await expr_lit_unit.expr_lit_unit.get_res()
    assert(res_after.equals(new Unit()))
  })

  it('expr_make_big_map', async () => {
    await expr_make_big_map.expr_make_big_map.deploy({ as: alice })

    const value_0_before = await expr_make_big_map.expr_make_big_map.get_res_value(new Nat(0));
    assert(value_0_before === undefined)
    const value_1_before = await expr_make_big_map.expr_make_big_map.get_res_value(new Nat(1));
    assert(value_1_before === undefined)
    const value_2_before = await expr_make_big_map.expr_make_big_map.get_res_value(new Nat(2));
    assert(value_2_before === undefined)

    await expr_make_big_map.expr_make_big_map.exec({ as: alice })

    const value_0_after = await expr_make_big_map.expr_make_big_map.get_res_value(new Nat(0));
    assert(value_0_after == "0")
    const value_1_after = await expr_make_big_map.expr_make_big_map.get_res_value(new Nat(1));
    assert(value_1_after == "1")
    const value_2_after = await expr_make_big_map.expr_make_big_map.get_res_value(new Nat(2));
    assert(value_2_after == "2")
  })

  it('expr_make_big_map_empty', async () => {
    await expr_make_big_map_empty.expr_make_big_map_empty.deploy({ as: alice })

    const value_0_before = await expr_make_big_map_empty.expr_make_big_map_empty.get_res_value(new Nat(0));
    assert(value_0_before == "0")
    const value_1_before = await expr_make_big_map_empty.expr_make_big_map_empty.get_res_value(new Nat(1));
    assert(value_1_before == "1")
    const value_2_before = await expr_make_big_map_empty.expr_make_big_map_empty.get_res_value(new Nat(2));
    assert(value_2_before == "2")

    await expr_make_big_map_empty.expr_make_big_map_empty.exec({ as: alice })

    const value_0_after = await expr_make_big_map_empty.expr_make_big_map_empty.get_res_value(new Nat(0));
    assert(value_0_after === undefined)
    const value_1_after = await expr_make_big_map_empty.expr_make_big_map_empty.get_res_value(new Nat(1));
    assert(value_1_after === undefined)
    const value_2_after = await expr_make_big_map_empty.expr_make_big_map_empty.get_res_value(new Nat(2));
    assert(value_2_after === undefined)
  })

  it('expr_make_list', async () => {
    await expr_make_list.expr_make_list.deploy({ as: alice })

    const res_before = await expr_make_list.expr_make_list.get_res();
    assert(res_before.length == 0)

    await expr_make_list.expr_make_list.exec({ as: alice })

    const res_after = await expr_make_list.expr_make_list.get_res();
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('expr_make_list_empty', async () => {
    await expr_make_list_empty.expr_make_list_empty.deploy({ as: alice })

    const res_before = await expr_make_list_empty.expr_make_list_empty.get_res();
    assert(res_before.length == 3)
    assert(res_before[0].equals(new Nat(0)))
    assert(res_before[1].equals(new Nat(1)))
    assert(res_before[2].equals(new Nat(2)))

    await expr_make_list_empty.expr_make_list_empty.exec({ as: alice })

    const res_after = await expr_make_list_empty.expr_make_list_empty.get_res();
    assert(res_after.length == 0)
  })

  it('expr_make_map', async () => {
    await expr_make_map.expr_make_map.deploy({ as: alice })

    const res_before = await expr_make_map.expr_make_map.get_res();
    assert(res_before.length == 0)

    await expr_make_map.expr_make_map.exec({ as: alice })

    const res_after = await expr_make_map.expr_make_map.get_res();
    assert(res_after.length == 3)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
    assert(res_after[1][0].equals(new Nat(1)))
    assert(res_after[1][1] == "1")
    assert(res_after[2][0].equals(new Nat(2)))
    assert(res_after[2][1] == "2")
  })

  it('expr_make_map_empty', async () => {
    await expr_make_map_empty.expr_make_map_empty.deploy({ as: alice })

    const res_before = await expr_make_map_empty.expr_make_map_empty.get_res();
    assert(res_before.length == 3)
    assert(res_before[0][0].equals(new Nat(0)))
    assert(res_before[0][1] == "0")
    assert(res_before[1][0].equals(new Nat(1)))
    assert(res_before[1][1] == "1")
    assert(res_before[2][0].equals(new Nat(2)))
    assert(res_before[2][1] == "2")
    await expr_make_map_empty.expr_make_map_empty.exec({ as: alice })

    const res_after = await expr_make_map_empty.expr_make_map_empty.get_res();
    assert(res_after.length == 0)
  })

  it('expr_make_set', async () => {
    await expr_make_set.expr_make_set.deploy({ as: alice })

    const res_before = await expr_make_set.expr_make_set.get_res();
    assert(res_before.length == 0)

    await expr_make_set.expr_make_set.exec({ as: alice })

    const res_after = await expr_make_set.expr_make_set.get_res();
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('expr_make_set_empty', async () => {
    await expr_make_set_empty.expr_make_set_empty.deploy({ as: alice })

    const res_before = await expr_make_set_empty.expr_make_set_empty.get_res();
    assert(res_before.length == 3)
    assert(res_before[0].equals(new Nat(0)))
    assert(res_before[1].equals(new Nat(1)))
    assert(res_before[2].equals(new Nat(2)))

    await expr_make_set_empty.expr_make_set_empty.exec({ as: alice })

    const res_after = await expr_make_set_empty.expr_make_set_empty.get_res();
    assert(res_after.length == 0)
  })

  it('expr_map_contains', async () => {
    await expr_map_contains.expr_map_contains.deploy({ as: alice })

    const res_before = await expr_map_contains.expr_map_contains.get_res()
    assert(res_before == false)

    await expr_map_contains.expr_map_contains.exec({ as: alice })

    const res_after = await expr_map_contains.expr_map_contains.get_res()
    assert(res_after == true)
  })

  it('expr_map_get', async () => {
    await expr_map_get.expr_map_get.deploy({ as: alice })

    const res_before = await expr_map_get.expr_map_get.get_res()
    assert(res_before.equals(Option.None()))

    await expr_map_get.expr_map_get.exec({ as: alice })

    const res_after = await expr_map_get.expr_map_get.get_res()
    assert(res_after.equals(Option.Some<string>("0")))
  })

  it('expr_map_length', async () => {
    await expr_map_length.expr_map_length.deploy({ as: alice })

    const res_before = await expr_map_length.expr_map_length.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_map_length.expr_map_length.exec({ as: alice })

    const res_after = await expr_map_length.expr_map_length.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_map_lit', async () => {
    await expr_map_lit.expr_map_lit.deploy({ as: alice })

    const res_before = await expr_map_lit.expr_map_lit.get_res()
    assert(res_before.length == 0)

    await expr_map_lit.expr_map_lit.exec({ as: alice })

    const res_after = await expr_map_lit.expr_map_lit.get_res()
    assert(res_after.length == 3)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
    assert(res_after[1][0].equals(new Nat(1)))
    assert(res_after[1][1] == "1")
    assert(res_after[2][0].equals(new Nat(2)))
    assert(res_after[2][1] == "2")
  })

  it('expr_map_map', async () => {
    await expr_map_map.expr_map_map.deploy({ as: alice })

    const res_before = await expr_map_map.expr_map_map.get_res()
    assert(res_before.length == 0)

    await expr_map_map.expr_map_map.exec({ as: alice })

    const res_after = await expr_map_map.expr_map_map.get_res()
    assert(res_after.length == 3)
    assert(res_after[0][0] == "abc")
    assert(res_after[0][1].equals(new Nat(2)))
    assert(res_after[1][0] == "def")
    assert(res_after[1][1].equals(new Nat(3)))
    assert(res_after[2][0] == "ijk")
    assert(res_after[2][1].equals(new Nat(4)))
  })

  it('expr_map_put', async () => {
    await expr_map_put.expr_map_put.deploy({ as: alice })

    const res_before = await expr_map_put.expr_map_put.get_res()
    assert(res_before.length == 0)

    await expr_map_put.expr_map_put.exec({ as: alice })

    const res_after = await expr_map_put.expr_map_put.get_res()
    assert(res_after.length == 1)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
  })

  it('expr_map_remove', async () => {
    await expr_map_remove.expr_map_remove.deploy({ as: alice })

    const res_before = await expr_map_remove.expr_map_remove.get_res()
    assert(res_before.length == 1)
    assert(res_before[0][0].equals(new Nat(0)))
    assert(res_before[0][1] == "0")

    await expr_map_remove.expr_map_remove.exec({ as: alice })

    const res_after = await expr_map_remove.expr_map_remove.get_res()
    assert(res_after.length == 0)
  })

  it('expr_map_update', async () => {
    await expr_map_update.expr_map_update.deploy({ as: alice })

    const res_before = await expr_map_update.expr_map_update.get_res()
    assert(res_before.length == 0)

    await expr_map_update.expr_map_update.exec({ as: alice })

    const res_after = await expr_map_update.expr_map_update.get_res()
    assert(res_after.length == 1)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
  })

  it('expr_method_asset_contains', async () => {
    await expr_method_asset_contains.expr_method_asset_contains.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_contains.expr_method_asset_contains.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_contains.expr_method_asset_contains.get_res()
    assert(res_before == false)

    await expr_method_asset_contains.expr_method_asset_contains.exec({ as: alice })

    const my_asset_after = await expr_method_asset_contains.expr_method_asset_contains.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_contains.expr_method_asset_contains.get_res()
    assert(res_after == true)
  })

  it('expr_method_asset_contains_aggregate', async () => {
    await expr_method_asset_contains_aggregate.expr_method_asset_contains_aggregate.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_contains_aggregate.expr_method_asset_contains_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_contains_aggregate.expr_method_asset_contains_aggregate.get_o_asset()
    assert(o_asset_before.length == 1)
    assert(o_asset_before[0].equals(new Nat(0)))
    const res_before = await expr_method_asset_contains_aggregate.expr_method_asset_contains_aggregate.get_res()
    assert(res_before == false)

    await expr_method_asset_contains_aggregate.expr_method_asset_contains_aggregate.exec({ as: alice })

    const my_asset_after = await expr_method_asset_contains_aggregate.expr_method_asset_contains_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_contains_aggregate.expr_method_asset_contains_aggregate.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0].equals(new Nat(0)))
    const res_after = await expr_method_asset_contains_aggregate.expr_method_asset_contains_aggregate.get_res()
    assert(res_after == true)
  })

  it('expr_method_asset_contains_one_field', async () => {
    await expr_method_asset_contains_one_field.expr_method_asset_contains_one_field.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_contains_one_field.expr_method_asset_contains_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await expr_method_asset_contains_one_field.expr_method_asset_contains_one_field.get_res()
    assert(res_before == false)

    await expr_method_asset_contains_one_field.expr_method_asset_contains_one_field.exec({ as: alice })

    const my_asset_after = await expr_method_asset_contains_one_field.expr_method_asset_contains_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    const res_after = await expr_method_asset_contains_one_field.expr_method_asset_contains_one_field.get_res()
    assert(res_after == true)
  })

  it('expr_method_asset_contains_partition', async () => {
    await expr_method_asset_contains_partition.expr_method_asset_contains_partition.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_contains_partition.expr_method_asset_contains_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_contains_partition.expr_method_asset_contains_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await expr_method_asset_contains_partition.expr_method_asset_contains_partition.get_res()
    assert(res_before == true)

    await expr_method_asset_contains_partition.expr_method_asset_contains_partition.exec({ as: alice })

    const my_asset_after = await expr_method_asset_contains_partition.expr_method_asset_contains_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_contains_partition.expr_method_asset_contains_partition.get_o_asset()
    assert(o_asset_after.length == 0)
    const res_after = await expr_method_asset_contains_partition.expr_method_asset_contains_partition.get_res()
    assert(res_after == false)
  })

  it('expr_method_asset_contains_view', async () => {
    await expr_method_asset_contains_view.expr_method_asset_contains_view.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_contains_view.expr_method_asset_contains_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_contains_view.expr_method_asset_contains_view.get_res()
    assert(res_before == false)

    await expr_method_asset_contains_view.expr_method_asset_contains_view.exec({ as: alice })

    const my_asset_after = await expr_method_asset_contains_view.expr_method_asset_contains_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_contains_view.expr_method_asset_contains_view.get_res()
    assert(res_after == true)
  })

  it('expr_method_asset_count', async () => {
    await expr_method_asset_count.expr_method_asset_count.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_count.expr_method_asset_count.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_count.expr_method_asset_count.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_count.expr_method_asset_count.exec({ as: alice })

    const my_asset_after = await expr_method_asset_count.expr_method_asset_count.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_count.expr_method_asset_count.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_method_asset_count_aggregate', async () => {
    await expr_method_asset_count_aggregate.expr_method_asset_count_aggregate.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_count_aggregate.expr_method_asset_count_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 1)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_count_aggregate.expr_method_asset_count_aggregate.get_o_asset()
    assert(o_asset_before.length == 1)
    assert(o_asset_before[0].equals(new Nat(0)))
    const res_before = await expr_method_asset_count_aggregate.expr_method_asset_count_aggregate.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_count_aggregate.expr_method_asset_count_aggregate.exec({ as: alice })

    const my_asset_after = await expr_method_asset_count_aggregate.expr_method_asset_count_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_count_aggregate.expr_method_asset_count_aggregate.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0].equals(new Nat(0)))
    const res_after = await expr_method_asset_count_aggregate.expr_method_asset_count_aggregate.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_method_asset_count_one_field', async () => {
    await expr_method_asset_count_one_field.expr_method_asset_count_one_field.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_count_one_field.expr_method_asset_count_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await expr_method_asset_count_one_field.expr_method_asset_count_one_field.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_count_one_field.expr_method_asset_count_one_field.exec({ as: alice })

    const my_asset_after = await expr_method_asset_count_one_field.expr_method_asset_count_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    const res_after = await expr_method_asset_count_one_field.expr_method_asset_count_one_field.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_method_asset_count_partition', async () => {
    await expr_method_asset_count_partition.expr_method_asset_count_partition.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_count_partition.expr_method_asset_count_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_count_partition.expr_method_asset_count_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await expr_method_asset_count_partition.expr_method_asset_count_partition.get_res()
    assert(res_before.equals(new Int(-1)))

    await expr_method_asset_count_partition.expr_method_asset_count_partition.exec({ as: alice })

    const my_asset_after = await expr_method_asset_count_partition.expr_method_asset_count_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_count_partition.expr_method_asset_count_partition.get_o_asset()
    assert(o_asset_after.length == 0)
    const res_after = await expr_method_asset_count_partition.expr_method_asset_count_partition.get_res()
    assert(res_after.equals(new Int(0)))
  })

  it('expr_method_asset_count_view', async () => {
    await expr_method_asset_count_view.expr_method_asset_count_view.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_count_view.expr_method_asset_count_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_count_view.expr_method_asset_count_view.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_count_view.expr_method_asset_count_view.exec({ as: alice })

    const my_asset_after = await expr_method_asset_count_view.expr_method_asset_count_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_count_view.expr_method_asset_count_view.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_method_asset_get', async () => {
    await expr_method_asset_get.expr_method_asset_get.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_get.expr_method_asset_get.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_get.expr_method_asset_get.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_get.expr_method_asset_get.exec({ as: alice })

    const my_asset_after = await expr_method_asset_get.expr_method_asset_get.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_get.expr_method_asset_get.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('expr_method_asset_head', async () => {
    await expr_method_asset_head.expr_method_asset_head.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_head.expr_method_asset_head.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_head.expr_method_asset_head.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_head.expr_method_asset_head.exec({ as: alice })

    const my_asset_after = await expr_method_asset_head.expr_method_asset_head.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_head.expr_method_asset_head.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id1")
  })

  it('expr_method_asset_head_aggregate', async () => {
    await expr_method_asset_head_aggregate.expr_method_asset_head_aggregate.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_head_aggregate.expr_method_asset_head_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_head_aggregate.expr_method_asset_head_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await expr_method_asset_head_aggregate.expr_method_asset_head_aggregate.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_head_aggregate.expr_method_asset_head_aggregate.exec({ as: alice })

    const my_asset_after = await expr_method_asset_head_aggregate.expr_method_asset_head_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_head_aggregate.expr_method_asset_head_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_head_aggregate.expr_method_asset_head_aggregate.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('expr_method_asset_head_one_field', async () => {
    await expr_method_asset_head_one_field.expr_method_asset_head_one_field.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_head_one_field.expr_method_asset_head_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await expr_method_asset_head_one_field.expr_method_asset_head_one_field.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_head_one_field.expr_method_asset_head_one_field.exec({ as: alice })

    const my_asset_after = await expr_method_asset_head_one_field.expr_method_asset_head_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    const res_after = await expr_method_asset_head_one_field.expr_method_asset_head_one_field.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id1")
  })

  it('expr_method_asset_head_partition', async () => {
    await expr_method_asset_head_partition.expr_method_asset_head_partition.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_head_partition.expr_method_asset_head_partition.init({ as: alice })

    const my_asset_init = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    const res_init = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_res()
    assert(res_init.length == 0)

    await expr_method_asset_head_partition.expr_method_asset_head_partition.exec({ as: alice })

    const my_asset_after = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_head_partition.expr_method_asset_head_partition.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('expr_method_asset_head_view', async () => {
    await expr_method_asset_head_view.expr_method_asset_head_view.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_head_view.expr_method_asset_head_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_head_view.expr_method_asset_head_view.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_head_view.expr_method_asset_head_view.exec({ as: alice })

    const my_asset_after = await expr_method_asset_head_view.expr_method_asset_head_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_head_view.expr_method_asset_head_view.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id1")
  })

  it('expr_method_asset_nth', async () => {
    await expr_method_asset_nth.expr_method_asset_nth.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_nth.expr_method_asset_nth.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_nth.expr_method_asset_nth.get_res()
    assert(res_before.equals(Option.None()))

    await expr_method_asset_nth.expr_method_asset_nth.exec({ as: alice })

    const my_asset_after = await expr_method_asset_nth.expr_method_asset_nth.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_nth.expr_method_asset_nth.get_res()
    assert(res_after.equals(Option.Some<string>("id1")))
  })

  it('expr_method_asset_nth_aggregate', async () => {
    await expr_method_asset_nth_aggregate.expr_method_asset_nth_aggregate.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_nth_aggregate.expr_method_asset_nth_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_nth_aggregate.expr_method_asset_nth_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await expr_method_asset_nth_aggregate.expr_method_asset_nth_aggregate.get_res()
    assert(res_before.equals(Option.None()))

    await expr_method_asset_nth_aggregate.expr_method_asset_nth_aggregate.exec({ as: alice })

    const my_asset_after = await expr_method_asset_nth_aggregate.expr_method_asset_nth_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_nth_aggregate.expr_method_asset_nth_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_nth_aggregate.expr_method_asset_nth_aggregate.get_res()
    assert(res_after.equals(Option.Some(new Nat(1))))
  })

  it('expr_method_asset_nth_one_field', async () => {
    await expr_method_asset_nth_one_field.expr_method_asset_nth_one_field.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_nth_one_field.expr_method_asset_nth_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await expr_method_asset_nth_one_field.expr_method_asset_nth_one_field.get_res()
    assert(res_before.equals(Option.None()))

    await expr_method_asset_nth_one_field.expr_method_asset_nth_one_field.exec({ as: alice })

    const my_asset_after = await expr_method_asset_nth_one_field.expr_method_asset_nth_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    const res_after = await expr_method_asset_nth_one_field.expr_method_asset_nth_one_field.get_res()
    assert(res_after.equals(Option.Some<string>("id1")))
  })

  it('expr_method_asset_nth_partition', async () => {
    await expr_method_asset_nth_partition.expr_method_asset_nth_partition.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_res()
    assert(res_before.equals(Option.None()))

    await expr_method_asset_nth_partition.expr_method_asset_nth_partition.init({ as: alice })

    const my_asset_init = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    const res_init = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_res()
    assert(res_init.equals(Option.None()))

    await expr_method_asset_nth_partition.expr_method_asset_nth_partition.exec({ as: alice })

    const my_asset_after = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_nth_partition.expr_method_asset_nth_partition.get_res()
    assert(res_after.equals(Option.Some(new Nat(1))))
  })

  it('expr_method_asset_nth_view', async () => {
    await expr_method_asset_nth_view.expr_method_asset_nth_view.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_nth_view.expr_method_asset_nth_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_nth_view.expr_method_asset_nth_view.get_res()
    assert(res_before.equals(Option.None()))

    await expr_method_asset_nth_view.expr_method_asset_nth_view.exec({ as: alice })

    const my_asset_after = await expr_method_asset_nth_view.expr_method_asset_nth_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_nth_view.expr_method_asset_nth_view.get_res()
    assert(res_after.equals(Option.Some<string>("id1")))
  })

  it('expr_method_asset_select', async () => {
    await expr_method_asset_select.expr_method_asset_select.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_select.expr_method_asset_select.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_select.expr_method_asset_select.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_select.expr_method_asset_select.exec({ as: alice })

    const my_asset_after = await expr_method_asset_select.expr_method_asset_select.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_select.expr_method_asset_select.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id2")
  })

  it('expr_method_asset_select_aggregate', async () => {
    await expr_method_asset_select_aggregate.expr_method_asset_select_aggregate.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_select_aggregate.expr_method_asset_select_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_select_aggregate.expr_method_asset_select_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await expr_method_asset_select_aggregate.expr_method_asset_select_aggregate.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_select_aggregate.expr_method_asset_select_aggregate.exec({ as: alice })

    const my_asset_after = await expr_method_asset_select_aggregate.expr_method_asset_select_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_select_aggregate.expr_method_asset_select_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_select_aggregate.expr_method_asset_select_aggregate.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('expr_method_asset_select_one_field', async () => {
    await expr_method_asset_select_one_field.expr_method_asset_select_one_field.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_select_one_field.expr_method_asset_select_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await expr_method_asset_select_one_field.expr_method_asset_select_one_field.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_select_one_field.expr_method_asset_select_one_field.exec({ as: alice })

    const my_asset_after = await expr_method_asset_select_one_field.expr_method_asset_select_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    const res_after = await expr_method_asset_select_one_field.expr_method_asset_select_one_field.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id2")
  })

  it('expr_method_asset_select_partition', async () => {
    await expr_method_asset_select_partition.expr_method_asset_select_partition.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_select_partition.expr_method_asset_select_partition.init({ as: alice })

    const my_asset_init = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    const res_init = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_res()
    assert(res_init.length == 0)

    await expr_method_asset_select_partition.expr_method_asset_select_partition.exec({ as: alice })

    const my_asset_after = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_select_partition.expr_method_asset_select_partition.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('expr_method_asset_select_view', async () => {
    await expr_method_asset_select_view.expr_method_asset_select_view.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_select_view.expr_method_asset_select_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_select_view.expr_method_asset_select_view.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_select_view.expr_method_asset_select_view.exec({ as: alice })

    const my_asset_after = await expr_method_asset_select_view.expr_method_asset_select_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_select_view.expr_method_asset_select_view.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id2")
  })

  it('expr_method_asset_sort', async () => {
    await expr_method_asset_sort.expr_method_asset_sort.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sort.expr_method_asset_sort.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_sort.expr_method_asset_sort.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_sort.expr_method_asset_sort.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sort.expr_method_asset_sort.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_sort.expr_method_asset_sort.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] == "id2")
    assert(res_after[1] == "id1")
    assert(res_after[2] == "id0")
  })

  it('expr_method_asset_sort_aggregate', async () => {
    await expr_method_asset_sort_aggregate.expr_method_asset_sort_aggregate.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sort_aggregate.expr_method_asset_sort_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_sort_aggregate.expr_method_asset_sort_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await expr_method_asset_sort_aggregate.expr_method_asset_sort_aggregate.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_sort_aggregate.expr_method_asset_sort_aggregate.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sort_aggregate.expr_method_asset_sort_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_sort_aggregate.expr_method_asset_sort_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_sort_aggregate.expr_method_asset_sort_aggregate.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('expr_method_asset_sort_one_field', async () => {
    await expr_method_asset_sort_one_field.expr_method_asset_sort_one_field.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sort_one_field.expr_method_asset_sort_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await expr_method_asset_sort_one_field.expr_method_asset_sort_one_field.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_sort_one_field.expr_method_asset_sort_one_field.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sort_one_field.expr_method_asset_sort_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    const res_after = await expr_method_asset_sort_one_field.expr_method_asset_sort_one_field.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] == "id2")
    assert(res_after[1] == "id1")
    assert(res_after[2] == "id0")
  })

  it('expr_method_asset_sort_partition', async () => {
    await expr_method_asset_sort_partition.expr_method_asset_sort_partition.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_sort_partition.expr_method_asset_sort_partition.init({ as: alice })

    const my_asset_init = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    const res_init = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_res()
    assert(res_init.length == 0)

    await expr_method_asset_sort_partition.expr_method_asset_sort_partition.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_sort_partition.expr_method_asset_sort_partition.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('expr_method_asset_sort_view', async () => {
    await expr_method_asset_sort_view.expr_method_asset_sort_view.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sort_view.expr_method_asset_sort_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_sort_view.expr_method_asset_sort_view.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_sort_view.expr_method_asset_sort_view.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sort_view.expr_method_asset_sort_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_sort_view.expr_method_asset_sort_view.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] == "id2")
    assert(res_after[1] == "id1")
    assert(res_after[2] == "id0")
  })

  it('expr_method_asset_sum', async () => {
    await expr_method_asset_sum.expr_method_asset_sum.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sum.expr_method_asset_sum.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_sum.expr_method_asset_sum.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_sum.expr_method_asset_sum.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sum.expr_method_asset_sum.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_sum.expr_method_asset_sum.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_method_asset_sum_aggregate', async () => {
    await expr_method_asset_sum_aggregate.expr_method_asset_sum_aggregate.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sum_aggregate.expr_method_asset_sum_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_sum_aggregate.expr_method_asset_sum_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await expr_method_asset_sum_aggregate.expr_method_asset_sum_aggregate.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_sum_aggregate.expr_method_asset_sum_aggregate.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sum_aggregate.expr_method_asset_sum_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_sum_aggregate.expr_method_asset_sum_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_sum_aggregate.expr_method_asset_sum_aggregate.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_method_asset_sum_one_field', async () => {
    await expr_method_asset_sum_one_field.expr_method_asset_sum_one_field.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sum_one_field.expr_method_asset_sum_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await expr_method_asset_sum_one_field.expr_method_asset_sum_one_field.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_sum_one_field.expr_method_asset_sum_one_field.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sum_one_field.expr_method_asset_sum_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_sum_one_field.expr_method_asset_sum_one_field.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_method_asset_sum_partition', async () => {
    await expr_method_asset_sum_partition.expr_method_asset_sum_partition.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_sum_partition.expr_method_asset_sum_partition.init({ as: alice })

    const my_asset_init = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    const res_init = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_res()
    assert(res_init.equals(new Nat(0)))

    await expr_method_asset_sum_partition.expr_method_asset_sum_partition.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_sum_partition.expr_method_asset_sum_partition.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_method_asset_sum_rational', async () => {
    await expr_method_asset_sum_rational.expr_method_asset_sum_rational.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sum_rational.expr_method_asset_sum_rational.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Rational(0.1)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Rational(0.2)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Rational(0.5)))
    const res_before = await expr_method_asset_sum_rational.expr_method_asset_sum_rational.get_res()
    assert(res_before.equals(new Rational(0)))

    await expr_method_asset_sum_rational.expr_method_asset_sum_rational.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sum_rational.expr_method_asset_sum_rational.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Rational(0.1)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Rational(0.2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Rational(0.5)))
    const res_after = await expr_method_asset_sum_rational.expr_method_asset_sum_rational.get_res()
    assert(res_after.equals(new Rational(0.8)))
  })

  it('expr_method_asset_sum_view', async () => {
    await expr_method_asset_sum_view.expr_method_asset_sum_view.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_sum_view.expr_method_asset_sum_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_sum_view.expr_method_asset_sum_view.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_method_asset_sum_view.expr_method_asset_sum_view.exec({ as: alice })

    const my_asset_after = await expr_method_asset_sum_view.expr_method_asset_sum_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_sum_view.expr_method_asset_sum_view.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_method_asset_tail', async () => {
    await expr_method_asset_tail.expr_method_asset_tail.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_tail.expr_method_asset_tail.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_tail.expr_method_asset_tail.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_tail.expr_method_asset_tail.exec({ as: alice })

    const my_asset_after = await expr_method_asset_tail.expr_method_asset_tail.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_tail.expr_method_asset_tail.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id1")
    assert(res_after[1] == "id2")
  })

  it('expr_method_asset_tail_aggregate', async () => {
    await expr_method_asset_tail_aggregate.expr_method_asset_tail_aggregate.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_tail_aggregate.expr_method_asset_tail_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_tail_aggregate.expr_method_asset_tail_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await expr_method_asset_tail_aggregate.expr_method_asset_tail_aggregate.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_tail_aggregate.expr_method_asset_tail_aggregate.exec({ as: alice })

    const my_asset_after = await expr_method_asset_tail_aggregate.expr_method_asset_tail_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_tail_aggregate.expr_method_asset_tail_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_tail_aggregate.expr_method_asset_tail_aggregate.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('expr_method_asset_tail_one_field', async () => {
    await expr_method_asset_tail_one_field.expr_method_asset_tail_one_field.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_tail_one_field.expr_method_asset_tail_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await expr_method_asset_tail_one_field.expr_method_asset_tail_one_field.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_tail_one_field.expr_method_asset_tail_one_field.exec({ as: alice })

    const my_asset_after = await expr_method_asset_tail_one_field.expr_method_asset_tail_one_field.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0] == "id0")
    assert(my_asset_after[1] == "id1")
    assert(my_asset_after[2] == "id2")
    const res_after = await expr_method_asset_tail_one_field.expr_method_asset_tail_one_field.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id1")
    assert(res_after[1] == "id2")
  })

  it('expr_method_asset_tail_partition', async () => {
    await expr_method_asset_tail_partition.expr_method_asset_tail_partition.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_tail_partition.expr_method_asset_tail_partition.init({ as: alice })

    const my_asset_init = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    const res_init = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_res()
    assert(res_init.length == 0)

    await expr_method_asset_tail_partition.expr_method_asset_tail_partition.exec({ as: alice })

    const my_asset_after = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await expr_method_asset_tail_partition.expr_method_asset_tail_partition.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('expr_method_asset_tail_view', async () => {
    await expr_method_asset_tail_view.expr_method_asset_tail_view.deploy({ as: alice })

    const my_asset_before = await expr_method_asset_tail_view.expr_method_asset_tail_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await expr_method_asset_tail_view.expr_method_asset_tail_view.get_res()
    assert(res_before.length == 0)

    await expr_method_asset_tail_view.expr_method_asset_tail_view.exec({ as: alice })

    const my_asset_after = await expr_method_asset_tail_view.expr_method_asset_tail_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await expr_method_asset_tail_view.expr_method_asset_tail_view.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id1")
    assert(res_after[1] == "id2")
  })

  it('expr_multicmp', async () => {
    await expr_multicmp.expr_multicmp.deploy({ as: alice })

    const res_before = await expr_multicmp.expr_multicmp.get_res()
    assert(res_before == false)

    await expr_multicmp.expr_multicmp.exec({ as: alice })

    const res_after = await expr_multicmp.expr_multicmp.get_res()
    assert(res_after == true)
  })

  it('expr_option_map', async () => {
    await expr_option_map.expr_option_map.deploy({ as: alice })

    const res_before = await expr_option_map.expr_option_map.get_res()
    assert(res_before.equals(Option.None()))

    await expr_option_map.expr_option_map.exec({ as: alice })

    const res_after = await expr_option_map.expr_option_map.get_res()
    assert(res_after.equals(Option.Some(new Nat(2))))
  })

  it('expr_record_lit', async () => {
    await expr_record_lit.expr_record_lit.deploy({ as: alice })

    const res_before = await expr_record_lit.expr_record_lit.get_res()
    assert(res_before.equals(new expr_record_lit.my_record("", new Int(0), new Nat(0))))

    await expr_record_lit.expr_record_lit.exec({ as: alice })

    const res_after = await expr_record_lit.expr_record_lit.get_res()
    assert(res_after.equals(new expr_record_lit.my_record("mystr", new Int(1), new Nat(3))))
  })

  it('expr_record_update_record_in_exec', async () => {
    await expr_record_update_record_in_exec.expr_record_update_record_in_exec.deploy({ as: alice })

    const res_before = await expr_record_update_record_in_exec.expr_record_update_record_in_exec.get_res()
    assert(res_before.equals(new expr_record_update_record_in_exec.my_record(new Nat(0), "")))

    await expr_record_update_record_in_exec.expr_record_update_record_in_exec.exec({ as: alice })

    const res_after = await expr_record_update_record_in_exec.expr_record_update_record_in_exec.get_res()
    assert(res_after.equals(new expr_record_update_record_in_exec.my_record(new Nat(1), "mystr")))
  })

  it('expr_set_add', async () => {
    await expr_set_add.expr_set_add.deploy({ as: alice })

    const res_before = await expr_set_add.expr_set_add.get_res()
    assert(res_before.length == 0)

    await expr_set_add.expr_set_add.exec({ as: alice })

    const res_after = await expr_set_add.expr_set_add.get_res()
    assert(res_after.length == 4)
    assert(res_after[0] = "0")
    assert(res_after[1] = "1")
    assert(res_after[2] = "2")
    assert(res_after[3] = "3")
  })

  it('expr_set_contains', async () => {
    await expr_set_contains.expr_set_contains.deploy({ as: alice })

    const res_before = await expr_set_contains.expr_set_contains.get_res()
    assert(res_before == false)

    await expr_set_contains.expr_set_contains.exec({ as: alice })

    const res_after = await expr_set_contains.expr_set_contains.get_res()
    assert(res_after == true)
  })

  it('expr_set_length', async () => {
    await expr_set_length.expr_set_length.deploy({ as: alice })

    const res_before = await expr_set_length.expr_set_length.get_res()
    assert(res_before.equals(new Nat(0)))

    await expr_set_length.expr_set_length.exec({ as: alice })

    const res_after = await expr_set_length.expr_set_length.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('expr_set_lit', async () => {
    await expr_set_lit.expr_set_lit.deploy({ as: alice })

    const res_before = await expr_set_lit.expr_set_lit.get_res()
    assert(res_before.length == 0)

    await expr_set_lit.expr_set_lit.exec({ as: alice })

    const res_after = await expr_set_lit.expr_set_lit.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] = "0")
    assert(res_after[1] = "1")
    assert(res_after[2] = "2")
  })

  it('expr_set_remove', async () => {
    await expr_set_remove.expr_set_remove.deploy({ as: alice })

    const res_before = await expr_set_remove.expr_set_remove.get_res()
    assert(res_before.length == 0)

    await expr_set_remove.expr_set_remove.exec({ as: alice })

    const res_after = await expr_set_remove.expr_set_remove.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] = "2")
    assert(res_after[1] = "3")
  })

  it('expr_set_update', async () => {
    await expr_set_update.expr_set_update.deploy({ as: alice })

    const res_before = await expr_set_update.expr_set_update.get_res()
    assert(res_before.length == 0)

    await expr_set_update.expr_set_update.exec({ as: alice })

    const res_after = await expr_set_update.expr_set_update.get_res()
    assert(res_after.length == 4)
    assert(res_after[0] = "0")
    assert(res_after[1] = "1")
    assert(res_after[2] = "2")
    assert(res_after[3] = "3")
  })

  it('expr_tuple_access', async () => {
    await expr_tuple_access.expr_tuple_access.deploy({ as: alice })

    await expr_tuple_access.expr_tuple_access.exec({ as: alice })
  })

  it('expr_tuple_access_simple', async () => {
    await expr_tuple_access_simple.expr_tuple_access_simple.deploy({ as: alice })

    const n_before = await expr_tuple_access_simple.expr_tuple_access_simple.get_n()
    assert(n_before.equals(new Nat(0)))

    await expr_tuple_access_simple.expr_tuple_access_simple.exec({ as: alice })

    const n_after = await expr_tuple_access_simple.expr_tuple_access_simple.get_n()
    assert(n_after.equals(new Nat(3)))
  })

  it('expr_var_match_list_empty', async () => {
    await expr_var_match_list_empty.expr_var_match_list_empty.deploy({ as: alice })
    const res_before = await expr_var_match_list_empty.expr_var_match_list_empty.get_res();
    assert(res_before == "")
    await expr_var_match_list_empty.expr_var_match_list_empty.exec({ as: alice })
    const res_after = await expr_var_match_list_empty.expr_var_match_list_empty.get_res();
    assert(res_after == "mystr")
  })

  it('expr_var_match_list_head', async () => {
    await expr_var_match_list_head.expr_var_match_list_head.deploy({ as: alice })
    const res_before = await expr_var_match_list_head.expr_var_match_list_head.get_res();
    assert(res_before == "")
    await expr_var_match_list_head.expr_var_match_list_head.exec({ as: alice })
    const res_after = await expr_var_match_list_head.expr_var_match_list_head.get_res();
    assert(res_after == "mystr")
  })

  it('expr_var_match_option_none', async () => {
    await expr_var_match_option_none.expr_var_match_option_none.deploy({ as: alice })
    const res_before = await expr_var_match_option_none.expr_var_match_option_none.get_res();
    assert(res_before == "")
    await expr_var_match_option_none.expr_var_match_option_none.exec({ as: alice })
    const res_after = await expr_var_match_option_none.expr_var_match_option_none.get_res();
    assert(res_after == "mystr")
  })

  it('expr_var_match_option_some', async () => {
    await expr_var_match_option_some.expr_var_match_option_some.deploy({ as: alice })
    const res_before = await expr_var_match_option_some.expr_var_match_option_some.get_res();
    assert(res_before == "")
    await expr_var_match_option_some.expr_var_match_option_some.exec({ as: alice })
    const res_after = await expr_var_match_option_some.expr_var_match_option_some.get_res();
    assert(res_after == "mystr")
  })

  it('expr_var_match_or_left', async () => {
    await expr_var_match_or_left.expr_var_match_or_left.deploy({ as: alice })
    const res_before = await expr_var_match_or_left.expr_var_match_or_left.get_res();
    assert(res_before == "")
    await expr_var_match_or_left.expr_var_match_or_left.exec({ as: alice })
    const res_after = await expr_var_match_or_left.expr_var_match_or_left.get_res();
    assert(res_after == "mystr")
  })

  it('expr_var_match_or_right', async () => {
    await expr_var_match_or_right.expr_var_match_or_right.deploy({ as: alice })
    const res_before = await expr_var_match_or_right.expr_var_match_or_right.get_res();
    assert(res_before == "")
    await expr_var_match_or_right.expr_var_match_or_right.exec({ as: alice })
    const res_after = await expr_var_match_or_right.expr_var_match_or_right.get_res();
    assert(res_after == "mystr")
  })

  it('fa12_false', async () => {
    await fa12_false.fa12_false.deploy({ as: alice })

    const value_before = await fa12_false.fa12_false.get_ledger_value(new Int(0))
    assert(value_before?.equals(new Nat(10000000)))

    await fa12_false.fa12_false.transfer(new Int(0), { as: alice })

    const value_after = await fa12_false.fa12_false.get_ledger_value(new Int(0))
    assert(value_after?.equals(new Nat(10000001)))

    await expect_to_fail(async () => {
      await fa12_false.fa12_false.transfer(new Int(1), { as: alice })
    }, { prim: "Pair", args: [{ string: "ASSET_NOT_FOUND" }, { string: "ledger" }] })
  })

  it('fa12_simple', async () => {
    await fa12_simple.fa12_simple.deploy({ as: alice })

    const value_0_before = await fa12_simple.fa12_simple.get_ledger_value(new Int(0))
    assert(value_0_before?.equals(new Nat(10000000)))
    const value_1_before = await fa12_simple.fa12_simple.get_ledger_value(new Int(1))
    assert(value_1_before?.equals(new Nat(0)))

    await fa12_simple.fa12_simple.transfer(new Int(0), new Int(1), new Nat(1), { as: alice })

    const value_0_after = await fa12_simple.fa12_simple.get_ledger_value(new Int(0))
    assert(value_0_after?.equals(new Nat(9999999)))
    const value_1_after = await fa12_simple.fa12_simple.get_ledger_value(new Int(1))
    assert(value_1_after?.equals(new Nat(1)))
  })

  it('fail_', async () => {
    await fail_.fail_.deploy({ as: alice })

    await expect_to_fail(async () => {
      await fail_.fail_.exec({ as: alice })
    }, { string: "KO" })
  })

  it('fail_for', async () => {
    await fail_for.fail_for.deploy({ as: alice })

    await expect_to_fail(async () => {
      await fail_for.fail_for.exec({ as: alice })
    }, { string: "KO" })
  })

  it('fail_if', async () => {
    await fail_if.fail_if.deploy({ as: alice })

    await expect_to_fail(async () => {
      await fail_if.fail_if.f({ as: alice })
    }, { string: "OK" })
  })

  it('fail_match_list', async () => {
    await fail_match_list.fail_match_list.deploy({ as: alice })

    await expect_to_fail(async () => {
      await fail_match_list.fail_match_list.exec({ as: alice })
    }, { string: "OK" })
  })

  it('fail_match_option', async () => {
    await fail_match_option.fail_match_option.deploy({ as: alice })

    await expect_to_fail(async () => {
      await fail_match_option.fail_match_option.exec({ as: alice })
    }, { string: "OK" })
  })

  it('fail_while', async () => {
    await fail_while.fail_while.deploy({ as: alice })

    await expect_to_fail(async () => {
      await fail_while.fail_while.f({ as: alice })
    }, { string: "OK" })
  })

  it('fail_with_tuple_lit', async () => {
    await fail_with_tuple_lit.fail_with_tuple_lit.deploy({ as: alice })
    expect_to_fail(async () => {
      await fail_with_tuple_lit.fail_with_tuple_lit.exec({ as: alice })
    }, { prim: "Pair", args: [{ string: "error" }, { int: "0" }] })
  })

  it('fold_reverse', async () => {
    await fold_reverse.fold_reverse.deploy({ as: alice })

    const res_before = await fold_reverse.fold_reverse.get_res()
    assert(res_before.length == 0)

    await fold_reverse.fold_reverse.exec({ as: alice })

    const res_after = await fold_reverse.fold_reverse.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(3)))
    assert(res_after[1].equals(new Nat(2)))
    assert(res_after[2].equals(new Nat(1)))
  })

  it('fun', async () => {
    await fun.fun.deploy({ as: alice })

    const res_before = await fun.fun.get_res()
    assert(res_before.equals(new Int(0)))

    await fun.fun.exec({ as: alice })

    const res_after = await fun.fun.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('fun_entry_pure', async () => {
    await fun_entry_pure.fun_entry_pure.deploy({ as: alice })

    const res_before = await fun_entry_pure.fun_entry_pure.get_res()
    assert(res_before.equals(new Nat(0)))

    await fun_entry_pure.fun_entry_pure.exec({ as: alice })

    const res_after = await fun_entry_pure.fun_entry_pure.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('fun_entry_read', async () => {
    await fun_entry_read.fun_entry_read.deploy({ as: alice })

    const res_before = await fun_entry_read.fun_entry_read.get_res()
    assert(res_before.equals(new Nat(1)))

    await fun_entry_read.fun_entry_read.exec({ as: alice })

    const res_after = await fun_entry_read.fun_entry_read.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('fun_entry_write', async () => {
    await fun_entry_write.fun_entry_write.deploy({ as: alice })

    const res_before = await fun_entry_write.fun_entry_write.get_res()
    assert(res_before.equals(new Nat(0)))

    await fun_entry_write.fun_entry_write.exec({ as: alice })

    const res_after = await fun_entry_write.fun_entry_write.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('fun_entry_write_with_transfer', async () => {
    await fun_entry_write_with_transfer.fun_entry_write_with_transfer.deploy({ as: alice, amount: new Tez(1) })

    const alice_balance_before = await alice.get_balance()
    const res_before = await fun_entry_write_with_transfer.fun_entry_write_with_transfer.get_res()
    assert(res_before.equals(new Nat(0)))

    await fun_entry_write_with_transfer.fun_entry_write_with_transfer.exec(alice.get_address(), { as: bob })

    const alice_balance_after = await alice.get_balance()
    const res_after = await fun_entry_write_with_transfer.fun_entry_write_with_transfer.get_res()
    assert(res_after.equals(new Nat(2)))
    assert(alice_balance_before.plus(new Tez(1)).equals(alice_balance_after))
  })

  it('fun_instr_unit', async () => {
    await fun_instr_unit.fun_instr_unit.deploy({ as: alice })

    const res_before = await fun_instr_unit.fun_instr_unit.get_res()
    assert(res_before.equals(new Nat(0)))

    await fun_instr_unit.fun_instr_unit.exec({ as: alice })

    const res_after = await fun_instr_unit.fun_instr_unit.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('fun_instr_unit_arg', async () => {
    await fun_instr_unit_arg.fun_instr_unit_arg.deploy({ as: alice })

    const res_before = await fun_instr_unit_arg.fun_instr_unit_arg.get_res()
    assert(res_before.equals(new Nat(0)))

    await fun_instr_unit_arg.fun_instr_unit_arg.exec({ as: alice })

    const res_after = await fun_instr_unit_arg.fun_instr_unit_arg.get_res()
    assert(res_after.equals(new Nat(7)))
  })

  it('fun_instr_unit_arg_side_effect', async () => {
    await fun_instr_unit_arg_side_effect.fun_instr_unit_arg_side_effect.deploy({ as: alice })

    const res_before = await fun_instr_unit_arg_side_effect.fun_instr_unit_arg_side_effect.get_res()
    assert(res_before.equals(new Nat(0)))

    await fun_instr_unit_arg_side_effect.fun_instr_unit_arg_side_effect.exec({ as: alice })

    const res_after = await fun_instr_unit_arg_side_effect.fun_instr_unit_arg_side_effect.get_res()
    assert(res_after.equals(new Nat(5)))
  })

  it('fun_unit', async () => {
    await fun_unit.fun_unit.deploy({ as: alice })

    const u_before = await fun_unit.fun_unit.get_u()
    assert(u_before.equals(new Unit()))

    await fun_unit.fun_unit.exec({ as: alice })

    const u_after = await fun_unit.fun_unit.get_u()
    assert(u_after.equals(new Unit()))
  })

  it('fun_view_instr_pure', async () => {
    await fun_view_instr_pure.fun_view_instr_pure.deploy({ as: alice })

    const res = await fun_view_instr_pure.fun_view_instr_pure.view_my_view({ as: alice })
    assert(res && res.equals(new Nat(0)))
  })

  it('fun_view_pure', async () => {
    await fun_view_pure.fun_view_pure.deploy({ as: alice })

    const res = await fun_view_pure.fun_view_pure.view_my_view({ as: alice });
    assert(res && res.equals(new Nat(2)))
  })

  it('fun_view_read', async () => {
    await fun_view_read.fun_view_read.deploy({ as: alice })

    const res = await fun_view_read.fun_view_read.view_my_view({ as: alice });
    assert(res && res.equals(new Nat(3)))
  })

  it('fun_view_read_asset', async () => {
    await fun_view_read_asset.fun_view_read_asset.deploy({ as: alice })

    const res = await fun_view_read_asset.fun_view_read_asset.view_v({ as: alice });
    assert(res == "mystr")
  })

  it('function_with_nat_to_string', async () => {
    await function_with_nat_to_string.function_with_nat_to_string.deploy({ as: alice })
    const res_before = await function_with_nat_to_string.function_with_nat_to_string.get_res();
    assert(res_before == "", "Invalid Value")
    await function_with_nat_to_string.function_with_nat_to_string.exec(new Nat(256), { as: alice })
    const res_after = await function_with_nat_to_string.function_with_nat_to_string.get_res();
    assert(res_after == "256", "Invalid Value")
  })

  it('function_with_simplify_rational', async () => {
    await function_with_simplify_rational.function_with_simplify_rational.deploy({ as: alice })
    const res_before = await function_with_simplify_rational.function_with_simplify_rational.get_res();
    assert(res_before.equals(new Rational(0)), "Invalid Value")
    await function_with_simplify_rational.function_with_simplify_rational.exec(new Rational(36, new BigNumber(48)), { as: alice })
    const res_after = await function_with_simplify_rational.function_with_simplify_rational.get_res();
    assert(res_after.equals(new Rational(3, new BigNumber(4))), "Invalid Value")
  })

  it('get_in_require_failif', async () => {
    await get_in_require_failif.get_in_require_failif.deploy({ as: alice })

    const res_before = await get_in_require_failif.get_in_require_failif.get_res()
    assert(res_before == false)

    await get_in_require_failif.get_in_require_failif.exec({ as: alice })

    const res_after = await get_in_require_failif.get_in_require_failif.get_res()
    assert(res_after == true)
  })

  it('get_some_with_msg', async () => {
    await get_some_with_msg.get_some_with_msg.deploy({ as: alice })

    const res_before = await get_some_with_msg.get_some_with_msg.get_res()
    assert(res_before.equals(new Nat(0)))

    await get_some_with_msg.get_some_with_msg.exec({ as: alice })

    const res_after = await get_some_with_msg.get_some_with_msg.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('getter_called_by', async () => {
    await getter_called_by.getter_called_by.deploy({ as: alice })

    await expect_to_fail(async () => {
      await getter_called_by.getter_called_by.get({ as: bob })
    }, { "string": "INVALID_CALLER" })

    const res = await getter_called_by.getter_called_by.get({ as: alice })
    assert(res.equals(new Nat(2)))
  })

  it('greedy_and', async () => {
    await greedy_and.greedy_and.deploy({ as: alice })

    const res_before = await greedy_and.greedy_and.get_res()
    assert(res_before == false)

    await greedy_and.greedy_and.exec({ as: alice })

    const res_after = await greedy_and.greedy_and.get_res()
    assert(res_after == true)
  })

  it('greedy_or', async () => {
    await greedy_or.greedy_or.deploy({ as: alice })

    const res_before = await greedy_or.greedy_or.get_res()
    assert(res_before == false)

    await greedy_or.greedy_or.exec({ as: alice })

    const res_after = await greedy_or.greedy_or.get_res()
    assert(res_after == true)
  })

  it('implicit_cast_to_view', async () => {
    await implicit_cast_to_view.implicit_cast_to_view.deploy({ as: alice })

    const res_before = await implicit_cast_to_view.implicit_cast_to_view.get_res()
    assert(res_before.equals(new Int(0)))

    await implicit_cast_to_view.implicit_cast_to_view.exec({ as: alice })

    const res_after = await implicit_cast_to_view.implicit_cast_to_view.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('implicit_the', async () => {
    await implicit_the.implicit_the.deploy({ as: alice })

    const res_before = await implicit_the.implicit_the.get_res()
    assert(res_before.length == 0)

    await implicit_the.implicit_the.exec({ as: alice })

    const res_after = await implicit_the.implicit_the.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id2")
  })

  it('import_arl_all_def', async () => {
    await import_arl_all_def.import_arl_all_def.deploy({ as: alice })
  })

  it('import_arl_asset_container_use_arg', async () => {
    await import_arl_asset_container_use_arg.import_arl_asset_container_use_arg.deploy({ as: alice })
    // TODO: import
  })

  it('import_arl_asset_container_use_arg_collide', async () => {
    await import_arl_asset_container_use_arg_collide.import_arl_asset_container_use_arg_collide.deploy({ as: alice })
    // TODO: import
  })

  it('import_arl_asset_def', async () => {
    await import_arl_asset_def.import_arl_asset_def.deploy({ as: alice })
  })

  it('import_arl_asset_key_use_arg', async () => {
    await import_arl_asset_key_use_arg.import_arl_asset_key_use_arg.deploy({ as: alice })

    const r = new Nat(2)

    const res_before = await import_arl_asset_key_use_arg.import_arl_asset_key_use_arg.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_asset_key_use_arg.import_arl_asset_key_use_arg.exec(r, { as: alice })

    const res_after = await import_arl_asset_key_use_arg.import_arl_asset_key_use_arg.get_res()
    assert(res_after.equals(Option.Some(r)))
  })

  it('import_arl_asset_key_use_arg_collide', async () => {
    await import_arl_asset_key_use_arg_collide.import_arl_asset_key_use_arg_collide.deploy({ as: alice })
    // TODO: import
  })

  it('import_arl_asset_use_all', async () => {
    await import_arl_asset_use_all.import_arl_asset_use_all.deploy({ as: alice })

    const r = new import_arl_asset_use_all.import_arl_all_def__my_asset_value("mystr", new Bytes("02"), new Int(3));

    const res_before = await import_arl_asset_use_all.import_arl_asset_use_all.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_asset_use_all.import_arl_asset_use_all.exec(r, { as: alice })

    const res_after = await import_arl_asset_use_all.import_arl_asset_use_all.get_res()
    assert(res_after.equals(Option.Some(r)))
  })

  it('import_arl_asset_value_use_arg', async () => {
    await import_arl_asset_value_use_arg.import_arl_asset_value_use_arg.deploy({ as: alice })

    const r = "mystr";

    const res_before = await import_arl_asset_value_use_arg.import_arl_asset_value_use_arg.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_asset_value_use_arg.import_arl_asset_value_use_arg.exec(r, { as: alice })

    const res_after = await import_arl_asset_value_use_arg.import_arl_asset_value_use_arg.get_res()
    assert(res_after.equals(Option.Some<string>(r)))
  })

  it('import_arl_asset_value_use_arg_collide', async () => {
    await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.deploy({ as: alice })

    const r = "mystr";
    const q = new import_arl_asset_value_use_arg_collide.my_asset_value(true, new Int(0));

    const res_imported_before = await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_top_before = await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.get_res_top()
    assert(res_top_before.equals(Option.None()))

    await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.exec_imported(r, { as: alice })

    const res_imported_0 = await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.get_res_imported()
    assert(res_imported_0.equals(Option.Some<string>(r)))
    const res_top_0 = await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.get_res_top()
    assert(res_top_0.equals(Option.None()))

    await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.exec_top(q, { as: alice })

    const res_imported_after = await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.get_res_imported()
    assert(res_imported_after.equals(Option.Some<string>(r)))
    const res_top_after = await import_arl_asset_value_use_arg_collide.import_arl_asset_value_use_arg_collide.get_res_top()
    assert(res_top_after.equals(Option.Some(q)))
  })

  it('import_arl_asset_view_use_arg', async () => {
    await import_arl_asset_view_use_arg.import_arl_asset_view_use_arg.deploy({ as: alice })

    const vs: Array<Nat> = [new Nat(0), new Nat(1), new Nat(2)]

    const res_before = await import_arl_asset_view_use_arg.import_arl_asset_view_use_arg.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_asset_view_use_arg.import_arl_asset_view_use_arg.exec(vs, { as: alice })

    const res_after = await import_arl_asset_view_use_arg.import_arl_asset_view_use_arg.get_res()
    assert(res_after.equals(Option.Some(vs)))
  })

  it('import_arl_asset_view_use_arg_collide', async () => {
    await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.deploy({ as: alice })

    const vs: Array<Nat> = [new Nat(0), new Nat(1), new Nat(2)]
    const ws: Array<Bytes> = [new Bytes("00"), new Bytes("01"), new Bytes("02")]

    const res_imported_before = await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_top_before = await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.get_res_top()
    assert(res_top_before.equals(Option.None()))

    await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.exec_imported(vs, { as: alice })

    const res_imported_0 = await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.get_res_imported()
    assert(res_imported_0.equals(Option.Some(vs)))
    const res_top_0 = await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.get_res_top()
    assert(res_top_0.equals(Option.None()))

    await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.exec_top(ws, { as: alice })

    const res_imported_after = await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.get_res_imported()
    assert(res_imported_after.equals(Option.Some(vs)))
    const res_top_after = await import_arl_asset_view_use_arg_collide.import_arl_asset_view_use_arg_collide.get_res_top()
    assert(res_top_after.equals(Option.Some(ws)))
  })

  it('import_arl_constant_def', async () => {
    await import_arl_constant_def.import_arl_constant_def.deploy({ as: alice })
  })

  it('import_arl_constant_use', async () => {
    await import_arl_constant_use.import_arl_constant_use.deploy({ as: alice })

    const res_before = await import_arl_constant_use.import_arl_constant_use.get_res()
    assert(res_before.equals(new Nat(0)))

    await import_arl_constant_use.import_arl_constant_use.exec({ as: alice })

    const res_after = await import_arl_constant_use.import_arl_constant_use.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('import_arl_constant_use_all', async () => {
    await import_arl_constant_use_all.import_arl_constant_use_all.deploy({ as: alice })

    const res_before = await import_arl_constant_use_all.import_arl_constant_use_all.get_res()
    assert(res_before.equals(new Nat(0)))

    await import_arl_constant_use_all.import_arl_constant_use_all.exec({ as: alice })

    const res_after = await import_arl_constant_use_all.import_arl_constant_use_all.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('import_arl_constant_use_collide', async () => {
    await import_arl_constant_use_collide.import_arl_constant_use_collide.deploy({ as: alice })

    const res_imported_before = await import_arl_constant_use_collide.import_arl_constant_use_collide.get_res_imported()
    assert(res_imported_before.equals(new Nat(0)))
    const res_imported_top = await import_arl_constant_use_collide.import_arl_constant_use_collide.get_res_top()
    assert(res_imported_top == "")

    await import_arl_constant_use_collide.import_arl_constant_use_collide.exec({ as: alice })

    const res_imported_after = await import_arl_constant_use_collide.import_arl_constant_use_collide.get_res_imported()
    assert(res_imported_after.equals(new Nat(2)))
    const res_top_after = await import_arl_constant_use_collide.import_arl_constant_use_collide.get_res_top()
    assert(res_top_after == "mystr")
  })

  it('import_arl_entry_record_use_all', async () => {
    await import_arl_all_def.import_arl_all_def.deploy({ as: alice })
    await import_arl_entry_record_use_all.import_arl_entry_record_use_all.deploy({ as: alice })

    const res_before = await import_arl_entry_record_use_all.import_arl_entry_record_use_all.get_res()
    assert(res_before.equals(new Nat(0)))
    const myc_before = await import_arl_entry_record_use_all.import_arl_entry_record_use_all.get_myc()
    assert(myc_before == "")

    await import_arl_entry_record_use_all.import_arl_entry_record_use_all.exec(import_arl_all_def.import_arl_all_def.get_address(), { as: alice })

    const res_after = await import_arl_entry_record_use_all.import_arl_entry_record_use_all.get_res()
    assert(res_after.equals(new Nat(2)))
    const myc_after = await import_arl_entry_record_use_all.import_arl_entry_record_use_all.get_myc()
    assert(myc_after == "")
  })

  it('import_arl_entrypoint_def', async () => {
    await import_arl_entrypoint_def.import_arl_entrypoint_def.deploy({ as: alice })
  })

  it('import_arl_entrypoint_use', async () => {
    await import_arl_entrypoint_def.import_arl_entrypoint_def.deploy({ as: alice })
    await import_arl_entrypoint_use.import_arl_entrypoint_use.deploy({ as: alice })

    const res_before = await import_arl_entrypoint_use.import_arl_entrypoint_use.get_res()
    assert(res_before.equals(new Nat(0)))

    await import_arl_entrypoint_use.import_arl_entrypoint_use.exec(import_arl_entrypoint_def.import_arl_entrypoint_def.get_address(), { as: alice })

    const res_after = await import_arl_entrypoint_use.import_arl_entrypoint_use.get_res()
    assert(res_after.equals(new Nat(6)))
  })

  it('import_arl_entrypoint_use_collide', async () => {
    await import_arl_entrypoint_def.import_arl_entrypoint_def.deploy({ as: alice })
    await import_arl_entrypoint_use_collide.import_arl_entrypoint_use_collide.deploy({ as: alice })

    const res_imported_before = await import_arl_entrypoint_use_collide.import_arl_entrypoint_use_collide.get_res_imported()
    assert(res_imported_before.equals(new Nat(0)))
    const res_top_before = await import_arl_entrypoint_use_collide.import_arl_entrypoint_use_collide.get_res_top()
    assert(res_top_before.equals(new Nat(0)))

    await import_arl_entrypoint_use_collide.import_arl_entrypoint_use_collide.exec(import_arl_entrypoint_def.import_arl_entrypoint_def.get_address(), { as: alice })

    const res_imported_after = await import_arl_entrypoint_use_collide.import_arl_entrypoint_use_collide.get_res_imported()
    assert(res_imported_after.equals(new Nat(6)))
    const res_top_after = await import_arl_entrypoint_use_collide.import_arl_entrypoint_use_collide.get_res_top()
    assert(res_top_after.equals(new Nat(7)))
  })

  it('import_arl_enum_def', async () => {
    await import_arl_enum_def.import_arl_enum_def.deploy({ as: alice })
  })

  it('import_arl_enum_use', async () => {
    await import_arl_enum_use.import_arl_enum_use.deploy({ as: alice })

    const res_before = await import_arl_enum_use.import_arl_enum_use.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_enum_use.import_arl_enum_use.exec({ as: alice })

    const res_after = await import_arl_enum_use.import_arl_enum_use.get_res()
    assert(res_after.equals(Option.Some(new import_arl_enum_use.A())))
  })

  it('import_arl_enum_use_all', async () => {
    await import_arl_enum_use_all.import_arl_enum_use_all.deploy({ as: alice })

    const res_before = await import_arl_enum_use_all.import_arl_enum_use_all.get_res()
    assert(res_before.equals(new import_arl_enum_use_all.eFirst()))

    await import_arl_enum_use_all.import_arl_enum_use_all.exec({ as: alice })

    const res_after = await import_arl_enum_use_all.import_arl_enum_use_all.get_res()
    assert(res_after.equals(new import_arl_enum_use_all.eSecond()))
  })

  it('import_arl_enum_use_collide', async () => {
    await import_arl_enum_use_collide.import_arl_enum_use_collide.deploy({ as: alice })

    const res_imported_before = await import_arl_enum_use_collide.import_arl_enum_use_collide.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_imported_top = await import_arl_enum_use_collide.import_arl_enum_use_collide.get_res_top()
    assert(res_imported_top.equals(Option.None()))

    await import_arl_enum_use_collide.import_arl_enum_use_collide.exec({ as: alice })

    const res_imported_after = await import_arl_enum_use_collide.import_arl_enum_use_collide.get_res_imported()
    assert(res_imported_after.equals(Option.Some(new import_arl_enum_use_collide.A())))
    const res_top_after = await import_arl_enum_use_collide.import_arl_enum_use_collide.get_res_top()
    assert(res_top_after.equals(Option.Some(new import_arl_enum_use_collide.Z())))
  })

  it('import_arl_enum_use_complete', async () => {
    await import_arl_enum_use_complete.import_arl_enum_use_complete.deploy({ as: alice })

    const res_imported_before = await import_arl_enum_use_complete.import_arl_enum_use_complete.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_imported_top = await import_arl_enum_use_complete.import_arl_enum_use_complete.get_res_top()
    assert(res_imported_top.equals(Option.None()))

    await import_arl_enum_use_complete.import_arl_enum_use_complete.exec({ as: alice })

    const res_imported_after = await import_arl_enum_use_complete.import_arl_enum_use_complete.get_res_imported()
    assert(res_imported_after.equals(Option.Some(new import_arl_enum_use_complete.A())))
    const res_top_after = await import_arl_enum_use_complete.import_arl_enum_use_complete.get_res_top()
    assert(res_top_after.equals(Option.Some(new import_arl_enum_use_complete.Z())))
  })

  it('import_arl_enum_with_args_def', async () => {
    await import_arl_enum_with_args_def.import_arl_enum_with_args_def.deploy({ as: alice })
  })

  it('import_arl_enum_with_args_use', async () => {
    await import_arl_enum_with_args_use.import_arl_enum_with_args_use.deploy({ as: alice })

    const res_before = await import_arl_enum_with_args_use.import_arl_enum_with_args_use.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_enum_with_args_use.import_arl_enum_with_args_use.exec({ as: alice })

    const res_after = await import_arl_enum_with_args_use.import_arl_enum_with_args_use.get_res()
    assert(res_after.equals(Option.Some<import_arl_enum_with_args_use.import_arl_enum_with_args_def__my_enum>(new import_arl_enum_with_args_use.A(new Nat(0)))))
  })

  it('import_arl_enum_with_args_use_collide', async () => {
    await import_arl_enum_with_args_use_collide.import_arl_enum_with_args_use_collide.deploy({ as: alice })

    const res_imported_before = await import_arl_enum_with_args_use_collide.import_arl_enum_with_args_use_collide.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_imported_top = await import_arl_enum_with_args_use_collide.import_arl_enum_with_args_use_collide.get_res_top()
    assert(res_imported_top.equals(Option.None()))

    await import_arl_enum_with_args_use_collide.import_arl_enum_with_args_use_collide.exec({ as: alice })

    const res_imported_after = await import_arl_enum_with_args_use_collide.import_arl_enum_with_args_use_collide.get_res_imported()
    assert(res_imported_after.equals(Option.Some<import_arl_enum_with_args_use_collide.import_arl_enum_with_args_def__my_enum>(new import_arl_enum_with_args_use_collide.B("mystr"))))
    const res_top_after = await import_arl_enum_with_args_use_collide.import_arl_enum_with_args_use_collide.get_res_top()
    assert(res_top_after.equals(Option.Some<import_arl_enum_with_args_use_collide.my_enum>(new import_arl_enum_with_args_use_collide.Z(new Nat(2)))))
  })

  it('import_arl_enum_with_args_use_complete', async () => {
    await import_arl_enum_with_args_use_complete.import_arl_enum_with_args_use_complete.deploy({ as: alice })

    const res_imported_before = await import_arl_enum_with_args_use_complete.import_arl_enum_with_args_use_complete.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_imported_top = await import_arl_enum_with_args_use_complete.import_arl_enum_with_args_use_complete.get_res_top()
    assert(res_imported_top.equals(Option.None()))

    await import_arl_enum_with_args_use_complete.import_arl_enum_with_args_use_complete.exec({ as: alice })

    const res_imported_after = await import_arl_enum_with_args_use_complete.import_arl_enum_with_args_use_complete.get_res_imported()
    assert(res_imported_after.equals(Option.Some<import_arl_enum_with_args_use_complete.import_arl_enum_with_args_def__my_enum>(new import_arl_enum_with_args_use_complete.A(new Nat(2)))))
    const res_top_after = await import_arl_enum_with_args_use_complete.import_arl_enum_with_args_use_complete.get_res_top()
    assert(res_top_after.equals(Option.Some<import_arl_enum_with_args_use_complete.my_enum>(new import_arl_enum_with_args_use_complete.Z(new Nat(2)))))
  })

  it('import_arl_event_def', async () => {
    await import_arl_event_def.import_arl_event_def.deploy({ as: alice })
  })

  it('import_arl_event_use', async () => {
    await import_arl_event_use.import_arl_event_use.deploy({ as: alice })

    const ret = await import_arl_event_use.import_arl_event_use.exec({ as: alice });
    assert(ret.events.length == 1)
    assert(JSON.stringify(ret.events[0].payload) == '{"prim":"Pair","args":[{"int":"2"},{"string":"mystr"}]}')
  })

  it('import_arl_event_use_collide', async () => {
    await import_arl_event_use_collide.import_arl_event_use_collide.deploy({ as: alice })

    const ret = await import_arl_event_use_collide.import_arl_event_use_collide.exec({ as: alice });
    assert(ret.events.length == 2)
    assert(JSON.stringify(ret.events[0].payload) == '{"prim":"Pair","args":[{"int":"2"},{"string":"mystr"}]}')
    assert(JSON.stringify(ret.events[1].payload) == '{"prim":"Pair","args":[{"string":"mystr"},{"prim":"Pair","args":[{"int":"2"},{"bytes":"02"}]}]}')
  })

  it('import_arl_fun_2_pure_use', async () => {
    await import_arl_fun_2_pure_use.import_arl_fun_2_pure_use.deploy({ as: alice })

    const res_before = await import_arl_fun_2_pure_use.import_arl_fun_2_pure_use.get_res()
    assert(res_before.equals(new Nat(0)))

    await import_arl_fun_2_pure_use.import_arl_fun_2_pure_use.exec({ as: alice })

    const res_after = await import_arl_fun_2_pure_use.import_arl_fun_2_pure_use.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('import_arl_fun_def', async () => {
    await import_arl_fun_def.import_arl_fun_def.deploy({ as: alice })
  })

  it('import_arl_fun_def_pure', async () => {
    await import_arl_fun_def_pure.import_arl_fun_def_pure.deploy({ as: alice })
  })

  it('import_arl_fun_instr_pure_use', async () => {
    await import_arl_fun_instr_pure_use.import_arl_fun_instr_pure_use.deploy({ as: alice })

    const res_before = await import_arl_fun_instr_pure_use.import_arl_fun_instr_pure_use.get_res()
    assert(res_before.equals(new Nat(0)))

    await expect_to_fail(async () => {
      await import_arl_fun_instr_pure_use.import_arl_fun_instr_pure_use.exec({ as: alice })
    }, { string: "ok" })
  })

  it('import_arl_fun_pure_use', async () => {
    await import_arl_fun_pure_use.import_arl_fun_pure_use.deploy({ as: alice })

    const res_before = await import_arl_fun_pure_use.import_arl_fun_pure_use.get_res()
    assert(res_before.equals(new Nat(0)))

    await import_arl_fun_pure_use.import_arl_fun_pure_use.exec({ as: alice })

    const res_after = await import_arl_fun_pure_use.import_arl_fun_pure_use.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('import_arl_record_complex_0', async () => {
    await import_arl_record_complex_0.import_arl_record_complex_0.deploy({ as: alice })
  })

  it('import_arl_record_complex_1', async () => {
    await import_arl_record_complex_1.import_arl_record_complex_1.deploy({ as: alice })
  })

  it('import_arl_record_complex_2', async () => {
    await import_arl_record_complex_2.import_arl_record_complex_2.deploy({ as: alice })

    const res_before = await import_arl_record_complex_2.import_arl_record_complex_2.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_record_complex_2.import_arl_record_complex_2.exec({ as: alice })

    const res_after = await import_arl_record_complex_2.import_arl_record_complex_2.get_res()
    assert(res_after.equals(Option.Some(new import_arl_record_complex_2.import_arl_record_complex_1__my_record(new Nat(0), new import_arl_record_complex_2.import_arl_record_complex_0__rec(new Nat(2), "mystring")))))
  })

  it('import_arl_record_def', async () => {
    await import_arl_record_def.import_arl_record_def.deploy({ as: alice })
  })

  it('import_arl_record_use', async () => {
    await import_arl_record_use.import_arl_record_use.deploy({ as: alice })

    const res_before = await import_arl_record_use.import_arl_record_use.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_record_use.import_arl_record_use.exec({ as: alice })

    const res_after = await import_arl_record_use.import_arl_record_use.get_res()
    assert(res_after.equals(Option.Some(new import_arl_record_use.import_arl_record_def__my_record(new Nat(2), "mystr"))))
  })

  it('import_arl_record_use_all', async () => {
    await import_arl_record_use_all.import_arl_record_use_all.deploy({ as: alice })

    const res_before = await import_arl_record_use_all.import_arl_record_use_all.get_res()
    assert(res_before.equals(new import_arl_record_use_all.import_arl_all_def__my_record(new Nat(0), "")))
    const myc_before = await import_arl_record_use_all.import_arl_record_use_all.get_myc()
    assert(myc_before == "")
    const foo_before = await import_arl_record_use_all.import_arl_record_use_all.get_foo()
    assert(foo_before.equals(new Nat(0)))

    await import_arl_record_use_all.import_arl_record_use_all.exec({ as: alice })

    const res_after = await import_arl_record_use_all.import_arl_record_use_all.get_res()
    assert(res_after.equals(new import_arl_record_use_all.import_arl_all_def__my_record(new Nat(0), "mystr")))
    const myc_after = await import_arl_record_use_all.import_arl_record_use_all.get_myc()
    assert(myc_after == "")
    const foo_after = await import_arl_record_use_all.import_arl_record_use_all.get_foo()
    assert(foo_after.equals(new Nat(0)))
  })

  it('import_arl_record_use_collide', async () => {
    await import_arl_record_use_collide.import_arl_record_use_collide.deploy({ as: alice })

    const res_imported_before = await import_arl_record_use_collide.import_arl_record_use_collide.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_imported_top = await import_arl_record_use_collide.import_arl_record_use_collide.get_res_top()
    assert(res_imported_top.equals(Option.None()))

    await import_arl_record_use_collide.import_arl_record_use_collide.exec({ as: alice })

    const res_imported_after = await import_arl_record_use_collide.import_arl_record_use_collide.get_res_imported()
    assert(res_imported_after.equals(Option.Some(new import_arl_record_use_collide.import_arl_record_def__my_record(new Nat(2), "mystr"))))
    const res_top_after = await import_arl_record_use_collide.import_arl_record_use_collide.get_res_top()
    assert(res_top_after.equals(Option.Some(new import_arl_record_use_collide.my_record("mystr1", new Nat(3), new Bytes("03")))))
  })

  it('import_arl_record_use_complete', async () => {
    await import_arl_record_use_complete.import_arl_record_use_complete.deploy({ as: alice })

    const res_imported_before = await import_arl_record_use_complete.import_arl_record_use_complete.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_imported_top = await import_arl_record_use_complete.import_arl_record_use_complete.get_res_top()
    assert(res_imported_top.equals(Option.None()))

    await import_arl_record_use_complete.import_arl_record_use_complete.exec({ as: alice })

    const res_imported_after = await import_arl_record_use_complete.import_arl_record_use_complete.get_res_imported()
    assert(res_imported_after.equals(Option.Some(new import_arl_record_use_complete.import_arl_record_def__my_record(new Nat(2), "mystr"))))
    const res_top_after = await import_arl_record_use_complete.import_arl_record_use_complete.get_res_top()
    assert(res_top_after.equals(Option.Some(new import_arl_record_use_complete.my_record("", new Nat(0), new Bytes("02")))))
  })

  it('import_arl_transfer_use', async () => {
    await import_arl_all_def.import_arl_all_def.deploy({ as: alice })
    await import_arl_transfer_use.import_arl_transfer_use.deploy({ as: alice })

    const res_before = await import_arl_transfer_use.import_arl_transfer_use.get_res()
    assert(res_before.equals(new Nat(0)))
    const res_view_before = await import_arl_transfer_use.import_arl_transfer_use.get_res_view()
    assert(res_view_before.equals(Option.None()))

    await import_arl_transfer_use.import_arl_transfer_use.exec(import_arl_all_def.import_arl_all_def.get_address(), { as: alice })

    const res_after = await import_arl_transfer_use.import_arl_transfer_use.get_res()
    assert(res_after.equals(new Nat(2)))
    const res_view_after = await import_arl_transfer_use.import_arl_transfer_use.get_res_view()
    assert(res_view_after.equals(Option.Some(new Nat(2))))
  })

  it('import_arl_view_def', async () => {
    await import_arl_view_def.import_arl_view_def.deploy({ as: alice })
  })

  it('import_arl_view_use', async () => {
    await import_arl_view_def.import_arl_view_def.deploy({ as: alice })
    await import_arl_view_use.import_arl_view_use.deploy({ as: alice })

    const res_before = await import_arl_view_use.import_arl_view_use.get_res()
    assert(res_before.equals(Option.None()))

    await import_arl_view_use.import_arl_view_use.exec(import_arl_view_def.import_arl_view_def.get_address(), { as: alice })

    const res_after = await import_arl_view_use.import_arl_view_use.get_res()
    assert(res_after.equals(Option.Some(new Nat(5))))
  })

  it('import_arl_view_use_all', async () => {
    await import_arl_all_def.import_arl_all_def.deploy({ as: alice })
    await import_arl_view_use_all.import_arl_view_use_all.deploy({ as: alice })

    const res_before = await import_arl_view_use_all.import_arl_view_use_all.get_res()
    assert(res_before.equals(new Nat(0)))

    await import_arl_view_use_all.import_arl_view_use_all.exec(import_arl_all_def.import_arl_all_def.get_address(), { as: alice })

    const res_after = await import_arl_view_use_all.import_arl_view_use_all.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('import_arl_view_use_collide', async () => {
    await import_arl_view_def.import_arl_view_def.deploy({ as: alice })
    await import_arl_view_use_collide.import_arl_view_use_collide.deploy({ as: alice })

    const res_imported_before = await import_arl_view_use_collide.import_arl_view_use_collide.get_res_imported()
    assert(res_imported_before.equals(Option.None()))
    const res_top_before = await import_arl_view_use_collide.import_arl_view_use_collide.get_res_top()
    assert(res_top_before.equals(Option.None()))

    await import_arl_view_use_collide.import_arl_view_use_collide.exec(import_arl_view_def.import_arl_view_def.get_address(), { as: alice })

    const res_imported_after = await import_arl_view_use_collide.import_arl_view_use_collide.get_res_imported()
    assert(res_imported_after.equals(Option.Some(new Nat(5))))
    const res_top_after = await import_arl_view_use_collide.import_arl_view_use_collide.get_res_top()
    assert(res_top_after.equals(Option.Some<string>("mystr")))
  })

  it('import_tz_entry_use', async () => {
    await import_tz_entry_use.import_tz_entry_use.deploy({ as: alice })

    const res_before = await import_tz_entry_use.import_tz_entry_use.get_res()
    assert(res_before.equals(new Nat(0)))

    await import_tz_entry_use.import_tz_entry_use.e({ as: alice })

    const res_after = await import_tz_entry_use.import_tz_entry_use.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('import_tz_view_use', async () => {
    await import_tz_view_use.import_tz_view_use.deploy({ as: alice })

    const res_before = await import_tz_view_use.import_tz_view_use.get_res()
    assert(res_before.equals(new Nat(0)))

    await import_tz_view_use.import_tz_view_use.exec({ as: alice })

    const res_after = await import_tz_view_use.import_tz_view_use.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('init_asset_with_const', async () => {
    await init_asset_with_const.init_asset_with_const.deploy([["a", new Nat(1)], ["b", new Nat(2)], ["c", new Nat(3)]], { as: alice })

    const n_before = await init_asset_with_const.init_asset_with_const.get_n()
    assert(n_before.equals(new Nat(0)))

    await init_asset_with_const.init_asset_with_const.exec({ as: alice })

    const n_after = await init_asset_with_const.init_asset_with_const.get_n()
    assert(n_after.equals(new Nat(6)))
  })

  it('init_lambda', async () => {
    await init_lambda.init_lambda.deploy({ as: alice })

    const res_before = await init_lambda.init_lambda.get_res()
    assert(res_before.equals(new Int(0)))

    await init_lambda.init_lambda.exec(new Int(1), { as: alice })

    const res_after = await init_lambda.init_lambda.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('instr_list_prepend', async () => {
    await instr_list_prepend.instr_list_prepend.deploy({ as: alice })

    const res_before = await instr_list_prepend.instr_list_prepend.get_res()
    assert(res_before.length == 3)
    assert(res_before[0] == "1")
    assert(res_before[1] == "2")
    assert(res_before[2] == "3")

    await instr_list_prepend.instr_list_prepend.exec({ as: alice })

    const res_after = await instr_list_prepend.instr_list_prepend.get_res()
    assert(res_after.length == 4)
    assert(res_after[0] == "0")
    assert(res_after[1] == "1")
    assert(res_after[2] == "2")
    assert(res_after[3] == "3")
  })

  it('instr_map_put', async () => {
    await instr_map_put.instr_map_put.deploy({ as: alice })

    const res_before = await instr_map_put.instr_map_put.get_res()
    assert(res_before.length == 0)

    await instr_map_put.instr_map_put.exec({ as: alice })

    const res_after = await instr_map_put.instr_map_put.get_res()
    assert(res_after.length == 1)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
  })

  it('instr_map_remove', async () => {
    await instr_map_remove.instr_map_remove.deploy({ as: alice })

    const res_before = await instr_map_remove.instr_map_remove.get_res()
    assert(res_before.length == 1)
    assert(res_before[0][0].equals(new Nat(0)))
    assert(res_before[0][1] == "0")

    await instr_map_remove.instr_map_remove.exec({ as: alice })

    const res_after = await instr_map_remove.instr_map_remove.get_res()
    assert(res_after.length == 0)
  })

  it('instr_map_update_local_record', async () => {
    await instr_map_update_local_record.instr_map_update_local_record.deploy({ as: alice })

    const res_before = await instr_map_update_local_record.instr_map_update_local_record.get_res()
    assert(res_before.length == 0)

    await instr_map_update_local_record.instr_map_update_local_record.exec({ as: alice })

    const res_after = await instr_map_update_local_record.instr_map_update_local_record.get_res()
    assert(res_after.length == 1)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
  })

  it('instr_map_update_local_var', async () => {
    await instr_map_update_local_var.instr_map_update_local_var.deploy({ as: alice })

    const res_before = await instr_map_update_local_var.instr_map_update_local_var.get_res()
    assert(res_before.length == 0)

    await instr_map_update_local_var.instr_map_update_local_var.exec({ as: alice })

    const res_after = await instr_map_update_local_var.instr_map_update_local_var.get_res()
    assert(res_after.length == 1)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
  })

  it('instr_map_update_storage_record', async () => {
    await instr_map_update_storage_record.instr_map_update_storage_record.deploy({ as: alice })

    const res_before = await instr_map_update_storage_record.instr_map_update_storage_record.get_res()
    assert(res_before.equals(new instr_map_update_storage_record.my_record(new Nat(0), [])))

    await instr_map_update_storage_record.instr_map_update_storage_record.exec({ as: alice })

    const res_after = await instr_map_update_storage_record.instr_map_update_storage_record.get_res()
    assert(res_after.equals(new instr_map_update_storage_record.my_record(new Nat(0), [[new Nat(0), "0"]])))
  })

  it('instr_map_update_storage_var', async () => {
    await instr_map_update_storage_var.instr_map_update_storage_var.deploy({ as: alice })

    const res_before = await instr_map_update_storage_var.instr_map_update_storage_var.get_res()
    assert(res_before.length == 0)

    await instr_map_update_storage_var.instr_map_update_storage_var.exec({ as: alice })

    const res_after = await instr_map_update_storage_var.instr_map_update_storage_var.get_res()
    assert(res_after.length == 1)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
  })

  it('instr_set_add', async () => {
    await instr_set_add.instr_set_add.deploy({ as: alice })

    const res_before = await instr_set_add.instr_set_add.get_res()
    assert(res_before.length == 3)
    assert(res_before[0] == "1")
    assert(res_before[1] == "2")
    assert(res_before[2] == "3")

    await instr_set_add.instr_set_add.exec({ as: alice })

    const res_after = await instr_set_add.instr_set_add.get_res()
    assert(res_after.length == 4)
    assert(res_after[0] == "0")
    assert(res_after[1] == "1")
    assert(res_after[2] == "2")
    assert(res_after[3] == "3")
  })

  it('instr_set_remove', async () => {
    await instr_set_remove.instr_set_remove.deploy({ as: alice })

    const res_before = await instr_set_remove.instr_set_remove.get_res()
    assert(res_before.length == 3)
    assert(res_before[0] == "1")
    assert(res_before[1] == "2")
    assert(res_before[2] == "3")

    await instr_set_remove.instr_set_remove.exec({ as: alice })

    const res_after = await instr_set_remove.instr_set_remove.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "2")
    assert(res_after[1] == "3")
  })

  it('instr_set_update_add', async () => {
    await instr_set_update_add.instr_set_update_add.deploy({ as: alice })

    const res_before = await instr_set_update_add.instr_set_update_add.get_res()
    assert(res_before.length == 3)
    assert(res_before[0] == "1")
    assert(res_before[1] == "2")
    assert(res_before[2] == "3")

    await instr_set_update_add.instr_set_update_add.exec({ as: alice })

    const res_after = await instr_set_update_add.instr_set_update_add.get_res()
    assert(res_after.length == 4)
    assert(res_after[0] == "1")
    assert(res_after[1] == "2")
    assert(res_after[2] == "3")
    assert(res_after[3] == "4")
  })

  it('instr_set_update_remove', async () => {
    await instr_set_update_remove.instr_set_update_remove.deploy({ as: alice })

    const res_before = await instr_set_update_remove.instr_set_update_remove.get_res()
    assert(res_before.length == 3)
    assert(res_before[0] == "1")
    assert(res_before[1] == "2")
    assert(res_before[2] == "3")

    await instr_set_update_remove.instr_set_update_remove.exec({ as: alice })

    const res_after = await instr_set_update_remove.instr_set_update_remove.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "2")
    assert(res_after[1] == "3")
  })

  it('int_to_date', async () => {
    await int_to_date.int_to_date.deploy({ as: alice })

    const res_before = await int_to_date.int_to_date.get_res()
    assert(res_before.toISOString() == '2000-01-01T00:00:00.000Z')

    await int_to_date.int_to_date.exec({ as: alice })

    const res_after = await int_to_date.int_to_date.get_res()
    assert(res_after.toISOString() == '2020-12-31T00:00:00.000Z')
  })

  it('invariants_on_states', async () => {
    await invariants_on_states.invariants_on_states.deploy({ as: alice })

    const state_before = await invariants_on_states.invariants_on_states.get_state()
    assert(state_before == invariants_on_states.states.One)
    const v_before = await invariants_on_states.invariants_on_states.get_v()
    assert(v_before.equals(new Int(0)))

    await invariants_on_states.invariants_on_states.exec({ as: alice })

    const state_after = await invariants_on_states.invariants_on_states.get_state()
    assert(state_after == invariants_on_states.states.Two)
    const v_after = await invariants_on_states.invariants_on_states.get_v()
    assert(v_after.equals(new Int(1)))
  })

  it('invariants_on_variable', async () => {
    await invariants_on_variable.invariants_on_variable.deploy({ as: alice })

    const v_before = await invariants_on_variable.invariants_on_variable.get_v()
    assert(v_before.equals(new Int(0)))

    await invariants_on_variable.invariants_on_variable.exec({ as: alice })

    const v_after = await invariants_on_variable.invariants_on_variable.get_v()
    assert(v_after.equals(new Int(1)))
  })

  it('iter_list_ticket', async () => {
    await iter_list_ticket.iter_list_ticket.deploy({ as: alice })
  })

  it('iterable_big_map_assign', async () => {
    await iterable_big_map_assign.iterable_big_map_assign.deploy({ as: alice })

    const mystr0_before = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("mystr0");
    assert(mystr0_before?.equals(new Bytes("00")))
    const mystr1_before = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("mystr1");
    assert(mystr1_before?.equals(new Bytes("01")))
    const mystr2_before = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("mystr2");
    assert(mystr2_before?.equals(new Bytes("02")))
    const mystr3_before = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("mystr3");
    assert(mystr3_before?.equals(new Bytes("03")))
    const str_before = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("str");
    assert(str_before == undefined)

    await iterable_big_map_assign.iterable_big_map_assign.exec({ as: alice })

    const mystr0_after = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("mystr0");
    assert(mystr0_after == undefined)
    const mystr1_after = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("mystr1");
    assert(mystr1_after == undefined)
    const mystr2_after = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("mystr2");
    assert(mystr2_after == undefined)
    const mystr3_after = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("mystr3");
    assert(mystr3_after == undefined)
    const str_after = await iterable_big_map_assign.iterable_big_map_assign.get_my_map_value("str");
    assert(str_after?.equals(new Bytes("0a")))
  })

  it('iterable_big_map_contains', async () => {
    await iterable_big_map_contains.iterable_big_map_contains.deploy({ as: alice })

    const mystr0_before = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr0");
    assert(mystr0_before?.equals(new Bytes("00")))
    const mystr1_before = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr1");
    assert(mystr1_before?.equals(new Bytes("01")))
    const mystr2_before = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr2");
    assert(mystr2_before?.equals(new Bytes("02")))
    const mystr3_before = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr3");
    assert(mystr3_before?.equals(new Bytes("03")))
    const mystr4_before = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr4");
    assert(mystr4_before == undefined)
    const res_before = await iterable_big_map_contains.iterable_big_map_contains.get_res();
    assert(res_before == false)

    await iterable_big_map_contains.iterable_big_map_contains.exec({ as: alice })

    const mystr0_after = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr0");
    assert(mystr0_after?.equals(new Bytes("00")))
    const mystr1_after = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr1");
    assert(mystr1_after?.equals(new Bytes("01")))
    const mystr2_after = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr2");
    assert(mystr2_after?.equals(new Bytes("02")))
    const mystr3_after = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr3");
    assert(mystr3_after?.equals(new Bytes("03")))
    const mystr4_after = await iterable_big_map_contains.iterable_big_map_contains.get_my_map_value("mystr4");
    assert(mystr4_after == undefined)
    const res_after = await iterable_big_map_contains.iterable_big_map_contains.get_res();
    assert(res_after == true)
  })

  it('iterable_big_map_for', async () => {
    await iterable_big_map_for.iterable_big_map_for.deploy({ as: alice })

    const mystr0_before = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr0");
    assert(mystr0_before?.equals(new Bytes("00")))
    const mystr1_before = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr1");
    assert(mystr1_before?.equals(new Bytes("01")))
    const mystr2_before = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr2");
    assert(mystr2_before?.equals(new Bytes("02")))
    const mystr3_before = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr3");
    assert(mystr3_before?.equals(new Bytes("03")))
    const mystr4_before = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr4");
    assert(mystr4_before == undefined)
    const res_before = await iterable_big_map_for.iterable_big_map_for.get_res();
    assert(res_before.equals(new Bytes("")))

    await iterable_big_map_for.iterable_big_map_for.exec({ as: alice })

    const mystr0_after = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr0");
    assert(mystr0_after?.equals(new Bytes("00")))
    const mystr1_after = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr1");
    assert(mystr1_after?.equals(new Bytes("01")))
    const mystr2_after = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr2");
    assert(mystr2_after?.equals(new Bytes("02")))
    const mystr3_after = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr3");
    assert(mystr3_after?.equals(new Bytes("03")))
    const mystr4_after = await iterable_big_map_for.iterable_big_map_for.get_my_map_value("mystr4");
    assert(mystr4_after == undefined)
    const res_after = await iterable_big_map_for.iterable_big_map_for.get_res();
    assert(res_after.equals(new Bytes("00010203")))
  })

  it('iterable_big_map_get', async () => {
    await iterable_big_map_get.iterable_big_map_get.deploy({ as: alice })

    const mystr0_before = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr0");
    assert(mystr0_before?.equals(new Bytes("00")))
    const mystr1_before = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr1");
    assert(mystr1_before?.equals(new Bytes("01")))
    const mystr2_before = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr2");
    assert(mystr2_before?.equals(new Bytes("02")))
    const mystr3_before = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr3");
    assert(mystr3_before?.equals(new Bytes("03")))
    const mystr4_before = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr4");
    assert(mystr4_before == undefined)
    const res_before = await iterable_big_map_get.iterable_big_map_get.get_res();
    assert(res_before.equals(Option.None()))

    await iterable_big_map_get.iterable_big_map_get.exec({ as: alice })

    const mystr0_after = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr0");
    assert(mystr0_after?.equals(new Bytes("00")))
    const mystr1_after = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr1");
    assert(mystr1_after?.equals(new Bytes("01")))
    const mystr2_after = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr2");
    assert(mystr2_after?.equals(new Bytes("02")))
    const mystr3_after = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr3");
    assert(mystr3_after?.equals(new Bytes("03")))
    const mystr4_after = await iterable_big_map_get.iterable_big_map_get.get_my_map_value("mystr4");
    assert(mystr4_after == undefined)
    const res_after = await iterable_big_map_get.iterable_big_map_get.get_res();
    assert(res_after.equals(Option.Some(new Bytes("02"))))
  })

  it('iterable_big_map_length', async () => {
    await iterable_big_map_length.iterable_big_map_length.deploy({ as: alice })

    const mystr0_before = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr0");
    assert(mystr0_before?.equals(new Bytes("00")))
    const mystr1_before = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr1");
    assert(mystr1_before?.equals(new Bytes("01")))
    const mystr2_before = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr2");
    assert(mystr2_before?.equals(new Bytes("02")))
    const mystr3_before = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr3");
    assert(mystr3_before?.equals(new Bytes("03")))
    const mystr4_before = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr4");
    assert(mystr4_before == undefined)
    const res_before = await iterable_big_map_length.iterable_big_map_length.get_res();
    assert(res_before.equals(new Nat(0)))

    await iterable_big_map_length.iterable_big_map_length.exec({ as: alice })

    const mystr0_after = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr0");
    assert(mystr0_after?.equals(new Bytes("00")))
    const mystr1_after = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr1");
    assert(mystr1_after?.equals(new Bytes("01")))
    const mystr2_after = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr2");
    assert(mystr2_after?.equals(new Bytes("02")))
    const mystr3_after = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr3");
    assert(mystr3_after?.equals(new Bytes("03")))
    const mystr4_after = await iterable_big_map_length.iterable_big_map_length.get_my_map_value("mystr4");
    assert(mystr4_after == undefined)
    const res_after = await iterable_big_map_length.iterable_big_map_length.get_res();
    assert(res_after.equals(new Nat(4)))
  })

  it('iterable_big_map_put', async () => {
    await iterable_big_map_put.iterable_big_map_put.deploy({ as: alice })

    const mystr0_before = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr0");
    assert(mystr0_before?.equals(new Bytes("00")))
    const mystr1_before = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr1");
    assert(mystr1_before?.equals(new Bytes("01")))
    const mystr2_before = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr2");
    assert(mystr2_before?.equals(new Bytes("02")))
    const mystr3_before = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr3");
    assert(mystr3_before?.equals(new Bytes("03")))
    const mystr4_before = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr4");
    assert(mystr4_before == undefined)

    await iterable_big_map_put.iterable_big_map_put.exec({ as: alice })

    const mystr0_after = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr0");
    assert(mystr0_after?.equals(new Bytes("00")))
    const mystr1_after = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr1");
    assert(mystr1_after?.equals(new Bytes("01")))
    const mystr2_after = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr2");
    assert(mystr2_after?.equals(new Bytes("02")))
    const mystr3_after = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr3");
    assert(mystr3_after?.equals(new Bytes("03")))
    const mystr4_after = await iterable_big_map_put.iterable_big_map_put.get_my_map_value("mystr4");
    assert(mystr4_after?.equals(new Bytes("04")))
  })

  it('iterable_big_map_remove', async () => {
    await iterable_big_map_remove.iterable_big_map_remove.deploy({ as: alice })

    const mystr0_before = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr0");
    assert(mystr0_before?.equals(new Bytes("00")))
    const mystr1_before = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr1");
    assert(mystr1_before?.equals(new Bytes("01")))
    const mystr2_before = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr2");
    assert(mystr2_before?.equals(new Bytes("02")))
    const mystr3_before = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr3");
    assert(mystr3_before?.equals(new Bytes("03")))
    const mystr4_before = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr4");
    assert(mystr4_before == undefined)

    await iterable_big_map_remove.iterable_big_map_remove.exec({ as: alice })

    const mystr0_after = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr0");
    assert(mystr0_after?.equals(new Bytes("00")))
    const mystr1_after = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr1");
    assert(mystr1_after == undefined)
    const mystr2_after = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr2");
    assert(mystr2_after?.equals(new Bytes("02")))
    const mystr3_after = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr3");
    assert(mystr3_after?.equals(new Bytes("03")))
    const mystr4_after = await iterable_big_map_remove.iterable_big_map_remove.get_my_map_value("mystr4");
    assert(mystr4_after == undefined)
  })

  it('iterable_big_map_storage_decl', async () => {
    await iterable_big_map_storage_decl.iterable_big_map_storage_decl.deploy({ as: alice })

    const mystr0 = await iterable_big_map_storage_decl.iterable_big_map_storage_decl.get_my_map_value("mystr0");
    assert(mystr0?.equals(new Bytes("00")))
    const mystr1 = await iterable_big_map_storage_decl.iterable_big_map_storage_decl.get_my_map_value("mystr1");
    assert(mystr1?.equals(new Bytes("01")))
    const mystr2 = await iterable_big_map_storage_decl.iterable_big_map_storage_decl.get_my_map_value("mystr2");
    assert(mystr2?.equals(new Bytes("02")))
    const mystr3 = await iterable_big_map_storage_decl.iterable_big_map_storage_decl.get_my_map_value("mystr3");
    assert(mystr3?.equals(new Bytes("03")))
    const mystr4 = await iterable_big_map_storage_decl.iterable_big_map_storage_decl.get_my_map_value("mystr4");
    assert(mystr4 == undefined)
    const r = await iterable_big_map_storage_decl.iterable_big_map_storage_decl.get_r()
    assert(r.equals(new Nat(0)))
  })

  it('iterable_big_map_test', async () => {
    await iterable_big_map_test.iterable_big_map_test.deploy({ as: alice })

    const mystr0_before = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr0");
    assert(mystr0_before?.equals(new Bytes("00")))
    const mystr1_before = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr1");
    assert(mystr1_before?.equals(new Bytes("01")))
    const mystr2_before = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr2");
    assert(mystr2_before?.equals(new Bytes("02")))
    const mystr3_before = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr3");
    assert(mystr3_before?.equals(new Bytes("03")))
    const mystr4_before = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr4");
    assert(mystr4_before == undefined)
    const res_concat_before = await iterable_big_map_test.iterable_big_map_test.get_res_concat();
    assert(res_concat_before.equals(new Bytes("")))

    await iterable_big_map_test.iterable_big_map_test.put("mystr4", new Bytes("04"), { as: alice })

    const mystr0_put = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr0");
    assert(mystr0_put?.equals(new Bytes("00")))
    const mystr1_put = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr1");
    assert(mystr1_put?.equals(new Bytes("01")))
    const mystr2_put = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr2");
    assert(mystr2_put?.equals(new Bytes("02")))
    const mystr3_put = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr3");
    assert(mystr3_put?.equals(new Bytes("03")))
    const mystr4_put = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr4");
    assert(mystr4_put?.equals(new Bytes("04")))
    const res_concat_put = await iterable_big_map_test.iterable_big_map_test.get_res_concat();
    assert(res_concat_put.equals(new Bytes("")))

    await iterable_big_map_test.iterable_big_map_test.remove("mystr4", { as: alice })

    const mystr0_remove = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr0");
    assert(mystr0_remove?.equals(new Bytes("00")))
    const mystr1_remove = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr1");
    assert(mystr1_remove?.equals(new Bytes("01")))
    const mystr2_remove = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr2");
    assert(mystr2_remove?.equals(new Bytes("02")))
    const mystr3_remove = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr3");
    assert(mystr3_remove?.equals(new Bytes("03")))
    const mystr4_remove = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr4");
    assert(mystr4_remove == undefined)
    const res_concat_remove = await iterable_big_map_test.iterable_big_map_test.get_res_concat();
    assert(res_concat_remove.equals(new Bytes("")))

    await iterable_big_map_test.iterable_big_map_test.iterate({ as: alice })

    const mystr0_iterate = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr0");
    assert(mystr0_iterate?.equals(new Bytes("00")))
    const mystr1_iterate = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr1");
    assert(mystr1_iterate?.equals(new Bytes("01")))
    const mystr2_iterate = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr2");
    assert(mystr2_iterate?.equals(new Bytes("02")))
    const mystr3_iterate = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr3");
    assert(mystr3_iterate?.equals(new Bytes("03")))
    const mystr4_iterate = await iterable_big_map_test.iterable_big_map_test.get_my_map_value("mystr4");
    assert(mystr4_iterate == undefined)
    const res_concat_iterate = await iterable_big_map_test.iterable_big_map_test.get_res_concat();
    assert(res_concat_iterate.equals(new Bytes("00010203")))
  })

  it('key_to_address', async () => {
    await key_to_address.key_to_address.deploy({ as: alice })

    const res_concat_remove = await key_to_address.key_to_address.get_res();
    assert(res_concat_remove.equals(Option.None()))

    await key_to_address.key_to_address.exec(alice.get_public_key(), { as: alice })

    const mystr0_iterate = await key_to_address.key_to_address.get_res();
    assert(mystr0_iterate?.equals(Option.Some(alice.get_address())))
  })

  it('lang_arith', async () => {
    await lang_arith.lang_arith.deploy({ as: alice })

    await lang_arith.lang_arith.exec({ as: alice })
  })

  it('lang_asset', async () => {
    await lang_asset.lang_asset.deploy({ as: alice })

    await lang_asset.lang_asset.exec({ as: alice })
  })

  it('lang_assign', async () => {
    await lang_assign.lang_assign.deploy({ as: alice })

    await lang_assign.lang_assign.exec({ as: alice })
  })

  it('lang_big_map', async () => {
    await lang_big_map.lang_big_map.deploy({ as: alice })

    await lang_big_map.lang_big_map.exec({ as: alice })
  })

  it('lang_cast', async () => {
    await lang_cast.lang_cast.deploy({ as: alice })

    await lang_cast.lang_cast.exec({ as: alice })
  })

  it('lang_cmp', async () => {
    await lang_cmp.lang_cmp.deploy({ as: alice })

    await lang_cmp.lang_cmp.exec({ as: alice })
  })

  it('lang_contract', async () => {
    await lang_contract.lang_contract.deploy({ amount: new Tez(1), as: alice })

    await lang_contract.lang_contract.exec(lang_contract.lang_contract.get_address(), { as: alice })
  })

  it('lang_crypto', async () => {
    await lang_crypto.lang_crypto.deploy({ as: alice })

    await lang_crypto.lang_crypto.exec({ as: alice })
  })

  it('lang_cst', async () => {
    await lang_cst.lang_cst.deploy({ as: alice })

    await lang_cst.lang_cst.exec({ as: alice })
  })

  it('lang_entry', async () => {
    await lang_entry.lang_entry.deploy({ as: alice })

    await lang_entry.lang_entry.exec({ as: alice })
  })

  it('lang_enum', async () => {
    await lang_enum.lang_enum.deploy({ as: alice })

    await lang_enum.lang_enum.exec({ as: alice })
  })

  it('lang_funs', async () => {
    await lang_funs.lang_funs.deploy({ as: alice })

    await lang_funs.lang_funs.exec({ as: alice })
  })

  it('lang_list', async () => {
    await lang_list.lang_list.deploy({ as: alice })

    await lang_list.lang_list.exec({ as: alice })
  })

  it('lang_literals', async () => {
    await lang_literals.lang_literals.deploy({ as: alice })

    await lang_literals.lang_literals.exec({ as: alice })
  })

  it('lang_map', async () => {
    await lang_map.lang_map.deploy({ as: alice })

    await lang_map.lang_map.exec({ as: alice })
  })

  it('lang_methods_asset', async () => {
    await lang_methods_asset.lang_methods_asset.deploy({ as: alice })

    await lang_methods_asset.lang_methods_asset.exec({ as: alice })
  })

  it('lang_set', async () => {
    await lang_set.lang_set.deploy({ as: alice })

    await lang_set.lang_set.exec({ as: alice })
  })

  it('large_if', async () => {
    await large_if.large_if.deploy({ as: alice })

    const res_before = await large_if.large_if.get_res();
    assert(res_before.equals(new Nat(0)))

    await large_if.large_if.exec({ as: alice })

    const res_after = await large_if.large_if.get_res();
    assert(res_after.equals(new Nat(86)))
  })

  it('list_list', async () => {
    await list_list.list_list.deploy({ as: alice })

    const res_before = await list_list.list_list.get_res();
    assert(res_before.length == 0)

    await list_list.list_list.exec({ as: alice })

    const res_after = await list_list.list_list.get_res();
    assert(res_after.length == 1)
    assert(res_after[0].length == 1)
    assert(res_after[0][0].equals(new Nat(1)))
  })

  it('list_nth_out_of_bound', async () => {
    await list_nth_out_of_bound.list_nth_out_of_bound.deploy({ as: alice })

    const res_before = await list_nth_out_of_bound.list_nth_out_of_bound.get_res();
    assert(res_before.equals(Option.None()))

    await list_nth_out_of_bound.list_nth_out_of_bound.exec({ as: alice })

    const res_after = await list_nth_out_of_bound.list_nth_out_of_bound.get_res();
    assert(res_after.equals(Option.None()))
  })

  it('list_option', async () => {
    await list_option.list_option.deploy({ as: alice })

    const res_before = await list_option.list_option.get_res();
    assert(res_before.length == 0)

    await list_option.list_option.exec({ as: alice })

    const res_after = await list_option.list_option.get_res();
    assert(res_after.length == 1)
    assert(res_after[0].equals(Option.Some(new Nat(1))))
  })

  it('list_or', async () => {
    await list_or.list_or.deploy({ as: alice })

    const res_before = await list_or.list_or.get_res();
    assert(res_before.length == 0)

    await list_or.list_or.exec({ as: alice })

    const res_after = await list_or.list_or.get_res();
    assert(res_after.length == 1)
    assert(res_after[0].equals(Or.Left(new Nat(1))))
  })

  it('lit_list', async () => {
    await lit_list.lit_list.deploy({ as: alice })

    const res_before = await lit_list.lit_list.get_res();
    assert(res_before.length == 0)

    await lit_list.lit_list.exec({ as: alice })

    const res_after = await lit_list.lit_list.get_res();
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('lit_map', async () => {
    await lit_map.lit_map.deploy({ as: alice })

    const res_before = await lit_map.lit_map.get_res();
    assert(res_before.length == 0)

    await lit_map.lit_map.exec({ as: alice })

    const res_after = await lit_map.lit_map.get_res();
    assert(res_after.length == 3)
    assert(res_after[0][0].equals(new Nat(0)))
    assert(res_after[0][1] == "0")
    assert(res_after[1][0].equals(new Nat(1)))
    assert(res_after[1][1] == "1")
    assert(res_after[2][0].equals(new Nat(2)))
    assert(res_after[2][1] == "2")
  })

  it('lit_set', async () => {
    await lit_set.lit_set.deploy({ as: alice })

    const res_before = await lit_set.lit_set.get_res();
    assert(res_before.length == 0)

    await lit_set.lit_set.exec({ as: alice })

    const res_after = await lit_set.lit_set.get_res();
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('lit_tez_underscore', async () => {
    await lit_tez_underscore.lit_tez_underscore.deploy({ as: alice })

    const res0 = await lit_tez_underscore.lit_tez_underscore.get_res0();
    assert(res0.equals(new Tez(1000)))
    const res1 = await lit_tez_underscore.lit_tez_underscore.get_res1();
    assert(res1.equals(new Tez(1000)))
    const res2 = await lit_tez_underscore.lit_tez_underscore.get_res2();
    assert(res2.equals(new Tez(1000)))
  })

  it('literal_in_argument', async () => {
    await literal_in_argument.literal_in_argument.deploy({ as: alice })

    const res_before = await literal_in_argument.literal_in_argument.get_res();
    assert(res_before.equals(new Rational(0)))

    await literal_in_argument.literal_in_argument.exec({ as: alice })

    const res_after = await literal_in_argument.literal_in_argument.get_res();
    assert(res_after.equals(new Rational(0.5)))
  })

  it('map_asset', async () => {
    await map_asset.map_asset.deploy({ as: alice })

    const my_asset_before = await map_asset.map_asset.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].length == 0)

    await map_asset.map_asset.exec({ as: alice })

    const my_asset_after = await map_asset.map_asset.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0][0] == "toto")
    assert(my_asset_after[0][1][0][1].equals(new Nat(0)))
  })

  it('match_detach_big_map', async () => {
    await match_detach_big_map.match_detach_big_map.deploy({ as: alice })

    const ticket_alice_before = await match_detach_big_map.match_detach_big_map.get_mt_value(alice.get_address());
    assert(ticket_alice_before === undefined)

    await match_detach_big_map.match_detach_big_map.init({ as: alice })

    const ticket_alice_init = await match_detach_big_map.match_detach_big_map.get_mt_value(alice.get_address());
    assert(ticket_alice_init?.equals(new Ticket<Unit>(match_detach_big_map.match_detach_big_map.get_address(), new Unit(), new Nat(1))))

    await match_detach_big_map.match_detach_big_map.exec({ as: alice })

    const ticket_alice_after = await match_detach_big_map.match_detach_big_map.get_mt_value(alice.get_address());
    assert(ticket_alice_after?.equals(new Ticket<Unit>(match_detach_big_map.match_detach_big_map.get_address(), new Unit(), new Nat(3))))
  })

  it('match_detach_map', async () => {
    await match_detach_map.match_detach_map.deploy({ as: alice })

    const mt_before = await match_detach_map.match_detach_map.get_mt();
    assert(mt_before.length == 0)

    await match_detach_map.match_detach_map.init({ as: alice })

    const mt_init = await match_detach_map.match_detach_map.get_mt();
    assert(mt_init.length == 1)
    assert(mt_init[0][0].equals(alice.get_address()))
    assert(mt_init[0][1].equals(new Ticket(match_detach_map.match_detach_map.get_address(), new Unit(), new Nat(1))))

    await match_detach_map.match_detach_map.exec({ as: alice })

    const mt_after = await match_detach_map.match_detach_map.get_mt();
    assert(mt_after.length == 1)
    assert(mt_after[0][0].equals(alice.get_address()))
    assert(mt_after[0][1].equals(new Ticket(match_detach_map.match_detach_map.get_address(), new Unit(), new Nat(3))))
  })

  it('match_detach_option', async () => {
    await match_detach_option.match_detach_option.deploy({ as: alice })

    const ot_before = await match_detach_option.match_detach_option.get_ot()
    assert(ot_before.equals(Option.None<Ticket<Unit>>()))

    await match_detach_option.match_detach_option.init({ as: alice })

    const ot_init = await match_detach_option.match_detach_option.get_ot()
    assert(ot_init.equals(Option.Some<Ticket<Unit>>(new Ticket<Unit>(match_detach_option.match_detach_option.get_address(), new Unit(), new Nat(1)))))

    await match_detach_option.match_detach_option.exec({ as: alice })

    const ot_after = await match_detach_option.match_detach_option.get_ot()
    assert(ot_after.equals(Option.Some<Ticket<Unit>>(new Ticket<Unit>(match_detach_option.match_detach_option.get_address(), new Unit(), new Nat(3)))))
  })

  it('match_entrypoint', async () => {
    await match_entrypoint.match_entrypoint.deploy({ as: alice })

    const res_before = await match_entrypoint.match_entrypoint.get_res();
    assert(res_before.equals(new Nat(0)))

    await match_entrypoint.match_entrypoint.exec({ as: alice })

    const res_after = await match_entrypoint.match_entrypoint.get_res();
    assert(res_after.equals(new Nat(1)))
  })

  it('max_tez', async () => {
    await max_tez.max_tez.deploy({ as: alice })

    const res_before = await max_tez.max_tez.get_res();
    assert(res_before.equals(new Tez(0)))

    await max_tez.max_tez.exec({ as: alice })

    const res_after = await max_tez.max_tez.get_res();
    assert(res_after.equals(new Tez(new BigNumber("9223372036854775807"), 'mutez')))
  })

  it('method_in_dorequire_or_dofailif', async () => {
    await method_in_dorequire_or_dofailif.method_in_dorequire_or_dofailif.deploy({ as: alice })

    const my_asset_before = await method_in_dorequire_or_dofailif.method_in_dorequire_or_dofailif.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))

    await method_in_dorequire_or_dofailif.method_in_dorequire_or_dofailif.deploy({ as: alice })

    const my_asset_after = await method_in_dorequire_or_dofailif.method_in_dorequire_or_dofailif.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
  })

  it('michelson_expression', async () => {
    await michelson_expression.michelson_expression.deploy({ as: alice })

    const res_before = await michelson_expression.michelson_expression.get_res()
    assert(res_before.equals(new Nat(0)))

    await michelson_expression.michelson_expression.exec({ as: alice })

    const res_after = await michelson_expression.michelson_expression.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('michelson_instruction', async () => {
    await michelson_instruction.michelson_instruction.deploy({ as: alice })

    await michelson_instruction.michelson_instruction.exec({ as: alice })
  })

  it('michelson_lambda', async () => {
    await michelson_lambda.michelson_lambda.deploy({ as: alice })

    const res_before = await michelson_lambda.michelson_lambda.get_res()
    assert(res_before.equals(new Nat(0)))

    await michelson_lambda.michelson_lambda.exec({ as: alice })

    const res_after = await michelson_lambda.michelson_lambda.get_res()
    assert(res_after.equals(new Nat(5)))
  })

  it('miles_with_expiration_spec', async () => {
    await miles_with_expiration_spec.miles_with_expiration_spec.deploy({ as: alice })
    // TODO
  })

  it('mod_rat', async () => {
    await mod_rat.mod_rat.deploy({ as: alice })

    const res_before = await mod_rat.mod_rat.get_res();
    assert(res_before.equals(new Rational(0)))

    await mod_rat.mod_rat.exec(new Rational(1), new Rational(0.3), { as: alice })

    const res_after = await mod_rat.mod_rat.get_res();
    assert(res_after.equals(new Rational(0.1)))
  })

  it('multi_e', async () => {
    await multi_e.multi_e.deploy({ as: alice })

    await multi_e.multi_e.e1({ as: alice })
    await multi_e.multi_e.e2({ as: alice })
    await multi_e.multi_e.e3({ as: alice })
    await multi_e.multi_e.e4({ as: alice })
    await multi_e.multi_e.e5({ as: alice })
    await multi_e.multi_e.e6({ as: alice })
    await multi_e.multi_e.e7({ as: alice })
    await multi_e.multi_e.e8({ as: alice })
  })

  it('multi_ident_match_option', async () => {
    await multi_ident_match_option.multi_ident_match_option.deploy({ as: alice })

    const str_before = await multi_ident_match_option.multi_ident_match_option.get_str();
    assert(str_before == "")
    const n_before = await multi_ident_match_option.multi_ident_match_option.get_n();
    assert(n_before.equals(new Nat(0)))

    await multi_ident_match_option.multi_ident_match_option.exec({ as: alice })

    const str_after = await multi_ident_match_option.multi_ident_match_option.get_str();
    assert(str_after == "mystr")
    const n_after = await multi_ident_match_option.multi_ident_match_option.get_n();
    assert(n_after.equals(new Nat(2)))
  })

  it('multi_ident_match_option_3', async () => {
    await multi_ident_match_option_3.multi_ident_match_option_3.deploy({ as: alice })

    const str_before = await multi_ident_match_option_3.multi_ident_match_option_3.get_str();
    assert(str_before == "")
    const n_before = await multi_ident_match_option_3.multi_ident_match_option_3.get_n();
    assert(n_before.equals(new Nat(0)))
    const x_before = await multi_ident_match_option_3.multi_ident_match_option_3.get_x();
    assert(x_before.equals(new Bytes("")))

    await multi_ident_match_option_3.multi_ident_match_option_3.exec({ as: alice })

    const str_after = await multi_ident_match_option_3.multi_ident_match_option_3.get_str();
    assert(str_after == "mystr")
    const n_after = await multi_ident_match_option_3.multi_ident_match_option_3.get_n();
    assert(n_after.equals(new Nat(2)))
    const x_after = await multi_ident_match_option_3.multi_ident_match_option_3.get_x();
    assert(x_after.equals(new Bytes("02")))
  })

  it('multi_ident_match_or_left', async () => {
    await multi_ident_match_or_left.multi_ident_match_or_left.deploy({ as: alice })

    const str_before = await multi_ident_match_or_left.multi_ident_match_or_left.get_str();
    assert(str_before == "")
    const n_before = await multi_ident_match_or_left.multi_ident_match_or_left.get_n();
    assert(n_before.equals(new Nat(0)))

    await multi_ident_match_or_left.multi_ident_match_or_left.exec({ as: alice })

    const str_after = await multi_ident_match_or_left.multi_ident_match_or_left.get_str();
    assert(str_after == "mystr")
    const n_after = await multi_ident_match_or_left.multi_ident_match_or_left.get_n();
    assert(n_after.equals(new Nat(2)))
  })

  it('multi_ident_match_or_right', async () => {
    await multi_ident_match_or_right.multi_ident_match_or_right.deploy({ as: alice })

    const str_before = await multi_ident_match_or_right.multi_ident_match_or_right.get_str();
    assert(str_before == "")
    const n_before = await multi_ident_match_or_right.multi_ident_match_or_right.get_n();
    assert(n_before.equals(new Nat(0)))

    await multi_ident_match_or_right.multi_ident_match_or_right.exec({ as: alice })

    const str_after = await multi_ident_match_or_right.multi_ident_match_or_right.get_str();
    assert(str_after == "mystr")
    const n_after = await multi_ident_match_or_right.multi_ident_match_or_right.get_n();
    assert(n_after.equals(new Nat(2)))
  })

  it('multi_p', async () => {
    await multi_p.multi_p.deploy({ as: alice })

    await multi_p.multi_p.e1({ as: alice })
    await multi_p.multi_p.e2({ as: alice })
    await multi_p.multi_p.e3({ as: alice })
    await multi_p.multi_p.e4({ as: alice })
    await multi_p.multi_p.e5({ as: alice })
    await multi_p.multi_p.e6({ as: alice })
    await multi_p.multi_p.e7({ as: alice })
    await multi_p.multi_p.e8({ as: alice })
    await multi_p.multi_p.e9({ as: alice })
  })

  it('multi_sort', async () => {
    await multi_sort.multi_sort.deploy({ as: alice })

    const my_asset_before = await multi_sort.multi_sort.get_my_asset()
    assert(my_asset_before.length == 4)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v1.equals(new Int(1)))
    assert(my_asset_before[0][1].v2.equals(new Int(2)))
    assert(my_asset_before[0][1].v3.equals(new Int(7)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v1.equals(new Int(1)))
    assert(my_asset_before[1][1].v2.equals(new Int(3)))
    assert(my_asset_before[1][1].v3.equals(new Int(9)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v1.equals(new Int(1)))
    assert(my_asset_before[2][1].v2.equals(new Int(3)))
    assert(my_asset_before[2][1].v3.equals(new Int(8)))
    assert(my_asset_before[3][0] == "id3")
    assert(my_asset_before[3][1].v1.equals(new Int(1)))
    assert(my_asset_before[3][1].v2.equals(new Int(2)))
    assert(my_asset_before[3][1].v3.equals(new Int(6)))
    const res_before = await multi_sort.multi_sort.get_res()
    assert(res_before.length == 0)

    await multi_sort.multi_sort.exec({ as: alice })

    const my_asset_after = await multi_sort.multi_sort.get_my_asset()
    assert(my_asset_after.length == 4)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v1.equals(new Int(1)))
    assert(my_asset_after[0][1].v2.equals(new Int(2)))
    assert(my_asset_after[0][1].v3.equals(new Int(7)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v1.equals(new Int(1)))
    assert(my_asset_after[1][1].v2.equals(new Int(3)))
    assert(my_asset_after[1][1].v3.equals(new Int(9)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v1.equals(new Int(1)))
    assert(my_asset_after[2][1].v2.equals(new Int(3)))
    assert(my_asset_after[2][1].v3.equals(new Int(8)))
    assert(my_asset_after[3][0] == "id3")
    assert(my_asset_after[3][1].v1.equals(new Int(1)))
    assert(my_asset_after[3][1].v2.equals(new Int(2)))
    assert(my_asset_after[3][1].v3.equals(new Int(6)))
    const res_after = await multi_sort.multi_sort.get_res()
    assert(res_after.length == 4)
    assert(res_after[0] == "id3")
    assert(res_after[1] == "id1")
    assert(res_after[2] == "id2")
    assert(res_after[3] == "id0")
  })

  it('multi_update', async () => {
    await multi_update.multi_update.deploy({ as: alice })

    const my_asset_before = await multi_update.multi_update.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "key")
    assert(my_asset_before[0][1].v1.equals(new Nat(0)))
    assert(my_asset_before[0][1].v2.equals(new Nat(0)))
    assert(my_asset_before[0][1].v3.equals(new Nat(0)))

    await multi_update.multi_update.exec({ as: alice })

    const my_asset_after = await multi_update.multi_update.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "key")
    assert(my_asset_after[0][1].v1.equals(new Nat(1)))
    assert(my_asset_after[0][1].v2.equals(new Nat(2)))
    assert(my_asset_after[0][1].v3.equals(new Nat(3)))
  })

  it('multi_var_storage', async () => {
    await multi_var_storage.multi_var_storage.deploy({ as: alice })

    const a_before = await multi_var_storage.multi_var_storage.get_a()
    assert(a_before == "")
    const b_before = await multi_var_storage.multi_var_storage.get_b()
    assert(b_before.equals(Option.None()))
    const c_before = await multi_var_storage.multi_var_storage.get_c()
    assert(c_before.equals(new Nat(0)))
    const d_before = await multi_var_storage.multi_var_storage.get_d()
    assert(d_before.equals(new Int(1)))

    await multi_var_storage.multi_var_storage.exec({ as: alice })

    const a_after = await multi_var_storage.multi_var_storage.get_a()
    assert(a_after == "")
    const b_after = await multi_var_storage.multi_var_storage.get_b()
    assert(b_after.equals(Option.None()))
    const c_after = await multi_var_storage.multi_var_storage.get_c()
    assert(c_after.equals(new Nat(2)))
    const d_after = await multi_var_storage.multi_var_storage.get_d()
    assert(d_after.equals(new Int(1)))
  })

  it('multivars', async () => {
    await multivars.multivars.deploy({ as: alice })

    const u_before = await multivars.multivars.get_u()
    assert(u_before.equals(new Nat(0)))
    const v_before = await multivars.multivars.get_v()
    assert(v_before == "")
    const w_before = await multivars.multivars.get_w()
    assert(w_before.equals(new Int(0)))
    const x_before = await multivars.multivars.get_x()
    assert(x_before.equals(new Bytes("00")))
    const y_before = await multivars.multivars.get_y()
    assert(y_before.equals(new Nat(1)))
    const z_before = await multivars.multivars.get_z()
    assert(z_before.equals(new Nat(0)))

    await multivars.multivars.exec({ as: alice })

    const u_after = await multivars.multivars.get_u()
    assert(u_after.equals(new Nat(0)))
    const v_after = await multivars.multivars.get_v()
    assert(v_after == "")
    const w_after = await multivars.multivars.get_w()
    assert(w_after.equals(new Int(0)))
    const x_after = await multivars.multivars.get_x()
    assert(x_after.equals(new Bytes("00")))
    const y_after = await multivars.multivars.get_y()
    assert(y_after.equals(new Nat(1)))
    const z_after = await multivars.multivars.get_z()
    assert(z_after.equals(new Nat(2)))
  })

  it('multivars1', async () => {
    await multivars1.multivars1.deploy({ as: alice })

    const u_before = await multivars1.multivars1.get_u()
    assert(u_before.equals(new Nat(1)))
    const v_before = await multivars1.multivars1.get_v()
    assert(v_before == "a")
    const r_before = await multivars1.multivars1.get_r()
    assert(r_before.equals(new Nat(0)))

    await multivars1.multivars1.exec({ as: alice })

    const u_after = await multivars1.multivars1.get_u()
    assert(u_after.equals(new Nat(1)))
    const v_after = await multivars1.multivars1.get_v()
    assert(v_after == "a")
    const r_after = await multivars1.multivars1.get_r()
    assert(r_after.equals(new Nat(2)))
  })

  it('multivars_simple', async () => {
    await multivars_simple.multivars_simple.deploy({ as: alice })

    const u = await multivars_simple.multivars_simple.get_u()
    assert(u.equals(new Nat(0)))
    const v = await multivars_simple.multivars_simple.get_v()
    assert(v == "")
    const w = await multivars_simple.multivars_simple.get_w()
    assert(w.equals(new Int(0)))
    const x = await multivars_simple.multivars_simple.get_x()
    assert(x.equals(new Bytes("00")))
    const y = await multivars_simple.multivars_simple.get_y()
    assert(y.equals(new Nat(1)))
    const z = await multivars_simple.multivars_simple.get_z()
    assert(z.equals(new Nat(0)))
  })

  it('mutez_to_nat', async () => {
    await mutez_to_nat.mutez_to_nat.deploy({ as: alice })

    const res_before = await mutez_to_nat.mutez_to_nat.get_res()
    assert(res_before.equals(new Nat(0)))

    await mutez_to_nat.mutez_to_nat.exec({ as: alice })

    const res_after = await mutez_to_nat.mutez_to_nat.get_res()
    assert(res_after.equals(new Nat(2000000)))
  })

  it('nat_to_string', async () => {
    await nat_to_string.nat_to_string.deploy({ as: alice })

    const res_before = await nat_to_string.nat_to_string.get_res()
    assert(res_before == "")

    await nat_to_string.nat_to_string.exec(new Nat(42), { as: alice })

    const res_42 = await nat_to_string.nat_to_string.get_res()
    assert(res_42 == "42")

    await nat_to_string.nat_to_string.exec(new Nat(2), { as: alice })

    const res_2 = await nat_to_string.nat_to_string.get_res()
    assert(res_2 == "2")

    await nat_to_string.nat_to_string.exec(new Nat(0), { as: alice })

    const res_0 = await nat_to_string.nat_to_string.get_res()
    assert(res_0 == "0")
  })

  it('nat_to_string_2', async () => {
    await nat_to_string_2.nat_to_string_2.deploy({ as: alice })

    const s1_before = await nat_to_string_2.nat_to_string_2.get_s1()
    const s2_before = await nat_to_string_2.nat_to_string_2.get_s2()
    const bal_before = await nat_to_string_2.nat_to_string_2.get_bal()
    assert(s1_before == "")
    assert(s2_before == "")
    assert(bal_before.equals(new Nat(1)))

    await nat_to_string_2.nat_to_string_2.callback(new Nat(100), { as: alice })

    const s1_after = await nat_to_string_2.nat_to_string_2.get_s1()
    const s2_after = await nat_to_string_2.nat_to_string_2.get_s2()
    const bal_after = await nat_to_string_2.nat_to_string_2.get_bal()
    assert(s1_after == "100")
    assert(s2_after == "1000")
    assert(bal_after.equals(new Nat(100)))
  })

  it('nested_for', async () => {
    await nested_for.nested_for.deploy({ as: alice })

    const my_asset_before = await nested_for.nested_for.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "a")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "aa")
    const res_before = await nested_for.nested_for.get_res()
    assert(res_before.equals(new Nat(0)))

    await nested_for.nested_for.exec({ as: alice })

    const my_asset_after = await nested_for.nested_for.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "a")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "aa")
    const res_after = await nested_for.nested_for.get_res()
    assert(res_after.equals(new Nat(12)))
  })

  it('nested_if_return', async () => {
    await nested_if_return.nested_if_return.deploy({ as: alice })

    const a_before = await nested_if_return.nested_if_return.get_a()
    assert(a_before.equals(new Nat(0)))
    const b_before = await nested_if_return.nested_if_return.get_b()
    assert(b_before.equals(new Nat(0)))
    const c_before = await nested_if_return.nested_if_return.get_c()
    assert(c_before.equals(new Nat(0)))

    await nested_if_return.nested_if_return.exec({ as: alice })

    const a_after = await nested_if_return.nested_if_return.get_a()
    assert(a_after.equals(new Nat(1)))
    const b_after = await nested_if_return.nested_if_return.get_b()
    assert(b_after.equals(new Nat(2)))
    const c_after = await nested_if_return.nested_if_return.get_c()
    assert(c_after.equals(new Nat(3)))
  })

  it('no_entrypoint', async () => {
    await no_entrypoint.no_entrypoint.deploy({ as: alice })

    const v = await no_entrypoint.no_entrypoint.get_v()
    assert(v.equals(new Nat(0)))
  })

  it('not_int', async () => {
    await not_int.not_int.deploy({ as: alice })
    const res_before = await not_int.not_int.get_res();
    assert(res_before.equals(new Int(0)), "Invalid Value")
    await not_int.not_int.exec({ as: alice })
    const res_after = await not_int.not_int.get_res();
    assert(res_after.equals(new Int(-8)), "Invalid Value")
  })

  it('not_nat', async () => {
    await not_nat.not_nat.deploy({ as: alice })

    const res_before = await not_nat.not_nat.get_res();
    assert(res_before.equals(new Int(0)), "Invalid Value")

    await not_nat.not_nat.exec({ as: alice })

    const res_after = await not_nat.not_nat.get_res();
    assert(res_after.equals(new Int(-8)), "Invalid Value")
  })

  it('nothing', async () => {
    await nothing.nothing.deploy({ as: alice })

    await nothing.nothing.exec({ as: alice })
  })

  it('one_constant', async () => {
    await one_constant.one_constant.deploy({ as: alice })

    const res_before = await one_constant.one_constant.get_res();
    assert(res_before == "")

    await one_constant.one_constant.exec({ as: alice })

    const res_after = await one_constant.one_constant.get_res();
    assert(res_after == "my_constant")
  })

  it('op_assign_rat_update_asset', async () => {
    await op_assign_rat_update_asset.op_assign_rat_update_asset.deploy({ as: alice })

    const my_asset_before = await op_assign_rat_update_asset.op_assign_rat_update_asset.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].r1.equals(new Rational(1)))
    assert(my_asset_before[0][1].r2.equals(new Rational(1)))
    assert(my_asset_before[0][1].r3.equals(new Rational(1)))
    assert(my_asset_before[0][1].r4.equals(new Rational(1)))

    await op_assign_rat_update_asset.op_assign_rat_update_asset.exec({ as: alice })

    const my_asset_after = await op_assign_rat_update_asset.op_assign_rat_update_asset.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].r1.equals(new Rational(2)))
    assert(my_asset_after[0][1].r2.equals(new Rational(0)))
    assert(my_asset_after[0][1].r3.equals(new Rational(0.9)))
    assert(my_asset_after[0][1].r4.equals(new Rational(1, new BigNumber(0.9))))
  })

  it('param_const', async () => {
    await param_const.param_const.deploy(new Nat(2), { as: alice })

    const res_before = await param_const.param_const.get_res();
    assert(res_before.equals(new Nat(0)))

    await param_const.param_const.exec({ as: alice })

    const res_after = await param_const.param_const.get_res();
    assert(res_after.equals(new Nat(2)))
  })

  it('parameter_expr_map', async () => {
    await parameter_expr_map.parameter_expr_map.deploy({ as: alice })

    await parameter_expr_map.parameter_expr_map.e0({ as: alice })

    const smap_before = await parameter_expr_map.parameter_expr_map.get_smap()
    assert(smap_before.length == 0)
    const slist_before = await parameter_expr_map.parameter_expr_map.get_slist()
    assert(slist_before.length == 0)

    await parameter_expr_map.parameter_expr_map.put([["a", new Nat(2)]], "k", new Nat(0), { as: alice })

    const smap_put = await parameter_expr_map.parameter_expr_map.get_smap()
    assert(smap_put.length == 2)
    assert(smap_put[0][0] == "a")
    assert(smap_put[0][1].equals(new Nat(2)))
    assert(smap_put[1][0] == "k")
    assert(smap_put[1][1].equals(new Nat(0)))
    const slist_put = await parameter_expr_map.parameter_expr_map.get_slist()
    assert(slist_put.length == 0)

    await parameter_expr_map.parameter_expr_map.e2([new Nat(0)], { as: alice })

    const smap_e2 = await parameter_expr_map.parameter_expr_map.get_smap()
    assert(smap_e2.length == 2)
    assert(smap_e2[0][0] == "a")
    assert(smap_e2[0][1].equals(new Nat(2)))
    assert(smap_e2[1][0] == "k")
    assert(smap_e2[1][1].equals(new Nat(0)))
    const slist_e2 = await parameter_expr_map.parameter_expr_map.get_slist()
    assert(slist_e2.length == 1)
    assert(slist_e2[0].equals(new Nat(0)))
  })

  it('partial_record', async () => {
    await partial_record.partial_record.deploy({ as: alice })

    const my_asset_before = await partial_record.partial_record.get_my_asset()
    assert(my_asset_before.length == 0)

    await partial_record.partial_record.exec({ as: alice })

    const my_asset_after = await partial_record.partial_record.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "myid")
    assert(my_asset_after[0][1].equals(new Nat(0)))
  })

  it('rat_arith_div', async () => {
    await rat_arith_div.rat_arith_div.deploy({ as: alice })

    const res_before = await rat_arith_div.rat_arith_div.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_arith_div.rat_arith_div.exec(new Rational(2), { as: alice })

    const res_after = await rat_arith_div.rat_arith_div.get_res()
    assert(res_after.equals(new Rational(4)))
  })

  it('rat_arith_minus', async () => {
    await rat_arith_minus.rat_arith_minus.deploy({ as: alice })

    const res_before = await rat_arith_minus.rat_arith_minus.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_arith_minus.rat_arith_minus.exec(new Rational(2), { as: alice })

    const res_after = await rat_arith_minus.rat_arith_minus.get_res()
    assert(res_after.equals(new Rational(1.5)))
  })

  it('rat_arith_mult', async () => {
    await rat_arith_mult.rat_arith_mult.deploy({ as: alice })

    const res_before = await rat_arith_mult.rat_arith_mult.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_arith_mult.rat_arith_mult.exec(new Rational(2), { as: alice })

    const res_after = await rat_arith_mult.rat_arith_mult.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('rat_arith_plus', async () => {
    await rat_arith_plus.rat_arith_plus.deploy({ as: alice })

    const res_before = await rat_arith_plus.rat_arith_plus.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_arith_plus.rat_arith_plus.exec(new Rational(1), { as: alice })

    const res_after = await rat_arith_plus.rat_arith_plus.get_res()
    assert(res_after.equals(new Rational(1.5)))
  })

  it('rat_arith_uminus', async () => {
    await rat_arith_uminus.rat_arith_uminus.deploy({ as: alice })

    const res_before = await rat_arith_uminus.rat_arith_uminus.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_arith_uminus.rat_arith_uminus.exec(new Rational(1), { as: alice })

    const res_after = await rat_arith_uminus.rat_arith_uminus.get_res()
    assert(res_after.equals(new Rational(-1)))
  })

  it('rat_cmp_eq', async () => {
    await rat_cmp_eq.rat_cmp_eq.deploy({ as: alice })

    const res_before = await rat_cmp_eq.rat_cmp_eq.get_res()
    assert(res_before == false)

    await rat_cmp_eq.rat_cmp_eq.exec(new Rational(0.25), { as: alice })

    const res_025 = await rat_cmp_eq.rat_cmp_eq.get_res()
    assert(res_025 == true)

    await rat_cmp_eq.rat_cmp_eq.exec(new Rational(1), { as: alice })

    const res_1 = await rat_cmp_eq.rat_cmp_eq.get_res()
    assert(res_1 == false)

    await rat_cmp_eq.rat_cmp_eq.exec(new Rational(0), { as: alice })

    const res_0 = await rat_cmp_eq.rat_cmp_eq.get_res()
    assert(res_0 == false)
  })

  it('rat_cmp_ge', async () => {
    await rat_cmp_ge.rat_cmp_ge.deploy({ as: alice })

    const res_before = await rat_cmp_ge.rat_cmp_ge.get_res()
    assert(res_before == false)

    await rat_cmp_ge.rat_cmp_ge.exec(new Rational(0.25), { as: alice })

    const res_025 = await rat_cmp_ge.rat_cmp_ge.get_res()
    assert(res_025 == true)

    await rat_cmp_ge.rat_cmp_ge.exec(new Rational(1), { as: alice })

    const res_1 = await rat_cmp_ge.rat_cmp_ge.get_res()
    assert(res_1 == true)

    await rat_cmp_ge.rat_cmp_ge.exec(new Rational(0), { as: alice })

    const res_0 = await rat_cmp_ge.rat_cmp_ge.get_res()
    assert(res_0 == false)
  })

  it('rat_cmp_gt', async () => {
    await rat_cmp_gt.rat_cmp_gt.deploy({ as: alice })

    const res_before = await rat_cmp_gt.rat_cmp_gt.get_res()
    assert(res_before == false)

    await rat_cmp_gt.rat_cmp_gt.exec(new Rational(0.25), { as: alice })

    const res_025 = await rat_cmp_gt.rat_cmp_gt.get_res()
    assert(res_025 == false)

    await rat_cmp_gt.rat_cmp_gt.exec(new Rational(1), { as: alice })

    const res_1 = await rat_cmp_gt.rat_cmp_gt.get_res()
    assert(res_1 == true)

    await rat_cmp_gt.rat_cmp_gt.exec(new Rational(0), { as: alice })

    const res_0 = await rat_cmp_gt.rat_cmp_gt.get_res()
    assert(res_0 == false)
  })

  it('rat_cmp_le', async () => {
    await rat_cmp_le.rat_cmp_le.deploy({ as: alice })

    const res_before = await rat_cmp_le.rat_cmp_le.get_res()
    assert(res_before == false)

    await rat_cmp_le.rat_cmp_le.exec(new Rational(0.25), { as: alice })

    const res_025 = await rat_cmp_le.rat_cmp_le.get_res()
    assert(res_025 == true)

    await rat_cmp_le.rat_cmp_le.exec(new Rational(1), { as: alice })

    const res_1 = await rat_cmp_le.rat_cmp_le.get_res()
    assert(res_1 == false)

    await rat_cmp_le.rat_cmp_le.exec(new Rational(0), { as: alice })

    const res_0 = await rat_cmp_le.rat_cmp_le.get_res()
    assert(res_0 == true)
  })

  it('rat_cmp_lt', async () => {
    await rat_cmp_lt.rat_cmp_lt.deploy({ as: alice })

    const res_before = await rat_cmp_lt.rat_cmp_lt.get_res()
    assert(res_before == false)

    await rat_cmp_lt.rat_cmp_lt.exec(new Rational(0.25), { as: alice })

    const res_025 = await rat_cmp_lt.rat_cmp_lt.get_res()
    assert(res_025 == false)

    await rat_cmp_lt.rat_cmp_lt.exec(new Rational(1), { as: alice })

    const res_1 = await rat_cmp_lt.rat_cmp_lt.get_res()
    assert(res_1 == false)

    await rat_cmp_lt.rat_cmp_lt.exec(new Rational(0), { as: alice })

    const res_0 = await rat_cmp_lt.rat_cmp_lt.get_res()
    assert(res_0 == true)
  })

  it('rat_dur', async () => {
    await rat_dur.rat_dur.deploy({ as: alice })

    const res_before = await rat_dur.rat_dur.get_res()
    assert(res_before.equals(new Duration("0s")))

    await rat_dur.rat_dur.exec({ as: alice })

    const res_after = await rat_dur.rat_dur.get_res()
    assert(res_after.equals(new Duration("30s")))
  })

  it('rat_int', async () => {
    await rat_int.rat_int.deploy({ as: alice })

    const res_before = await rat_int.rat_int.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_int.rat_int.exec(new Int(-1), { as: alice })

    const res_m1 = await rat_int.rat_int.get_res()
    assert(res_m1.equals(new Rational(-1)))

    await rat_int.rat_int.exec(new Int(0), { as: alice })

    const res_0 = await rat_int.rat_int.get_res()
    assert(res_0.equals(new Rational(0)))

    await rat_int.rat_int.exec(new Int(1), { as: alice })

    const res_1 = await rat_int.rat_int.get_res()
    assert(res_1.equals(new Rational(1)))
  })

  it('rat_max', async () => {
    await rat_max.rat_max.deploy({ as: alice })

    const res_before = await rat_max.rat_max.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_max.rat_max.exec({ as: alice })

    const res_after = await rat_max.rat_max.get_res()
    assert(res_after.equals(new Rational(0.5)))
  })

  it('rat_min', async () => {
    await rat_min.rat_min.deploy({ as: alice })

    const res_before = await rat_min.rat_min.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_min.rat_min.exec({ as: alice })

    const res_after = await rat_min.rat_min.get_res()
    assert(res_after.equals(new Rational(2, new BigNumber(5))))
  })

  it('rat_nat', async () => {
    await rat_nat.rat_nat.deploy({ as: alice })

    const res_before = await rat_nat.rat_nat.get_res()
    assert(res_before.equals(new Rational(0)))

    await rat_nat.rat_nat.exec(new Nat(1), { as: alice })

    const res_1 = await rat_nat.rat_nat.get_res()
    assert(res_1.equals(new Rational(1)))

    await rat_nat.rat_nat.exec(new Nat(0), { as: alice })

    const res_0 = await rat_nat.rat_nat.get_res()
    assert(res_0.equals(new Rational(0)))
  })

  it('rat_neg', async () => {
    await rat_neg.rat_neg.deploy({ as: alice })

    const a_before = await rat_neg.rat_neg.get_a()
    assert(a_before.equals(new Rational(0.5)))
    const b_before = await rat_neg.rat_neg.get_b()
    assert(b_before.equals(new Rational(-0.5)))
    const c_before = await rat_neg.rat_neg.get_c()
    assert(c_before.equals(new Rational(-0.5)))
    const d_before = await rat_neg.rat_neg.get_d()
    assert(d_before.equals(new Rational(0.5)))

    const na_before = await rat_neg.rat_neg.get_na()
    assert(na_before.equals(new Rational(-0.5)))
    const nb_before = await rat_neg.rat_neg.get_nb()
    assert(nb_before.equals(new Rational(0.5)))
    const nc_before = await rat_neg.rat_neg.get_nc()
    assert(nc_before.equals(new Rational(0.5)))
    const nd_before = await rat_neg.rat_neg.get_nd()
    assert(nd_before.equals(new Rational(-0.5)))

    const ca_before = await rat_neg.rat_neg.get_ca()
    assert(ca_before.equals(new Rational(0)))
    const cb_before = await rat_neg.rat_neg.get_cb()
    assert(cb_before.equals(new Rational(0)))
    const cc_before = await rat_neg.rat_neg.get_cc()
    assert(cc_before.equals(new Rational(0)))
    const cd_before = await rat_neg.rat_neg.get_cd()
    assert(cd_before.equals(new Rational(0)))

    await rat_neg.rat_neg.exec({ as: alice })

    const a_after = await rat_neg.rat_neg.get_a()
    assert(a_after.equals(new Rational(0.5)))
    const b_after = await rat_neg.rat_neg.get_b()
    assert(b_after.equals(new Rational(-0.5)))
    const c_after = await rat_neg.rat_neg.get_c()
    assert(c_after.equals(new Rational(-0.5)))
    const d_after = await rat_neg.rat_neg.get_d()
    assert(d_after.equals(new Rational(0.5)))

    const na_after = await rat_neg.rat_neg.get_na()
    assert(na_after.equals(new Rational(-0.5)))
    const nb_after = await rat_neg.rat_neg.get_nb()
    assert(nb_after.equals(new Rational(0.5)))
    const nc_after = await rat_neg.rat_neg.get_nc()
    assert(nc_after.equals(new Rational(0.5)))
    const nd_after = await rat_neg.rat_neg.get_nd()
    assert(nd_after.equals(new Rational(-0.5)))

    const ca_after = await rat_neg.rat_neg.get_ca()
    assert(ca_after.equals(new Rational(1)))
    const cb_after = await rat_neg.rat_neg.get_cb()
    assert(cb_after.equals(new Rational(-1)))
    const cc_after = await rat_neg.rat_neg.get_cc()
    assert(cc_after.equals(new Rational(-1)))
    const cd_after = await rat_neg.rat_neg.get_cd()
    assert(cd_after.equals(new Rational(1)))
  })

  it('rat_tez', async () => {
    await rat_tez.rat_tez.deploy({ as: alice })

    const res_before = await rat_tez.rat_tez.get_res()
    assert(res_before.equals(new Tez(0)))

    await rat_tez.rat_tez.exec({ as: alice })

    const res_after = await rat_tez.rat_tez.get_res()
    assert(res_after.equals(new Tez(0.3)))
  })

  it('rat_tez_big', async () => {
    await rat_tez_big.rat_tez_big.deploy({ as: alice })

    const res_before = await rat_tez_big.rat_tez_big.get_res()
    assert(res_before.equals(new Tez(0)))

    await rat_tez_big.rat_tez_big.exec({ as: alice })

    const res_after = await rat_tez_big.rat_tez_big.get_res()
    assert(res_after.equals(new Tez(new BigNumber("6148914691236517204"), "mutez")))
  })

  it('rational_cmp', async () => {
    await rational_cmp.rational_cmp.deploy({ as: alice })

    await rational_cmp.rational_cmp.exec({ as: alice })
  })

  it('rational_duration', async () => {
    await rational_duration.rational_duration.deploy({ as: alice })

    set_mockup_now(new Date("2021-01-01"))

    const last_exec_before = await rational_duration.rational_duration.get_last_exec();
    assert(last_exec_before.toISOString() == '2020-01-01T00:00:00.000Z')

    await rational_duration.rational_duration.exec(alice.get_address(), { amount: new Tez(1), as: alice })

    const last_exec_after = await rational_duration.rational_duration.get_last_exec();
    assert(last_exec_after.toISOString() == '2021-01-01T00:00:00.000Z')
  })

  it('rational_full', async () => {
    await rational_full.rational_full.deploy({ amount: new Tez(0.3), as: alice })

    const my_asset_before = await rational_full.rational_full.get_my_asset()
    assert(my_asset_before.length == 0)

    await rational_full.rational_full.exec(alice.get_address(), new Rational(0.5), { as: alice })

    const my_asset_after = await rational_full.rational_full.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(alice.get_address()))
    assert(my_asset_after[0][1].equals(new Rational(0.5)))
  })

  it('rational_rat_tez_mult', async () => {
    await rational_rat_tez_mult.rational_rat_tez_mult.deploy({ amount: new Tez(0.2), as: alice })

    await rational_rat_tez_mult.rational_rat_tez_mult.exec(alice.get_address(), { as: alice })
  })

  it('rational_simple', async () => {
    await rational_simple.rational_simple.deploy({ as: alice })
  })

  it('rational_tez_rat_mult', async () => {
    await rational_tez_rat_mult.rational_tez_rat_mult.deploy({ amount: new Tez(0.3), as: alice })

    await rational_tez_rat_mult.rational_tez_rat_mult.exec(alice.get_address(), { as: alice })
  })

  it('rec_update', async () => {
    await rec_update.rec_update.deploy({ as: alice })

    const res_before = await rec_update.rec_update.get_res()
    assert(res_before.equals(new rec_update.my_record("", new Int(0), new Nat(0))))

    await rec_update.rec_update.exec({ as: alice })

    const res_after = await rec_update.rec_update.get_res()
    assert(res_after.equals(new rec_update.my_record("mystr", new Int(0), new Nat(2))))
  })

  it('rec_update2', async () => {
    await rec_update2.rec_update2.deploy({ as: alice })

    const res_before = await rec_update2.rec_update2.get_res()
    assert(res_before.equals(new rec_update2.my_record(new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0), new Nat(0))))

    await rec_update2.rec_update2.exec({ as: alice })

    const res_after = await rec_update2.rec_update2.get_res()
    assert(res_after.equals(new rec_update2.my_record(new Nat(0), new Nat(1), new Nat(2), new Nat(3), new Nat(4), new Nat(5), new Nat(6), new Nat(7), new Nat(8), new Nat(9), new Nat(10), new Nat(11), new Nat(12))))
  })

  it('record_access', async () => {
    await record_access.record_access.deploy({ as: alice })
    const r_before = await record_access.record_access.get_r();
    assert(r_before.equals(new record_access.my_record("mystr", new Nat(2), new Bytes("ff"), new Int(1), "mystr2", new Nat(4), new Bytes("a0ff"), new Int(3))))
    const res_a_before = await record_access.record_access.get_res_a();
    assert(res_a_before == "")
    const res_b_before = await record_access.record_access.get_res_b();
    assert(res_b_before.equals(new Nat(0)))
    const res_c_before = await record_access.record_access.get_res_c();
    assert(res_c_before.equals(new Bytes("")))
    const res_d_before = await record_access.record_access.get_res_d();
    assert(res_d_before.equals(new Int(0)))
    const res_e_before = await record_access.record_access.get_res_e();
    assert(res_e_before == "")
    const res_f_before = await record_access.record_access.get_res_f();
    assert(res_f_before.equals(new Nat(0)))
    const res_g_before = await record_access.record_access.get_res_g();
    assert(res_g_before.equals(new Bytes("")))
    const res_h_before = await record_access.record_access.get_res_h();
    assert(res_h_before.equals(new Int(0)))
    await record_access.record_access.exec({ as: alice });
    const r_after = await record_access.record_access.get_r();
    assert(r_after.equals(new record_access.my_record("mystr", new Nat(2), new Bytes("ff"), new Int(1), "mystr2", new Nat(4), new Bytes("a0ff"), new Int(3))))
    const res_a_after = await record_access.record_access.get_res_a();
    assert(res_a_after == "mystr")
    const res_b_after = await record_access.record_access.get_res_b();
    assert(res_b_after.equals(new Nat(2)))
    const res_c_after = await record_access.record_access.get_res_c();
    assert(res_c_after.equals(new Bytes("ff")))
    const res_d_after = await record_access.record_access.get_res_d();
    assert(res_d_after.equals(new Int(1)))
    const res_e_after = await record_access.record_access.get_res_e();
    assert(res_e_after == "mystr2")
    const res_f_after = await record_access.record_access.get_res_f();
    assert(res_f_after.equals(new Nat(4)))
    const res_g_after = await record_access.record_access.get_res_g();
    assert(res_g_after.equals(new Bytes("a0ff")))
    const res_h_after = await record_access.record_access.get_res_h();
    assert(res_h_after.equals(new Int(3)))
  })

  it('record_access2', async () => {
    await record_access2.record_access2.deploy({ as: alice })
    const r_before = await record_access2.record_access2.get_r();
    assert(r_before.equals(new record_access2.my_record(new record_access2.my_record3("mystr7", new Nat(7)), new record_access2.my_record3("mystr0", new Nat(5)), new Bytes("ff"), new Int(1), "mystr2", new record_access2.my_record2("", new Nat(4), new Bytes("")), new Bytes("a0ff"), new record_access2.my_record3("mystr8", new Nat(8)))))
    const res_a_before = await record_access2.record_access2.get_res_a();
    assert(res_a_before.equals(new record_access2.my_record3("", new Nat(0))))
    const res_b_before = await record_access2.record_access2.get_res_b();
    assert(res_b_before.equals(new record_access2.my_record3("", new Nat(0))))
    const res_c_before = await record_access2.record_access2.get_res_c();
    assert(res_c_before.equals(new Bytes("")))
    const res_d_before = await record_access2.record_access2.get_res_d();
    assert(res_d_before.equals(new Int(0)))
    const res_e_before = await record_access2.record_access2.get_res_e();
    assert(res_e_before == "")
    const res_f_before = await record_access2.record_access2.get_res_f();
    assert(res_f_before.equals(new record_access2.my_record2("", new Nat(0), new Bytes(""))))
    const res_g_before = await record_access2.record_access2.get_res_g();
    assert(res_g_before.equals(new Bytes("")))
    const res_h_before = await record_access2.record_access2.get_res_h();
    assert(res_h_before.equals(new record_access2.my_record3("", new Nat(0))))
    const res_a_alpha_before = await record_access2.record_access2.get_res_a_alpha();
    assert(res_a_alpha_before == "")
    const res_a_beta_before = await record_access2.record_access2.get_res_a_beta();
    assert(res_a_beta_before.equals(new Nat(0)))
    const res_b_alpha_before = await record_access2.record_access2.get_res_b_alpha();
    assert(res_b_alpha_before == "")
    const res_b_beta_before = await record_access2.record_access2.get_res_b_beta();
    assert(res_b_beta_before.equals(new Nat(0)))
    const res_f_x_before = await record_access2.record_access2.get_res_f_x();
    assert(res_f_x_before == "")
    const res_f_y_before = await record_access2.record_access2.get_res_f_y();
    assert(res_f_y_before.equals(new Nat(0)))
    const res_f_z_before = await record_access2.record_access2.get_res_f_z();
    assert(res_f_z_before.equals(new Bytes("")))
    const res_h_alpha_before = await record_access2.record_access2.get_res_h_alpha();
    assert(res_h_alpha_before == "")
    const res_h_beta_before = await record_access2.record_access2.get_res_h_beta();
    assert(res_h_beta_before.equals(new Nat(0)))
    await record_access2.record_access2.exec({ as: alice });
    const r_after = await record_access2.record_access2.get_r();
    assert(r_after.equals(new record_access2.my_record(new record_access2.my_record3("mystr7", new Nat(7)), new record_access2.my_record3("mystr0", new Nat(5)), new Bytes("ff"), new Int(1), "mystr2", new record_access2.my_record2("", new Nat(4), new Bytes("")), new Bytes("a0ff"), new record_access2.my_record3("mystr8", new Nat(8)))))
    const res_a_after = await record_access2.record_access2.get_res_a();
    assert(res_a_after.equals(new record_access2.my_record3("mystr7", new Nat(7))))
    const res_b_after = await record_access2.record_access2.get_res_b();
    assert(res_b_after.equals(new record_access2.my_record3("mystr0", new Nat(5))))
    const res_c_after = await record_access2.record_access2.get_res_c();
    assert(res_c_after.equals(new Bytes("ff")))
    const res_d_after = await record_access2.record_access2.get_res_d();
    assert(res_d_after.equals(new Int(1)))
    const res_e_after = await record_access2.record_access2.get_res_e();
    assert(res_e_after == "mystr2")
    const res_f_after = await record_access2.record_access2.get_res_f();
    assert(res_f_after.equals(new record_access2.my_record2("", new Nat(4), new Bytes(""))))
    const res_g_after = await record_access2.record_access2.get_res_g();
    assert(res_g_after.equals(new Bytes("a0ff")))
    const res_h_after = await record_access2.record_access2.get_res_h();
    assert(res_h_after.equals(new record_access2.my_record3("mystr8", new Nat(8))))
    const res_a_alpha_after = await record_access2.record_access2.get_res_a_alpha();
    assert(res_a_alpha_after == "mystr7")
    const res_a_beta_after = await record_access2.record_access2.get_res_a_beta();
    assert(res_a_beta_after.equals(new Nat(7)))
    const res_b_alpha_after = await record_access2.record_access2.get_res_b_alpha();
    assert(res_b_alpha_after == "mystr0")
    const res_b_beta_after = await record_access2.record_access2.get_res_b_beta();
    assert(res_b_beta_after.equals(new Nat(5)))
    const res_f_x_after = await record_access2.record_access2.get_res_f_x();
    assert(res_f_x_after == "")
    const res_f_y_after = await record_access2.record_access2.get_res_f_y();
    assert(res_f_y_after.equals(new Nat(4)))
    const res_f_z_after = await record_access2.record_access2.get_res_f_z();
    assert(res_f_z_after.equals(new Bytes("")))
    const res_h_alpha_after = await record_access2.record_access2.get_res_h_alpha();
    assert(res_h_alpha_after == "mystr8")
    const res_h_beta_after = await record_access2.record_access2.get_res_h_beta();
    assert(res_h_beta_after.equals(new Nat(8)))
  })

  it('record_container', async () => {
    await record_container.record_container.deploy({ as: alice })

    const vl = await record_container.record_container.get_vl()
    assert(vl.length == 0)

    const vm = await record_container.record_container.get_vm()
    assert(vm.length == 0)
  })

  it('record_double_key', async () => {
    await record_double_key.record_double_key.deploy({ as: alice })

    const my_asset_before = await record_double_key.record_double_key.get_my_asset()
    assert(my_asset_before.length == 0)

    await record_double_key.record_double_key.exec({ as: alice })

    const my_asset_after = await record_double_key.record_double_key.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].a.equals(new Nat(0)))
    assert(my_asset_after[0][0].b.equals(alice.get_address()))
    assert(my_asset_after[0][1].c.equals(new Nat(2)))
    assert(my_asset_after[0][1].d.equals(new Nat(0)))
  })

  it('record_in_enum', async () => {
    await record_in_enum.record_in_enum.deploy({ as: alice })

    const res_before = await record_in_enum.record_in_enum.get_res();
    assert(res_before.equals(new Nat(0)), "Invalid Value")

    await record_in_enum.record_in_enum.exec({ as: alice })

    const res_after = await record_in_enum.record_in_enum.get_res();
    assert(res_after.equals(new Nat(10)), "Invalid Value")
  })

  it('record_update', async () => {
    await record_update.record_update.deploy({ as: alice })

    const r_before = await record_update.record_update.get_r()
    assert(r_before.equals(new record_update.my_record("", new Int(0), new Nat(0))))

    await record_update.record_update.exec({ as: alice })

    const r_after = await record_update.record_update.get_r()
    assert(r_after.equals(new record_update.my_record("", new Int(1), new Nat(0))))
  })

  it('remove_asset_with_partition', async () => {
    await remove_asset_with_partition.remove_asset_with_partition.deploy({ as: alice })

    const my_asset_before = await remove_asset_with_partition.remove_asset_with_partition.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].col.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].col.length == 0)
    const o_asset_before = await remove_asset_with_partition.remove_asset_with_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await remove_asset_with_partition.remove_asset_with_partition.init({ as: alice })

    const my_asset_init = await remove_asset_with_partition.remove_asset_with_partition.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].value.equals(new Int(0)))
    assert(my_asset_init[0][1].col.length == 1)
    assert(my_asset_init[0][1].col[0] == "oid")
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].value.equals(new Int(1)))
    assert(my_asset_init[1][1].col.length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].value.equals(new Int(2)))
    assert(my_asset_init[2][1].col.length == 0)
    const o_asset_init = await remove_asset_with_partition.remove_asset_with_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0] == "oid")

    await remove_asset_with_partition.remove_asset_with_partition.exec({ as: alice })

    const my_asset_after = await remove_asset_with_partition.remove_asset_with_partition.get_my_asset()
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0] == "id1")
    assert(my_asset_after[0][1].value.equals(new Int(1)))
    assert(my_asset_after[0][1].col.length == 0)
    assert(my_asset_after[1][0] == "id2")
    assert(my_asset_after[1][1].value.equals(new Int(2)))
    assert(my_asset_after[1][1].col.length == 0)
    const o_asset_after = await remove_asset_with_partition.remove_asset_with_partition.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('reverse_otherwise', async () => {
    await reverse_otherwise.reverse_otherwise.deploy({ as: alice })

    await expect_to_fail(async () => {
      await reverse_otherwise.reverse_otherwise.exec({ as: alice })
    }, { string: "false" })
  })

  it('reverse_with_enum', async () => {
    await reverse_with_enum.reverse_with_enum.deploy({ as: alice })

    const res_before = await reverse_with_enum.reverse_with_enum.get_res();
    assert(res_before.length == 0)

    await reverse_with_enum.reverse_with_enum.exec({ as: alice })

    const res_after = await reverse_with_enum.reverse_with_enum.get_res();
    assert(res_after.length == 4)
    assert(res_after[0].equals(new reverse_with_enum.entry1(new Int(3))))
    assert(res_after[1].equals(new reverse_with_enum.entry2("2")))
    assert(res_after[2].equals(new reverse_with_enum.entry2("1")))
    assert(res_after[3].equals(new reverse_with_enum.entry1(new Int(0))))
  })

  it('rf_failif_with', async () => {
    await rf_failif_with.rf_failif_with.deploy({ as: alice })

    await rf_failif_with.rf_failif_with.exec({ as: alice })
  })

  it('rf_require_otherwise', async () => {
    await rf_require_otherwise.rf_require_otherwise.deploy({ as: alice })

    await rf_require_otherwise.rf_require_otherwise.exec({ as: alice })
  })

  it('same_varname_in_two_distinct_scope', async () => {
    await same_varname_in_two_distinct_scope.same_varname_in_two_distinct_scope.deploy({ as: alice })

    await same_varname_in_two_distinct_scope.same_varname_in_two_distinct_scope.exec({ as: alice })
  })

  it('sample_asset_view', async () => {
    await sample_asset_view.sample_asset_view.deploy({ as: alice })

    const res_before = await sample_asset_view.sample_asset_view.get_res();
    assert(res_before.length == 0)

    await sample_asset_view.sample_asset_view.exec([new Nat(0)], { as: alice })

    const res_after = await sample_asset_view.sample_asset_view.get_res();
    assert(res_after.length == 1)
    assert(res_after[0].equals(new Nat(0)))

    const g = await sample_asset_view.sample_asset_view.my_getter({ as: alice })
    assert(g.length == 2)
    assert(g[0].equals(new Nat(0)))
    assert(g[1].equals(new Nat(2)))

    const v = await sample_asset_view.sample_asset_view.view_my_view({ as: alice })
    assert(v?.length == 2)
    assert(v[0].equals(new Nat(0)))
    assert(v[1].equals(new Nat(2)))
  })

  it('sample_make_sandbox_exec_operation', async () => {
    await sample_make_sandbox_exec_operation.sample_make_sandbox_exec_operation.deploy({ as: alice })

    const lambda: Micheline = [
      {
        prim: "DROP"
      },
      {
        prim: "NIL",
        args: [{ prim: "operation" }]
      },
      {
        prim: "PUSH",
        args: [{ prim: "address" }, { string: "tz1aSkwEot3L2kmUvcoxzjMomb9mvBNuzFK6" }]
      },
      {
        prim: "CONTRACT",
        args: [{ prim: "unit" }]
      },
      {
        prim: "IF_NONE",
        args: [[{ prim: "PUSH", args: [{ prim: "string" }, { string: "NOT_FOUND" }] }, { prim: "FAILWITH" }], []]
      },
      {
        prim: "PUSH",
        args: [{ prim: "mutez" }, { int: "1000000" }]
      },
      {
        prim: "PUSH",
        args: [{ prim: "unit" }, { prim: "Unit" }]
      },
      {
        prim: "TRANSFER_TOKENS"
      },
      {
        prim: "CONS"
      }
    ];
    const bob_balance_before = await bob.get_balance()

    await sample_make_sandbox_exec_operation.sample_make_sandbox_exec_operation.exec(lambda, { as: alice, amount: new Tez(1) })

    const bob_balance_after = await bob.get_balance()

    assert(bob_balance_before.plus(new Tez(1)).equals(bob_balance_after), "Invalid Value")
  })

  it('sample_sandbox_exec', async () => {
    await sample_sandbox_exec.sample_sandbox_exec.deploy({ as: alice })

    const lambda: Micheline = [
      {
        prim: "DROP"
      },
      {
        prim: "NIL",
        args: [{ prim: "operation" }]
      },
      {
        prim: "PUSH",
        args: [{ prim: "address" }, { string: "tz1aSkwEot3L2kmUvcoxzjMomb9mvBNuzFK6" }]
      },
      {
        prim: "CONTRACT",
        args: [{ prim: "unit" }]
      },
      {
        prim: "IF_NONE",
        args: [[{ prim: "PUSH", args: [{ prim: "string" }, { string: "NOT_FOUND" }] }, { prim: "FAILWITH" }], []]
      },
      {
        prim: "PUSH",
        args: [{ prim: "mutez" }, { int: "1000000" }]
      },
      {
        prim: "PUSH",
        args: [{ prim: "unit" }, { prim: "Unit" }]
      },
      {
        prim: "TRANSFER_TOKENS"
      },
      {
        prim: "CONS"
      }
    ];
    const bob_balance_before = await bob.get_balance()

    await sample_sandbox_exec.sample_sandbox_exec.exec(lambda, { as: alice, amount: new Tez(1) })

    const bob_balance_after = await bob.get_balance()

    assert(bob_balance_before.plus(new Tez(1)).equals(bob_balance_after), "Invalid Value")
  })

  it('sample_view_asset_value', async () => {
    await sample_view_asset_value.sample_view_asset_value.deploy({ as: alice })
    const res_0 = await sample_view_asset_value.sample_view_asset_value.get_my_asset_value("id0")
    assert(res_0?.equals(new Nat(0)))
    const res_1 = await sample_view_asset_value.sample_view_asset_value.get_my_asset_value("id1")
    assert(res_1?.equals(new Nat(1)))
    const res_2 = await sample_view_asset_value.sample_view_asset_value.get_my_asset_value("id2")
    assert(res_2 == undefined)
  })

  it('sapling_empty_state', async () => {
    await sapling_empty_state.sapling_empty_state.deploy({ as: alice })
    const res_before = await sapling_empty_state.sapling_empty_state.get_res();
    assert(res_before !== undefined)

    await sapling_empty_state.sapling_empty_state.exec({ as: alice })

    const res_after = await sapling_empty_state.sapling_empty_state.get_res();
    assert(res_after !== undefined)
  })

  it('sapling_var', async () => {
    await sapling_var.sapling_var.deploy({ as: alice })
    const n_before = await sapling_var.sapling_var.get_n();
    assert(n_before.equals(new Int(0)))
    const s_before = await sapling_var.sapling_var.get_s();
    assert(s_before !== undefined)

    await expect_to_fail(async () => {
      await sapling_var.sapling_var.exec(new Sapling_transaction("00000000000001f3849b5eba6e22354dbbccf076d39d63ab59d091f44bed6deb71a319cc10afed24a34ffaa403d7e58766dc6c5e0364a3d1a47e7286d87855544b8a9a4f04d6e1a6f80dba30932a82bb68fce3299aeed3ee9422d1330cffefed109dd0b753263470bea78799ee3f3cbb26a08c5dd8310ae8af66feb33950c45c67b7439e8c41e7941457b941e9ea3157105b860f9424eb210b4de663cd1239f692315049f789d367552c929f6b2aa4f0d01f2384ad1cc2daa5c4cd0731245506b614f67e7bd102ee0b639501c39b7028766fb469a99d3cd3754207098a1daec24645419514e76cbc29173e49d5d16e7aa43cd96acb77054aa333078b407987c4afdd42160bc5f585ba60296a8c1a1e48b7070c1d7106afdf6bf32c688d153b3871a784c354a779560000004f544b45fe787256593b593dcf8e54e9d57c15f86ad6ebc17c3ff65d5e7e6f216283ab4af840848b9a6928f3d65156fd10bef74b06366de141f906f94b48c9f0d0af5da81ee00177b8760cb6b99f74db3951eede8ad2be0b2f7aee18486431a9a1a439c639cacb0f6ebf7834e7c772d8cfa98ec7c844298f59107b5933c8876eeca7368bb9b0efb82b35e3acf6c0f6a1a7db98f3cd1c4e93f865dd654b393425d04a78e0a72529511e961025ba5e41d83a56825ab4db8809c7e9589959453608b4db6e1ce0ffa0077237bd3477007cc972642977b926d3d0d4f690550fbb543193ab31bf2c2ddf7c2a946fae1c62253dafaf25b87cbc18107469630b9f2cd0657cfdf4a6fff5d9f04bc1a50e43613900ffffffffff676980fbc2f4300c01f0b7820d00e3347c8da4ee614674376cbc45359daa54f9b5493e00000000"), { as: alice })
    }, { string: "BAD TRANSACTION" })
  })

  it('sapling_verify_update', async () => {
    await sapling_verify_update.sapling_verify_update.deploy({ as: alice })
  })

  it('section_constant_effect', async () => {
    await section_constant_effect.section_constant_effect.deploy({ as: alice })

    const res2_before = await section_constant_effect.section_constant_effect.get_res2();
    assert(res2_before.equals(new Nat(0)))
    const res3_before = await section_constant_effect.section_constant_effect.get_res3();
    assert(res3_before.equals(new Nat(0)))

    await section_constant_effect.section_constant_effect.exec({ as: alice })

    const res2_after = await section_constant_effect.section_constant_effect.get_res2();
    assert(res2_after.equals(new Nat(2)))
    const res3_after = await section_constant_effect.section_constant_effect.get_res3();
    assert(res3_after.equals(new Nat(3)))
  })

  it('section_constant_transition', async () => {
    await section_constant_transition.section_constant_transition.deploy({ as: alice })

    const res2_before = await section_constant_transition.section_constant_transition.get_res2();
    assert(res2_before.equals(new Nat(0)))
    const res3_before = await section_constant_transition.section_constant_transition.get_res3();
    assert(res3_before.equals(new Nat(0)))

    await section_constant_transition.section_constant_transition.exec({ as: alice })

    const res2_after = await section_constant_transition.section_constant_transition.get_res2();
    assert(res2_after.equals(new Nat(2)))
    const res3_after = await section_constant_transition.section_constant_transition.get_res3();
    assert(res3_after.equals(new Nat(3)))
  })

  it('select_partition', async () => {
    await select_partition.select_partition.deploy({ as: alice })

    const my_asset_before = await select_partition.select_partition.get_my_asset_value("toto")
    assert(my_asset_before == undefined)
    const o_asset_before = await select_partition.select_partition.get_o_asset()
    assert(o_asset_before.length == 0)
    const res_before = await select_partition.select_partition.get_res()
    assert(res_before.length == 0)

    await select_partition.select_partition.init({ as: alice })

    const my_asset_init = await select_partition.select_partition.get_my_asset_value("toto")
    assert(my_asset_init?.length == 1)
    assert(my_asset_init[0] == "tutu")
    const o_asset_init = await select_partition.select_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0][0] == "tutu")
    assert(o_asset_init[0][1].equals(new Nat(2)))
    const res_init = await select_partition.select_partition.get_res()
    assert(res_init.length == 0)

    await select_partition.select_partition.exec({ as: alice })

    const my_asset_after = await select_partition.select_partition.get_my_asset_value("toto")
    assert(my_asset_after?.length == 1)
    assert(my_asset_after[0] == "tutu")
    const o_asset_after = await select_partition.select_partition.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0][0] == "tutu")
    assert(o_asset_after[0][1].equals(new Nat(2)))
    const res_after = await select_partition.select_partition.get_res()
    assert(res_after.length == 1)
    assert(res_after[0] == "tutu")
  })

  it('select_partition_big_map', async () => {
    await select_partition_big_map.select_partition_big_map.deploy({ as: alice })

    const my_asset_before = await select_partition_big_map.select_partition_big_map.get_my_asset_value("toto")
    assert(my_asset_before == undefined)
    const o_asset_before = await select_partition_big_map.select_partition_big_map.get_o_asset_value("tutu")
    assert(o_asset_before == undefined)
    const res_before = await select_partition_big_map.select_partition_big_map.get_res()
    assert(res_before.length == 0)

    await select_partition_big_map.select_partition_big_map.init({ as: alice })

    const my_asset_init = await select_partition_big_map.select_partition_big_map.get_my_asset_value("toto")
    assert(my_asset_init?.length == 1)
    assert(my_asset_init[0] == "tutu")
    const o_asset_init = await select_partition_big_map.select_partition_big_map.get_o_asset_value("tutu")
    assert(o_asset_init?.equals(new Nat(2)))
    const res_init = await select_partition_big_map.select_partition_big_map.get_res()
    assert(res_init.length == 0)

    await select_partition_big_map.select_partition_big_map.exec({ as: alice })

    const my_asset_after = await select_partition_big_map.select_partition_big_map.get_my_asset_value("toto")
    assert(my_asset_after?.length == 1)
    assert(my_asset_after[0] == "tutu")
    const o_asset_after = await select_partition_big_map.select_partition_big_map.get_o_asset_value("tutu")
    assert(o_asset_after?.equals(new Nat(2)))
    const res_after = await select_partition_big_map.select_partition_big_map.get_res()
    assert(res_after.length == 1)
    assert(res_after[0] == "tutu")
  })

  it('select_with_extra_var', async () => {
    await select_with_extra_var.select_with_extra_var.deploy({ as: alice })

    const my_asset_before = await select_with_extra_var.select_with_extra_var.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_before = await select_with_extra_var.select_with_extra_var.get_res()
    assert(res_before.equals(new Int(0)))

    await select_with_extra_var.select_with_extra_var.exec("id2", { as: alice })

    const my_asset_after = await select_with_extra_var.select_with_extra_var.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(2)))
    const res_after = await select_with_extra_var.select_with_extra_var.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('select_with_extra_var2', async () => {
    await select_with_extra_var2.select_with_extra_var2.deploy({ as: alice })

    set_mockup_now(new Date("2020-01-01"))

    const my_asset_before = await select_with_extra_var2.select_with_extra_var2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].toISOString() == '2020-12-31T00:00:00.000Z')
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].toISOString() == '2020-12-31T00:00:00.000Z')
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].toISOString() == '2020-12-31T00:00:00.000Z')
    const res_before = await select_with_extra_var2.select_with_extra_var2.get_res()
    assert(res_before.length == 0)

    await select_with_extra_var2.select_with_extra_var2.exec({ as: alice })

    const my_asset_after = await select_with_extra_var2.select_with_extra_var2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].toISOString() == '2020-12-31T00:00:00.000Z')
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].toISOString() == '2020-12-31T00:00:00.000Z')
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].toISOString() == '2020-12-31T00:00:00.000Z')
    const res_after = await select_with_extra_var2.select_with_extra_var2.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] == "id0")
    assert(res_after[1] == "id1")
    assert(res_after[2] == "id2")
  })

  it('select_with_function_in_predicate', async () => {
    await select_with_function_in_predicate.select_with_function_in_predicate.deploy({ as: alice })

    const my_asset_before = await select_with_function_in_predicate.select_with_function_in_predicate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_before = await select_with_function_in_predicate.select_with_function_in_predicate.get_res()
    assert(res_before.equals(new Int(0)))

    await select_with_function_in_predicate.select_with_function_in_predicate.exec({ as: alice })

    const my_asset_after = await select_with_function_in_predicate.select_with_function_in_predicate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(2)))
    const res_after = await select_with_function_in_predicate.select_with_function_in_predicate.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('setdelegate', async () => {
    await setdelegate.setdelegate.deploy({ as: alice })

    // await setdelegate.setdelegate.exec(new Key_hash(alice.get_address().toString()), { as: alice })
  })

  it('simple', async () => {
    await simple.simple.deploy({ as: alice })

    const res_before = await simple.simple.get_res()
    assert(res_before.equals(new Nat(0)))

    await simple.simple.exec(new Nat(2), { as: alice })

    const res_after = await simple.simple.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('simple2', async () => {
    await simple2.simple2.deploy({ as: alice })

    const n_before = await simple2.simple2.get_n()
    assert(n_before.equals(new Int(0)))

    await simple2.simple2.set_value(new Int(1), { as: alice })

    const n_set_value = await simple2.simple2.get_n()
    assert(n_set_value.equals(new Int(1)))

    await simple2.simple2.inc({ as: alice })

    const n_inc = await simple2.simple2.get_n()
    assert(n_inc.equals(new Int(2)))
  })

  it('simple3', async () => {
    await simple3.simple3.deploy({ as: alice })

    await simple3.simple3.exec({ as: alice })
  })

  it('simple4', async () => {
    await simple4.simple4.deploy({ as: alice })

    await simple4.simple4.exec({ as: alice })
  })

  it('simple_2vars', async () => {
    await simple_2vars.simple_2vars.deploy({ as: alice })

    const a_before = await simple_2vars.simple_2vars.get_a()
    assert(a_before.equals(new Nat(0)))
    const b_before = await simple_2vars.simple_2vars.get_b()
    assert(b_before.equals(new Int(0)))

    await simple_2vars.simple_2vars.exec({ as: alice })

    const a_after = await simple_2vars.simple_2vars.get_a()
    assert(a_after.equals(new Nat(2)))
    const b_after = await simple_2vars.simple_2vars.get_b()
    assert(b_after.equals(new Int(3)))
  })

  it('simple_addupdate', async () => {
    await simple_addupdate.simple_addupdate.deploy({ as: alice })

    const my_asset_before = await simple_addupdate.simple_addupdate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v1.equals(new Nat(0)))
    assert(my_asset_before[0][1].v2.equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v1.equals(new Nat(1)))
    assert(my_asset_before[1][1].v2.equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v1.equals(new Nat(2)))
    assert(my_asset_before[2][1].v2.equals(new Int(2)))

    await simple_addupdate.simple_addupdate.exec({ as: alice })

    const my_asset_after = await simple_addupdate.simple_addupdate.get_my_asset()
    assert(my_asset_after.length == 4)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v1.equals(new Nat(0)))
    assert(my_asset_after[0][1].v2.equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v1.equals(new Nat(1)))
    assert(my_asset_after[1][1].v2.equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v1.equals(new Nat(2)))
    assert(my_asset_after[2][1].v2.equals(new Int(2)))
    assert(my_asset_after[3][0] == "id3")
    assert(my_asset_after[3][1].v1.equals(new Nat(3)))
    assert(my_asset_after[3][1].v2.equals(new Int(0)))
  })

  it('simple_addupdate_asset', async () => {
    await simple_addupdate_asset.simple_addupdate_asset.deploy({ as: alice })

    const updatableMap_before = await simple_addupdate_asset.simple_addupdate_asset.get_updatableMap()
    assert(updatableMap_before.length == 0)

    await simple_addupdate_asset.simple_addupdate_asset.update(new Nat(0), new Nat(1), "mystr", { as: alice })

    const updatableMap_after = await simple_addupdate_asset.simple_addupdate_asset.get_updatableMap()
    assert(updatableMap_after.length == 1)
    assert(updatableMap_after[0][0].equals(new Nat(0)))
    assert(updatableMap_after[0][1].value1.equals(new Nat(1)))
    assert(updatableMap_after[0][1].value2 == "mystr")
  })

  it('simple_arg_int', async () => {
    await simple_arg_int.simple_arg_int.deploy({ as: alice })

    const n_before = await simple_arg_int.simple_arg_int.get_n()
    assert(n_before.equals(new Int(0)))

    await simple_arg_int.simple_arg_int.assign(new Int(2), { as: alice })

    const n_after = await simple_arg_int.simple_arg_int.get_n()
    assert(n_after.equals(new Int(2)))
  })

  it('simple_arith', async () => {
    await simple_arith.simple_arith.deploy({ as: alice })

    const res_before = await simple_arith.simple_arith.get_res()
    assert(res_before.equals(new Int(0)))

    await simple_arith.simple_arith.exec({ as: alice })

    const res_after = await simple_arith.simple_arith.get_res()
    assert(res_after.equals(new Int(9)))
  })

  it('simple_asset', async () => {
    await simple_asset.simple_asset.deploy({ as: alice })

    const my_asset_before = await simple_asset.simple_asset.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const n_before = await simple_asset.simple_asset.get_n()
    assert(n_before.equals(new Int(0)))

    await simple_asset.simple_asset.add_asset({ as: alice })

    const my_asset_add_asset = await simple_asset.simple_asset.get_my_asset()
    assert(my_asset_add_asset.length == 4)
    assert(my_asset_add_asset[0][0] == "id0")
    assert(my_asset_add_asset[0][1].equals(new Int(0)))
    assert(my_asset_add_asset[1][0] == "id1")
    assert(my_asset_add_asset[1][1].equals(new Int(1)))
    assert(my_asset_add_asset[2][0] == "id2")
    assert(my_asset_add_asset[2][1].equals(new Int(2)))
    assert(my_asset_add_asset[3][0] == "id4")
    assert(my_asset_add_asset[3][1].equals(new Int(4)))
    const n_add_asset = await simple_asset.simple_asset.get_n()
    assert(n_add_asset.equals(new Int(0)))

    await expect_to_fail(async () => {
      await simple_asset.simple_asset.add_asset({ as: alice })
    }, { "prim": "Pair", "args": [{ "string": "KEY_EXISTS" }, { "string": "my_asset" }] })

    await simple_asset.simple_asset.remove_asset({ as: alice })

    const my_asset_remove_asset = await simple_asset.simple_asset.get_my_asset()
    assert(my_asset_remove_asset.length == 3)
    assert(my_asset_remove_asset[0][0] == "id1")
    assert(my_asset_remove_asset[0][1].equals(new Int(1)))
    assert(my_asset_remove_asset[1][0] == "id2")
    assert(my_asset_remove_asset[1][1].equals(new Int(2)))
    assert(my_asset_remove_asset[2][0] == "id4")
    assert(my_asset_remove_asset[2][1].equals(new Int(4)))
    const n_remove_asset = await simple_asset.simple_asset.get_n()
    assert(n_remove_asset.equals(new Int(0)))

    await simple_asset.simple_asset.exec({ as: alice })

    const my_asset_exec = await simple_asset.simple_asset.get_my_asset()
    assert(my_asset_exec.length == 3)
    assert(my_asset_exec[0][0] == "id1")
    assert(my_asset_exec[0][1].equals(new Int(1)))
    assert(my_asset_exec[1][0] == "id2")
    assert(my_asset_exec[1][1].equals(new Int(2)))
    assert(my_asset_exec[2][0] == "id4")
    assert(my_asset_exec[2][1].equals(new Int(4)))
    const n_exec = await simple_asset.simple_asset.get_n()
    assert(n_exec.equals(new Int(1)))
  })

  it('simple_asset_2', async () => {
    await simple_asset_2.simple_asset_2.deploy({ as: alice })

    const my_asset_before = await simple_asset_2.simple_asset_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Int(0)))
    assert(my_asset_before[0][1].v1 == true)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Int(1)))
    assert(my_asset_before[1][1].v1 == true)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Int(2)))
    assert(my_asset_before[2][1].v1 == true)
    const n_before = await simple_asset_2.simple_asset_2.get_n()
    assert(n_before.equals(new Int(0)))

    await simple_asset_2.simple_asset_2.add_asset({ as: alice })

    const my_asset_add_asset = await simple_asset_2.simple_asset_2.get_my_asset()
    assert(my_asset_add_asset.length == 4)
    assert(my_asset_add_asset[0][0] == "id0")
    assert(my_asset_add_asset[0][1].v0.equals(new Int(0)))
    assert(my_asset_add_asset[0][1].v1 == true)
    assert(my_asset_add_asset[1][0] == "id1")
    assert(my_asset_add_asset[1][1].v0.equals(new Int(1)))
    assert(my_asset_add_asset[1][1].v1 == true)
    assert(my_asset_add_asset[2][0] == "id2")
    assert(my_asset_add_asset[2][1].v0.equals(new Int(2)))
    assert(my_asset_add_asset[2][1].v1 == true)
    assert(my_asset_add_asset[3][0] == "id4")
    assert(my_asset_add_asset[3][1].v0.equals(new Int(4)))
    assert(my_asset_add_asset[3][1].v1 == true)
    const n_add_asset = await simple_asset_2.simple_asset_2.get_n()
    assert(n_add_asset.equals(new Int(0)))

    await expect_to_fail(async () => {
      await simple_asset_2.simple_asset_2.add_asset({ as: alice })
    }, { "prim": "Pair", "args": [{ "string": "KEY_EXISTS" }, { "string": "my_asset" }] })

    await simple_asset_2.simple_asset_2.remove_asset({ as: alice })

    const my_asset_remove_asset = await simple_asset_2.simple_asset_2.get_my_asset()
    assert(my_asset_remove_asset.length == 3)
    assert(my_asset_remove_asset[0][0] == "id1")
    assert(my_asset_remove_asset[0][1].v0.equals(new Int(1)))
    assert(my_asset_remove_asset[0][1].v1 == true)
    assert(my_asset_remove_asset[1][0] == "id2")
    assert(my_asset_remove_asset[1][1].v0.equals(new Int(2)))
    assert(my_asset_remove_asset[1][1].v1 == true)
    assert(my_asset_remove_asset[2][0] == "id4")
    assert(my_asset_remove_asset[2][1].v0.equals(new Int(4)))
    assert(my_asset_remove_asset[2][1].v1 == true)
    const n_remove_asset = await simple_asset_2.simple_asset_2.get_n()
    assert(n_remove_asset.equals(new Int(0)))

    await simple_asset_2.simple_asset_2.exec({ as: alice })

    const my_asset_exec = await simple_asset_2.simple_asset_2.get_my_asset()
    assert(my_asset_exec.length == 3)
    assert(my_asset_exec[0][0] == "id1")
    assert(my_asset_exec[0][1].v0.equals(new Int(1)))
    assert(my_asset_exec[1][0] == "id2")
    assert(my_asset_exec[1][1].v0.equals(new Int(2)))
    assert(my_asset_exec[2][0] == "id4")
    assert(my_asset_exec[2][1].v0.equals(new Int(4)))
    const n_exec = await simple_asset_2.simple_asset_2.get_n()
    assert(n_exec.equals(new Int(1)))
  })

  it('simple_asset_get_asset1_value', async () => {
    await simple_asset_get_asset1_value.simple_asset_get_asset1_value.deploy({ as: alice })

    const my_asset_before = await simple_asset_get_asset1_value.simple_asset_get_asset1_value.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await simple_asset_get_asset1_value.simple_asset_get_asset1_value.get_res()
    assert(res_before.equals(new Nat(0)))

    await simple_asset_get_asset1_value.simple_asset_get_asset1_value.exec({ as: alice })

    const my_asset_after = await simple_asset_get_asset1_value.simple_asset_get_asset1_value.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
    const res_after = await simple_asset_get_asset1_value.simple_asset_get_asset1_value.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('simple_asset_get_asset2_value', async () => {
    await simple_asset_get_asset2_value.simple_asset_get_asset2_value.deploy({ as: alice })

    const my_asset_before = await simple_asset_get_asset2_value.simple_asset_get_asset2_value.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].v1 == true)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].v1 == true)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].v1 == true)
    const res_before = await simple_asset_get_asset2_value.simple_asset_get_asset2_value.get_res()
    assert(res_before.equals(new Nat(0)))

    await simple_asset_get_asset2_value.simple_asset_get_asset2_value.exec({ as: alice })

    const my_asset_after = await simple_asset_get_asset2_value.simple_asset_get_asset2_value.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].v1 == true)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].v1 == true)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].v1 == true)
    const res_after = await simple_asset_get_asset2_value.simple_asset_get_asset2_value.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('simple_asset_get_asset2_value2', async () => {
    await simple_asset_get_asset2_value2.simple_asset_get_asset2_value2.deploy({ as: alice })

    const my_asset_before = await simple_asset_get_asset2_value2.simple_asset_get_asset2_value2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].v1 == true)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].v1 == true)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].v1 == true)
    const res_before = await simple_asset_get_asset2_value2.simple_asset_get_asset2_value2.get_res()
    assert(res_before == false)

    await simple_asset_get_asset2_value2.simple_asset_get_asset2_value2.exec({ as: alice })

    const my_asset_after = await simple_asset_get_asset2_value2.simple_asset_get_asset2_value2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].v1 == true)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].v1 == true)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].v1 == true)
    const res_after = await simple_asset_get_asset2_value2.simple_asset_get_asset2_value2.get_res()
    assert(res_after == true)
  })

  it('simple_asset_one_field', async () => {
    await simple_asset_one_field.simple_asset_one_field.deploy({ as: alice })

    const my_asset_before = await simple_asset_one_field.simple_asset_one_field.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")

    await simple_asset_one_field.simple_asset_one_field.add_asset({ as: alice })

    const my_asset_add_asset = await simple_asset_one_field.simple_asset_one_field.get_my_asset()
    assert(my_asset_add_asset.length == 4)
    assert(my_asset_add_asset[0] == "id0")
    assert(my_asset_add_asset[1] == "id1")
    assert(my_asset_add_asset[2] == "id2")
    assert(my_asset_add_asset[3] == "id4")

    await expect_to_fail(async () => {
      await simple_asset_one_field.simple_asset_one_field.add_asset({ as: alice })
    }, { "prim": "Pair", "args": [{ "string": "KEY_EXISTS" }, { "string": "my_asset" }] })

    await simple_asset_one_field.simple_asset_one_field.remove_asset({ as: alice })

    const my_asset_remove_asset = await simple_asset_one_field.simple_asset_one_field.get_my_asset()
    assert(my_asset_remove_asset.length == 3)
    assert(my_asset_remove_asset[0] == "id1")
    assert(my_asset_remove_asset[1] == "id2")
    assert(my_asset_remove_asset[2] == "id4")
  })

  it('simple_asset_skip', async () => {
    await simple_asset_skip.simple_asset_skip.deploy({ as: alice })

    const my_asset = await simple_asset_skip.simple_asset_skip.get_my_asset()
    assert(my_asset.length == 3)
    assert(my_asset[0][0] == "id0")
    assert(my_asset[0][1].value.equals(new Int(0)))
    assert(my_asset[0][1].v2.equals(new Nat(0)))
    assert(my_asset[1][0] == "id1")
    assert(my_asset[1][1].value.equals(new Int(1)))
    assert(my_asset[1][1].v2.equals(new Nat(1)))
    assert(my_asset[2][0] == "id2")
    assert(my_asset[2][1].value.equals(new Int(2)))
    assert(my_asset[2][1].v2.equals(new Nat(2)))
  })

  it('simple_asset_skip_empty', async () => {
    await simple_asset_skip_empty.simple_asset_skip_empty.deploy({ as: alice })

    const my_asset = await simple_asset_skip_empty.simple_asset_skip_empty.get_my_asset()
    assert(my_asset.length == 0)
  })

  it('simple_asset_skip_empty_one_field', async () => {
    await simple_asset_skip_empty_one_field.simple_asset_skip_empty_one_field.deploy({ as: alice })

    const my_asset = await simple_asset_skip_empty_one_field.simple_asset_skip_empty_one_field.get_my_asset()
    assert(my_asset.length == 0)
  })

  it('simple_asset_skip_one_field', async () => {
    await simple_asset_skip_one_field.simple_asset_skip_one_field.deploy({ as: alice })

    const my_asset = await simple_asset_skip_one_field.simple_asset_skip_one_field.get_my_asset()
    assert(my_asset.length == 3)
    assert(my_asset[0] == "id0")
    assert(my_asset[1] == "id1")
    assert(my_asset[2] == "id2")
  })

  it('simple_assign1', async () => {
    await simple_assign1.simple_assign1.deploy({ as: alice })

    const n_before = await simple_assign1.simple_assign1.get_n();
    assert(n_before.equals(new Nat(0)), "Invalid Value")

    await simple_assign1.simple_assign1.exec({ as: alice })

    const n_after = await simple_assign1.simple_assign1.get_n();
    assert(n_after.equals(new Nat(1)), "Invalid Value")
  })

  it('simple_assign2', async () => {
    await simple_assign2.simple_assign2.deploy({ as: alice })

    const n_before = await simple_assign2.simple_assign2.get_n()
    assert(n_before.equals(new Nat(0)))
    const s_before = await simple_assign2.simple_assign2.get_s()
    assert(s_before == "")

    await simple_assign2.simple_assign2.exec({ as: alice })

    const n_after = await simple_assign2.simple_assign2.get_n()
    assert(n_after.equals(new Nat(3)))
    const s_after = await simple_assign2.simple_assign2.get_s()
    assert(s_after == "ab")
  })

  it('simple_assign3', async () => {
    await simple_assign3.simple_assign3.deploy({ as: alice })

    const i_before = await simple_assign3.simple_assign3.get_i()
    assert(i_before.equals(new Int(0)))
    const n_before = await simple_assign3.simple_assign3.get_n()
    assert(n_before.equals(new Nat(0)))
    const s_before = await simple_assign3.simple_assign3.get_s()
    assert(s_before == "")

    await simple_assign3.simple_assign3.exec({ as: alice })

    const i_after = await simple_assign3.simple_assign3.get_i()
    assert(i_after.equals(new Int(4)))
    const n_after = await simple_assign3.simple_assign3.get_n()
    assert(n_after.equals(new Nat(3)))
    const s_after = await simple_assign3.simple_assign3.get_s()
    assert(s_after == "ab")
  })

  it('simple_contract_call', async () => {
    await simple_contract_call.simple_contract_call.deploy({ amount: new Tez(2), as: alice })

    const res_before = await simple_contract_call.simple_contract_call.get_res()
    assert(res_before == "")

    await simple_contract_call.simple_contract_call.exec(simple_contract_call.simple_contract_call.get_address(), { as: alice })

    const res_after = await simple_contract_call.simple_contract_call.get_res()
    assert(res_after == "mystr")
  })

  it('simple_freeze', async () => {
    await simple_freeze.simple_freeze.deploy({ as: alice })

    const res_before = await simple_freeze.simple_freeze.get_res()
    assert(res_before.equals(new Nat(0)))

    await simple_freeze.simple_freeze.exec(new Nat(2), { as: alice })

    const res_after = await simple_freeze.simple_freeze.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('simple_fun1', async () => {
    await simple_fun1.simple_fun1.deploy({ as: alice })

    const res_before = await simple_fun1.simple_fun1.get_res()
    assert(res_before.equals(new Int(-1)))

    await simple_fun1.simple_fun1.exec({ as: alice })

    const res_after = await simple_fun1.simple_fun1.get_res()
    assert(res_after.equals(new Int(0)))
  })

  it('simple_fun2', async () => {
    await simple_fun2.simple_fun2.deploy({ as: alice })

    const res_before = await simple_fun2.simple_fun2.get_res()
    assert(res_before.equals(new Int(-1)))

    await simple_fun2.simple_fun2.exec({ as: alice })

    const res_after = await simple_fun2.simple_fun2.get_res()
    assert(res_after.equals(new Int(0)))
  })

  it('simple_fun3', async () => {
    await simple_fun3.simple_fun3.deploy({ as: alice })

    const res_before = await simple_fun3.simple_fun3.get_res()
    assert(res_before.equals(new Int(0)))

    await simple_fun3.simple_fun3.exec({ as: alice })

    const res_after = await simple_fun3.simple_fun3.get_res()
    assert(res_after.equals(new Int(6)))
  })

  it('simple_fun4', async () => {
    await simple_fun4.simple_fun4.deploy({ as: alice })

    const res_before = await simple_fun4.simple_fun4.get_res()
    assert(res_before.equals(new Int(0)))

    await simple_fun4.simple_fun4.exec({ as: alice })

    const res_after = await simple_fun4.simple_fun4.get_res()
    assert(res_after.equals(new Int(11)))
  })

  it('simple_fun5', async () => {
    await simple_fun5.simple_fun5.deploy({ as: alice })

    const res_before = await simple_fun5.simple_fun5.get_res()
    assert(res_before.equals(new Int(-1)))

    await simple_fun5.simple_fun5.exec({ as: alice })

    const res_0 = await simple_fun5.simple_fun5.get_res()
    assert(res_0.equals(new Int(0)))

    await simple_fun5.simple_fun5.exec1({ as: alice })

    const res_1 = await simple_fun5.simple_fun5.get_res()
    assert(res_1.equals(new Int(1)))
  })

  it('simple_fun6', async () => {
    await simple_fun6.simple_fun6.deploy({ as: alice })

    const res_before = await simple_fun6.simple_fun6.get_res()
    assert(res_before.equals(new Int(-1)))

    await simple_fun6.simple_fun6.exec({ as: alice })

    const res_0 = await simple_fun6.simple_fun6.get_res()
    assert(res_0.equals(new Int(0)))

    await simple_fun6.simple_fun6.exec1({ as: alice })

    const res_1 = await simple_fun6.simple_fun6.get_res()
    assert(res_1.equals(new Int(1)))

    await simple_fun6.simple_fun6.exec2({ as: alice })

    const res_2 = await simple_fun6.simple_fun6.get_res()
    assert(res_2.equals(new Int(2)))
  })

  it('simple_fun7', async () => {
    await simple_fun7.simple_fun7.deploy({ as: alice })

    const res_before = await simple_fun7.simple_fun7.get_res()
    assert(res_before.equals(new Int(0)))
    const n_before = await simple_fun7.simple_fun7.get_n()
    assert(n_before.equals(new Nat(1)))

    await simple_fun7.simple_fun7.exec({ as: alice })

    const res_after = await simple_fun7.simple_fun7.get_res()
    assert(res_after.equals(new Int(2)))
    const n_after = await simple_fun7.simple_fun7.get_n()
    assert(n_after.equals(new Nat(1)))
  })

  it('simple_fun8', async () => {
    await simple_fun8.simple_fun8.deploy({ as: alice })

    const res_before = await simple_fun8.simple_fun8.get_res()
    assert(res_before.equals(new Int(0)))
    const n_before = await simple_fun8.simple_fun8.get_n()
    assert(n_before.equals(new Nat(1)))

    await simple_fun8.simple_fun8.exec({ as: alice })

    const res_after = await simple_fun8.simple_fun8.get_res()
    assert(res_after.equals(new Int(1)))
    const n_after = await simple_fun8.simple_fun8.get_n()
    assert(n_after.equals(new Nat(1)))
  })

  it('simple_fun_alt', async () => {
    await simple_fun_alt.simple_fun_alt.deploy({ as: alice })

    await simple_fun_alt.simple_fun_alt.exec({ as: alice })
  })

  it('simple_fun_with_storage', async () => {
    await simple_fun_with_storage.simple_fun_with_storage.deploy({ as: alice })

    const res_before = await simple_fun_with_storage.simple_fun_with_storage.get_res()
    assert(res_before.equals(new Int(0)))

    await simple_fun_with_storage.simple_fun_with_storage.exec({ as: alice })

    const res_after = await simple_fun_with_storage.simple_fun_with_storage.get_res()
    assert(res_after.equals(new Int(1)))
  })

  it('simple_fun_with_storage2', async () => {
    await simple_fun_with_storage2.simple_fun_with_storage2.deploy({ as: alice })

    const res_before = await simple_fun_with_storage2.simple_fun_with_storage2.get_res()
    assert(res_before.equals(new Int(0)))
    const n_before = await simple_fun_with_storage2.simple_fun_with_storage2.get_n()
    assert(n_before.equals(new Nat(1)))

    await simple_fun_with_storage2.simple_fun_with_storage2.exec({ as: alice })

    const res_after = await simple_fun_with_storage2.simple_fun_with_storage2.get_res()
    assert(res_after.equals(new Int(3)))
    const n_after = await simple_fun_with_storage2.simple_fun_with_storage2.get_n()
    assert(n_after.equals(new Nat(1)))
  })

  it('simple_fun_with_storage3', async () => {
    await simple_fun_with_storage3.simple_fun_with_storage3.deploy({ as: alice })

    const res_before = await simple_fun_with_storage3.simple_fun_with_storage3.get_res()
    assert(res_before.equals(new Int(0)))
    const n_before = await simple_fun_with_storage3.simple_fun_with_storage3.get_n()
    assert(n_before.equals(new Nat(1)))

    await simple_fun_with_storage3.simple_fun_with_storage3.exec({ as: alice })

    const res_after = await simple_fun_with_storage3.simple_fun_with_storage3.get_res()
    assert(res_after.equals(new Int(5)))
    const n_after = await simple_fun_with_storage3.simple_fun_with_storage3.get_n()
    assert(n_after.equals(new Nat(1)))
  })

  it('simple_get_field', async () => {
    await simple_get_field.simple_get_field.deploy({ as: alice })

    const my_asset_before = await simple_get_field.simple_get_field.get_my_asset();
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Int(0)))
    assert(my_asset_before[0][1] == "str")
    const res_before = await simple_get_field.simple_get_field.get_res()
    assert(res_before == "")

    await simple_get_field.simple_get_field.exec({ as: alice })

    const my_asset_after = await simple_get_field.simple_get_field.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Int(0)))
    assert(my_asset_after[0][1] == "str")
    const res_after = await simple_get_field.simple_get_field.get_res()
    assert(res_after == "str")
  })

  it('simple_if3', async () => {
    await simple_if3.simple_if3.deploy({ as: alice })

    const str_before = await simple_if3.simple_if3.get_str()
    assert(str_before == "")
    const n_before = await simple_if3.simple_if3.get_n()
    assert(n_before.equals(new Nat(0)))
    const i_before = await simple_if3.simple_if3.get_i()
    assert(i_before.equals(new Int(0)))

    await simple_if3.simple_if3.exec(new Int(0), { as: alice })

    const str_0 = await simple_if3.simple_if3.get_str()
    assert(str_0 == "mystr")
    const n_0 = await simple_if3.simple_if3.get_n()
    assert(n_0.equals(new Nat(0)))
    const i_0 = await simple_if3.simple_if3.get_i()
    assert(i_0.equals(new Int(1)))

    await simple_if3.simple_if3.exec(new Int(1), { as: alice })

    const str_1 = await simple_if3.simple_if3.get_str()
    assert(str_1 == "mystr")
    const n_1 = await simple_if3.simple_if3.get_n()
    assert(n_1.equals(new Nat(4)))
    const i_1 = await simple_if3.simple_if3.get_i()
    assert(i_1.equals(new Int(1)))
  })

  it('simple_multi_entry', async () => {
    await simple_multi_entry.simple_multi_entry.deploy({ as: alice })

    const n_before = await simple_multi_entry.simple_multi_entry.get_n()
    assert(n_before.equals(new Nat(0)))

    await simple_multi_entry.simple_multi_entry.e1({ as: alice })

    const n_e1 = await simple_multi_entry.simple_multi_entry.get_n()
    assert(n_e1.equals(new Nat(1)))

    await simple_multi_entry.simple_multi_entry.e2({ as: alice })

    const n_e2 = await simple_multi_entry.simple_multi_entry.get_n()
    assert(n_e2.equals(new Nat(2)))
  })

  it('simple_multi_entry2', async () => {
    await simple_multi_entry2.simple_multi_entry2.deploy({ as: alice })

    const n_before = await simple_multi_entry2.simple_multi_entry2.get_n()
    assert(n_before.equals(new Nat(0)))

    await simple_multi_entry2.simple_multi_entry2.e1(new Nat(1), { as: alice })

    const n_e1 = await simple_multi_entry2.simple_multi_entry2.get_n()
    assert(n_e1.equals(new Nat(1)))

    await simple_multi_entry2.simple_multi_entry2.e2(new Nat(1), new Nat(1), { as: alice })

    const n_e2 = await simple_multi_entry2.simple_multi_entry2.get_n()
    assert(n_e2.equals(new Nat(2)))

    await simple_multi_entry2.simple_multi_entry2.e3({ as: alice })

    const n_e3 = await simple_multi_entry2.simple_multi_entry2.get_n()
    assert(n_e3.equals(new Nat(0)))
  })

  it('simple_multi_entry3', async () => {
    await simple_multi_entry3.simple_multi_entry3.deploy({ as: alice })

    const str_before = await simple_multi_entry3.simple_multi_entry3.get_str()
    assert(str_before == "")
    const n_before = await simple_multi_entry3.simple_multi_entry3.get_n()
    assert(n_before.equals(new Nat(0)))
    const i_before = await simple_multi_entry3.simple_multi_entry3.get_i()
    assert(i_before.equals(new Int(0)))

    await simple_multi_entry3.simple_multi_entry3.e1(new Nat(1), { as: alice })

    const str_e1 = await simple_multi_entry3.simple_multi_entry3.get_str()
    assert(str_e1 == "")
    const n_e1 = await simple_multi_entry3.simple_multi_entry3.get_n()
    assert(n_e1.equals(new Nat(3)))
    const i_e1 = await simple_multi_entry3.simple_multi_entry3.get_i()
    assert(i_e1.equals(new Int(1)))

    await simple_multi_entry3.simple_multi_entry3.e2(new Nat(1), new Nat(1), { as: alice })

    const str_e2 = await simple_multi_entry3.simple_multi_entry3.get_str()
    assert(str_e2 == "mystring")
    const n_e2 = await simple_multi_entry3.simple_multi_entry3.get_n()
    assert(n_e2.equals(new Nat(2)))
    const i_e2 = await simple_multi_entry3.simple_multi_entry3.get_i()
    assert(i_e2.equals(new Int(7)))

    await simple_multi_entry3.simple_multi_entry3.e3({ as: alice })

    const str_e3 = await simple_multi_entry3.simple_multi_entry3.get_str()
    assert(str_e3 == "mystring")
    const n_e3 = await simple_multi_entry3.simple_multi_entry3.get_n()
    assert(n_e3.equals(new Nat(5)))
    const i_e3 = await simple_multi_entry3.simple_multi_entry3.get_i()
    assert(i_e3.equals(new Int(7)))
  })

  it('simple_op_add', async () => {
    await simple_op_add.simple_op_add.deploy({ as: alice })

    const res_before = await simple_op_add.simple_op_add.get_res()
    assert(res_before.equals(new Nat(0)))

    await simple_op_add.simple_op_add.exec({ as: alice })

    const res_after = await simple_op_add.simple_op_add.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('simple_op_uminus', async () => {
    await simple_op_uminus.simple_op_uminus.deploy({ as: alice })

    const res_before = await simple_op_uminus.simple_op_uminus.get_res()
    assert(res_before.equals(new Int(0)))

    await simple_op_uminus.simple_op_uminus.exec({ as: alice })

    const res_after = await simple_op_uminus.simple_op_uminus.get_res()
    assert(res_after.equals(new Int(-1)))
  })

  it('simple_param', async () => {
    await simple_param.simple_param.deploy(new Nat(0), { as: alice })

    const res_before = await simple_param.simple_param.get_res()
    assert(res_before.equals(new Nat(0)))

    await simple_param.simple_param.exec(new Nat(2), { as: alice })

    const res_after = await simple_param.simple_param.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('simple_param_const', async () => {
    await simple_param_const.simple_param_const.deploy(new Nat(2), { as: alice })

    const res_before = await simple_param_const.simple_param_const.get_res()
    assert(res_before.equals(new Nat(0)))

    await simple_param_const.simple_param_const.exec({ as: alice })

    const res_after = await simple_param_const.simple_param_const.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('simple_param_with_default', async () => {
    await simple_param_with_default.simple_param_with_default.deploy(new Nat(0), "", { as: alice })
    // TODO
    const res_before = await simple_param_with_default.simple_param_with_default.get_res()
    assert(res_before.equals(new Nat(0)))
    const str_before = await simple_param_with_default.simple_param_with_default.get_str()
    assert(str_before == "")

    await simple_param_with_default.simple_param_with_default.exec(new Nat(2), { as: alice })

    const res_after = await simple_param_with_default.simple_param_with_default.get_res()
    assert(res_after.equals(new Nat(2)))
    const str_after = await simple_param_with_default.simple_param_with_default.get_str()
    assert(str_after == "")
  })

  it('simple_record_assign', async () => {
    await simple_record_assign.simple_record_assign.deploy({ as: alice })

    const r_before = await simple_record_assign.simple_record_assign.get_r()
    assert(r_before.equals(new simple_record_assign.my_record("id", new Nat(0))))

    await simple_record_assign.simple_record_assign.exec({ as: alice })

    const r_after = await simple_record_assign.simple_record_assign.get_r()
    assert(r_after.equals(new simple_record_assign.my_record("id", new Nat(1))))
  })

  it('simple_record_assign1', async () => {
    await simple_record_assign1.simple_record_assign1.deploy({ as: alice })

    const r_before = await simple_record_assign1.simple_record_assign1.get_r()
    assert(r_before.equals(new simple_record_assign1.my_record(new Nat(0))))

    await simple_record_assign1.simple_record_assign1.exec({ as: alice })

    const r_after = await simple_record_assign1.simple_record_assign1.get_r()
    assert(r_after.equals(new simple_record_assign1.my_record(new Nat(1))))
  })

  it('simple_record_assign2', async () => {
    await simple_record_assign2.simple_record_assign2.deploy({ as: alice })

    const p_before = await simple_record_assign2.simple_record_assign2.get_p()
    assert(p_before.equals(new Nat(0)))
    const r_before = await simple_record_assign2.simple_record_assign2.get_r()
    assert(r_before.equals(new simple_record_assign2.my_record("id", new Nat(0), new Nat(0), new Nat(0))))
    const q_before = await simple_record_assign2.simple_record_assign2.get_q()
    assert(q_before.equals(new Nat(0)))

    await simple_record_assign2.simple_record_assign2.exec({ as: alice })

    const p_after = await simple_record_assign2.simple_record_assign2.get_p()
    assert(p_after.equals(new Nat(0)))
    const r_after = await simple_record_assign2.simple_record_assign2.get_r()
    assert(r_after.equals(new simple_record_assign2.my_record("id", new Nat(0), new Nat(0), new Nat(1))))
    const q_after = await simple_record_assign2.simple_record_assign2.get_q()
    assert(q_after.equals(new Nat(0)))
  })

  it('simple_record_lit', async () => {
    await simple_record_lit.simple_record_lit.deploy({ as: alice })

    await simple_record_lit.simple_record_lit.exec({ as: alice })
  })

  it('simple_record_lit_rev', async () => {
    await simple_record_lit_rev.simple_record_lit_rev.deploy({ as: alice })

    await simple_record_lit_rev.simple_record_lit_rev.exec({ as: alice })
  })

  it('simple_reverse', async () => {
    await simple_reverse.simple_reverse.deploy({ as: alice })

    const res_before = await simple_reverse.simple_reverse.get_res()
    assert(res_before.length == 0)

    await simple_reverse.simple_reverse.exec({ as: alice })

    const res_after = await simple_reverse.simple_reverse.get_res()
    assert(res_after.length == 3)
    assert(res_after[0] == "i2")
    assert(res_after[1] == "i1")
    assert(res_after[2] == "i0")
  })

  it('simple_sequence', async () => {
    await simple_sequence.simple_sequence.deploy({ as: alice })

    const str_before = await simple_sequence.simple_sequence.get_str()
    assert(str_before == "")
    const n_before = await simple_sequence.simple_sequence.get_n()
    assert(n_before.equals(new Nat(0)))
    const i_before = await simple_sequence.simple_sequence.get_i()
    assert(i_before.equals(new Int(0)))

    await simple_sequence.simple_sequence.exec({ as: alice })

    const str_after = await simple_sequence.simple_sequence.get_str()
    assert(str_after == "mystring")
    const n_after = await simple_sequence.simple_sequence.get_n()
    assert(n_after.equals(new Nat(5)))
    const i_after = await simple_sequence.simple_sequence.get_i()
    assert(i_after.equals(new Int(0)))
  })

  it('simple_sequence_with_arg', async () => {
    await simple_sequence_with_arg.simple_sequence_with_arg.deploy({ as: alice })

    const str_before = await simple_sequence_with_arg.simple_sequence_with_arg.get_str()
    assert(str_before == "")
    const n_before = await simple_sequence_with_arg.simple_sequence_with_arg.get_n()
    assert(n_before.equals(new Nat(0)))
    const i_before = await simple_sequence_with_arg.simple_sequence_with_arg.get_i()
    assert(i_before.equals(new Int(0)))

    await simple_sequence_with_arg.simple_sequence_with_arg.exec(new Nat(2), { as: alice })

    const str_after = await simple_sequence_with_arg.simple_sequence_with_arg.get_str()
    assert(str_after == "mystring")
    const n_after = await simple_sequence_with_arg.simple_sequence_with_arg.get_n()
    assert(n_after.equals(new Nat(4)))
    const i_after = await simple_sequence_with_arg.simple_sequence_with_arg.get_i()
    assert(i_after.equals(new Int(0)))
  })

  it('simple_sequence_with_arg2', async () => {
    await simple_sequence_with_arg2.simple_sequence_with_arg2.deploy({ as: alice })

    const str_before = await simple_sequence_with_arg2.simple_sequence_with_arg2.get_str()
    assert(str_before == "")
    const n_before = await simple_sequence_with_arg2.simple_sequence_with_arg2.get_n()
    assert(n_before.equals(new Nat(0)))

    await simple_sequence_with_arg2.simple_sequence_with_arg2.exec(new Nat(2), new Nat(2), { as: alice })

    const str_after = await simple_sequence_with_arg2.simple_sequence_with_arg2.get_str()
    assert(str_after == "mystring")
    const n_after = await simple_sequence_with_arg2.simple_sequence_with_arg2.get_n()
    assert(n_after.equals(new Nat(7)))
  })

  it('simple_sequence_with_arg_var', async () => {
    await simple_sequence_with_arg_var.simple_sequence_with_arg_var.deploy({ as: alice })

    const str_before = await simple_sequence_with_arg_var.simple_sequence_with_arg_var.get_str()
    assert(str_before == "")
    const n_before = await simple_sequence_with_arg_var.simple_sequence_with_arg_var.get_n()
    assert(n_before.equals(new Nat(0)))

    await simple_sequence_with_arg_var.simple_sequence_with_arg_var.exec(new Nat(2), { as: alice })

    const str_after = await simple_sequence_with_arg_var.simple_sequence_with_arg_var.get_str()
    assert(str_after == "mystring")
    const n_after = await simple_sequence_with_arg_var.simple_sequence_with_arg_var.get_n()
    assert(n_after.equals(new Nat(7)))
  })

  it('simple_string', async () => {
    await simple_string.simple_string.deploy({ as: alice })

    const res_before = await simple_string.simple_string.get_res()
    assert(res_before == "")

    await simple_string.simple_string.exec("mystr", { as: alice })

    const res_after = await simple_string.simple_string.get_res()
    assert(res_after == "mystr")
  })

  it('simple_while', async () => {
    await simple_while.simple_while.deploy({ as: alice })

    const res_before = await simple_while.simple_while.get_res()
    assert(res_before == false)

    await simple_while.simple_while.exec({ as: alice })

    const res_after = await simple_while.simple_while.get_res()
    assert(res_after == true)
  })

  it('simple_with_arg_view', async () => {
    await simple_with_arg_view.simple_with_arg_view.deploy({ as: alice })

    const n_before = await simple_with_arg_view.simple_with_arg_view.get_n()
    assert(n_before.equals(new Nat(0)))

    const n_getter_before = await simple_with_arg_view.simple_with_arg_view.getValue({ as: alice })
    assert(n_getter_before.equals(new Nat(0)))

    await simple_with_arg_view.simple_with_arg_view.assign(new Nat(2), { as: alice })

    const n_after = await simple_with_arg_view.simple_with_arg_view.get_n()
    assert(n_after.equals(new Nat(2)))

    const n_getter_after = await simple_with_arg_view.simple_with_arg_view.getValue({ as: alice })
    assert(n_getter_after.equals(new Nat(2)))
  })

  it('simple_with_type_annot', async () => {
    await simple_with_type_annot.simple_with_type_annot.deploy({ as: alice })

    const k_before = await simple_with_type_annot.simple_with_type_annot.get_k()
    assert(k_before.equals(new Nat(0)))

    await simple_with_type_annot.simple_with_type_annot.exec(new Nat(2), { as: alice })

    const k_after = await simple_with_type_annot.simple_with_type_annot.get_k()
    assert(k_after.equals(new Nat(2)))
  })

  it('simple_with_view', async () => {
    await simple_with_view.simple_with_view.deploy({ as: alice })

    const n_before = await simple_with_view.simple_with_view.get_n()
    assert(n_before.equals(new Nat(0)))

    const n_getter_before = await simple_with_view.simple_with_view.getValue({ as: alice })
    assert(n_getter_before.equals(new Nat(0)))

    await simple_with_view.simple_with_view.assign({ as: alice })

    const n_after = await simple_with_view.simple_with_view.get_n()
    assert(n_after.equals(new Nat(2)))

    const n_getter_after = await simple_with_view.simple_with_view.getValue({ as: alice })
    assert(n_getter_after.equals(new Nat(2)))
  })

  it('sourced_by', async () => {
    await sourced_by.sourced_by.deploy({ as: alice })

    const my_asset_before = await sourced_by.sourced_by.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(alice.get_address()))
    assert(my_asset_before[0][1] == "")

    await sourced_by.sourced_by.e0({ as: alice })
    await expect_to_fail(async () => {
      await sourced_by.sourced_by.e0({ as: bob })
    }, { string: "INVALID_SOURCE" })

    const my_asset_e0 = await sourced_by.sourced_by.get_my_asset()
    assert(my_asset_e0.length == 1)
    assert(my_asset_e0[0][0].equals(alice.get_address()))
    assert(my_asset_e0[0][1] == "")

    await sourced_by.sourced_by.e1({ as: alice })
    await expect_to_fail(async () => {
      await sourced_by.sourced_by.e1({ as: bob })
    }, { string: "INVALID_SOURCE" })

    const my_asset_e1 = await sourced_by.sourced_by.get_my_asset()
    assert(my_asset_e1.length == 1)
    assert(my_asset_e1[0][0].equals(alice.get_address()))
    assert(my_asset_e1[0][1] == "")

    await sourced_by.sourced_by.e2({ as: alice })
    await expect_to_fail(async () => {
      await sourced_by.sourced_by.e2({ as: bob })
    }, { string: "INVALID_SOURCE" })

    const my_asset_e2 = await sourced_by.sourced_by.get_my_asset()
    assert(my_asset_e2.length == 1)
    assert(my_asset_e2[0][0].equals(alice.get_address()))
    assert(my_asset_e2[0][1] == "")
  })

  it('state_in_effect', async () => {
    await state_in_effect.state_in_effect.deploy({ as: alice })

    const state_before = await state_in_effect.state_in_effect.get_state()
    assert(state_before == state_in_effect.states.S1)
    const res_before = await state_in_effect.state_in_effect.get_res()
    assert(res_before.equals(new Int(-1)))

    await state_in_effect.state_in_effect.exec({ as: alice })

    const state_after = await state_in_effect.state_in_effect.get_state()
    assert(state_after == state_in_effect.states.S1)
    const res_after = await state_in_effect.state_in_effect.get_res()
    assert(res_after.equals(new Int(0)))
  })

  it('state_is', async () => {
    await state_is.state_is.deploy({ as: alice })

    const state_before = await state_is.state_is.get_state()
    assert(state_before == state_is.states.Init)

    await expect_to_fail(async () => {
      await state_is.state_is.exec({ as: alice })
    }, { string: "INVALID_STATE" })

    await state_is.state_is.tr({ as: alice })

    const state_0 = await state_is.state_is.get_state()
    assert(state_0 == state_is.states.Running)

    await state_is.state_is.exec({ as: alice })

    const state_after = await state_is.state_is.get_state()
    assert(state_after == state_is.states.Running)
  })

  it('state_var', async () => {
    await state_var.state_var.deploy({ as: alice })

    await state_var.state_var.exec({ as: alice })
  })

  it('tern_bool_false', async () => {
    await tern_bool_false.tern_bool_false.deploy({ as: alice })

    const res_before = await tern_bool_false.tern_bool_false.get_res()
    assert(res_before.equals(new Nat(0)))

    await tern_bool_false.tern_bool_false.exec({ as: alice })

    const res_after = await tern_bool_false.tern_bool_false.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('tern_bool_true', async () => {
    await tern_bool_true.tern_bool_true.deploy({ as: alice })

    const res_before = await tern_bool_true.tern_bool_true.get_res()
    assert(res_before.equals(new Nat(0)))

    await tern_bool_true.tern_bool_true.exec({ as: alice })

    const res_after = await tern_bool_true.tern_bool_true.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('tern_opt', async () => {
    await tern_opt.tern_opt.deploy({ as: alice })

    const res_before = await tern_opt.tern_opt.get_res()
    assert(res_before.equals(new Nat(0)))

    await tern_opt.tern_opt.exec({ as: alice })

    const res_after = await tern_opt.tern_opt.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('tern_opt_3', async () => {
    await tern_opt_3.tern_opt_3.deploy({ as: alice })

    const res_before = await tern_opt_3.tern_opt_3.get_res()
    assert(res_before.equals(new Nat(0)))

    await tern_opt_3.tern_opt_3.exec({ as: alice })

    const res_after = await tern_opt_3.tern_opt_3.get_res()
    assert(res_after.equals(new Nat(5)))
  })

  it('test_add_asset2_with_partition', async () => {
    await test_add_asset2_with_partition.test_add_asset2_with_partition.deploy({ as: alice })

    const my_asset_before = await test_add_asset2_with_partition.test_add_asset2_with_partition.get_my_asset()
    assert(my_asset_before.length == 0)
    const o_asset_before = await test_add_asset2_with_partition.test_add_asset2_with_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_add_asset2_with_partition.test_add_asset2_with_partition.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_add_asset2_with_partition.test_add_asset2_with_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id3")
    assert(my_asset_after[0][1].p.length == 1)
    assert(my_asset_after[0][1].p[0].equals(new Nat(2)))
    assert(my_asset_after[0][1].v == true)
    const o_asset_after = await test_add_asset2_with_partition.test_add_asset2_with_partition.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0].equals(new Nat(2)))
  })

  it('test_add_asset_with_aggregate', async () => {
    await test_add_asset_with_aggregate.test_add_asset_with_aggregate.deploy({ as: alice })

    const my_asset_before = await test_add_asset_with_aggregate.test_add_asset_with_aggregate.get_my_asset()
    assert(my_asset_before.length == 0)
    const o_asset_before = await test_add_asset_with_aggregate.test_add_asset_with_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(1)))
    assert(o_asset_before[1].equals(new Nat(2)))
    assert(o_asset_before[2].equals(new Nat(3)))

    await expect_to_fail(async () => {
      await test_add_asset_with_aggregate.test_add_asset_with_aggregate.exec(new Nat(0), { as: alice })
    }, { string: "NOT_FOUND" })

    await test_add_asset_with_aggregate.test_add_asset_with_aggregate.exec(new Nat(1), { as: alice })

    const my_asset_after = await test_add_asset_with_aggregate.test_add_asset_with_aggregate.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id3")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    const o_asset_after = await test_add_asset_with_aggregate.test_add_asset_with_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(1)))
    assert(o_asset_after[1].equals(new Nat(2)))
    assert(o_asset_after[2].equals(new Nat(3)))
  })

  it('test_add_asset_with_both', async () => {
    await test_add_asset_with_both.test_add_asset_with_both.deploy({ as: alice })

    const my_asset_before = await test_add_asset_with_both.test_add_asset_with_both.get_my_asset()
    assert(my_asset_before.length == 0)
    const o_asset_before = await test_add_asset_with_both.test_add_asset_with_both.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(1)))
    assert(o_asset_before[1].equals(new Nat(2)))
    assert(o_asset_before[2].equals(new Nat(3)))
    const p_asset_before = await test_add_asset_with_both.test_add_asset_with_both.get_p_asset()
    assert(p_asset_before.length == 0)

    await test_add_asset_with_both.test_add_asset_with_both.exec(new Nat(1), new Int(2), { as: alice })

    const my_asset_after = await test_add_asset_with_both.test_add_asset_with_both.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id3")
    assert(my_asset_after[0][1].a.length == 1)
    assert(my_asset_after[0][1].a[0].equals(new Nat(1)))
    assert(my_asset_after[0][1].p.length == 1)
    assert(my_asset_after[0][1].p[0].equals(new Int(2)))
    const o_asset_after = await test_add_asset_with_both.test_add_asset_with_both.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(1)))
    assert(o_asset_after[1].equals(new Nat(2)))
    assert(o_asset_after[2].equals(new Nat(3)))
    const p_asset_after = await test_add_asset_with_both.test_add_asset_with_both.get_p_asset()
    assert(p_asset_after.length == 1)
    assert(p_asset_after[0].equals(new Int(2)))
  })

  it('test_add_asset_with_partition', async () => {
    await test_add_asset_with_partition.test_add_asset_with_partition.deploy({ as: alice })

    const my_asset_before = await test_add_asset_with_partition.test_add_asset_with_partition.get_my_asset()
    assert(my_asset_before.length == 0)
    const o_asset_before = await test_add_asset_with_partition.test_add_asset_with_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_add_asset_with_partition.test_add_asset_with_partition.exec(new Nat(1), { as: alice })

    const my_asset_after = await test_add_asset_with_partition.test_add_asset_with_partition.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id3")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    const o_asset_after = await test_add_asset_with_partition.test_add_asset_with_partition.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0].equals(new Nat(1)))
  })

  it('test_addfield_aggregate_1', async () => {
    await test_addfield_aggregate_1.test_addfield_aggregate_1.deploy({ as: alice })

    const my_asset_before = await test_addfield_aggregate_1.test_addfield_aggregate_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_addfield_aggregate_1.test_addfield_aggregate_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await expect_to_fail(async () => {
      await test_addfield_aggregate_1.test_addfield_aggregate_1.exec(new Nat(3), { as: alice })
    }, { string: "NOT_FOUND" })

    await test_addfield_aggregate_1.test_addfield_aggregate_1.exec(new Nat(0), { as: alice })

    const my_asset_after = await test_addfield_aggregate_1.test_addfield_aggregate_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_addfield_aggregate_1.test_addfield_aggregate_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('test_addfield_aggregate_2', async () => {
    await test_addfield_aggregate_2.test_addfield_aggregate_2.deploy({ as: alice })

    const my_asset_before = await test_addfield_aggregate_2.test_addfield_aggregate_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].col.length == 0)
    assert(my_asset_before[0][1].val.equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[1][1].val.equals(new Nat(0)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].col.length == 0)
    assert(my_asset_before[2][1].val.equals(new Nat(0)))
    const o_asset_before = await test_addfield_aggregate_2.test_addfield_aggregate_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await expect_to_fail(async () => {
      await test_addfield_aggregate_2.test_addfield_aggregate_2.exec(new Nat(3), { as: alice })
    }, { string: "NOT_FOUND" })

    await test_addfield_aggregate_2.test_addfield_aggregate_2.exec(new Nat(0), { as: alice })

    const my_asset_after = await test_addfield_aggregate_2.test_addfield_aggregate_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].col.length == 1)
    assert(my_asset_after[0][1].col[0].equals(new Nat(0)))
    assert(my_asset_after[0][1].val.equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[1][1].val.equals(new Nat(0)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].col.length == 0)
    assert(my_asset_after[2][1].val.equals(new Nat(0)))
    const o_asset_after = await test_addfield_aggregate_2.test_addfield_aggregate_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('test_addfield_partition_1', async () => {
    await test_addfield_partition_1.test_addfield_partition_1.deploy({ as: alice })

    const my_asset_before = await test_addfield_partition_1.test_addfield_partition_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_addfield_partition_1.test_addfield_partition_1.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_addfield_partition_1.test_addfield_partition_1.exec("mystr", { as: alice })

    const my_asset_after = await test_addfield_partition_1.test_addfield_partition_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0] == "mystr")
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_addfield_partition_1.test_addfield_partition_1.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0] == "mystr")
  })

  it('test_addfield_partition_2', async () => {
    await test_addfield_partition_2.test_addfield_partition_2.deploy({ as: alice })

    const my_asset_before = await test_addfield_partition_2.test_addfield_partition_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].col.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].col.length == 0)
    const o_asset_before = await test_addfield_partition_2.test_addfield_partition_2.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_addfield_partition_2.test_addfield_partition_2.exec("mystr", { as: alice })

    const my_asset_after = await test_addfield_partition_2.test_addfield_partition_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].col.length == 1)
    assert(my_asset_after[0][1].col[0] == "mystr")
    assert(my_asset_after[0][1].col.length == 1)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await test_addfield_partition_2.test_addfield_partition_2.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0] == "mystr")
  })

  it('test_addupdate_0', async () => {
    await test_addupdate_0.test_addupdate_0.deploy({ as: alice })

    const my_asset_before = await test_addupdate_0.test_addupdate_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v.equals(new Nat(0)))
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v.equals(new Nat(0)))
    assert(my_asset_before[1][1].value.equals(new Int(0)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v.equals(new Nat(0)))
    assert(my_asset_before[2][1].value.equals(new Int(0)))

    await test_addupdate_0.test_addupdate_0.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_addupdate_0.test_addupdate_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v.equals(new Nat(0)))
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v.equals(new Nat(0)))
    assert(my_asset_after[1][1].value.equals(new Int(0)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v.equals(new Nat(2)))
    assert(my_asset_after[2][1].value.equals(new Int(0)))
  })

  it('test_addupdate_1', async () => {
    await test_addupdate_1.test_addupdate_1.deploy({ as: alice })

    const my_asset_before = await test_addupdate_1.test_addupdate_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(0)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(0)))

    await test_addupdate_1.test_addupdate_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_addupdate_1.test_addupdate_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(0)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
  })

  it('test_addupdate_2', async () => {
    await test_addupdate_2.test_addupdate_2.deploy({ as: alice })

    const my_asset_before = await test_addupdate_2.test_addupdate_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(1)))
    assert(my_asset_before[0][1].v1.equals(new Int(1)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].v1.equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(1)))
    assert(my_asset_before[2][1].v1.equals(new Int(1)))

    await test_addupdate_2.test_addupdate_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_addupdate_2.test_addupdate_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(1)))
    assert(my_asset_after[0][1].v1.equals(new Int(1)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].v1.equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(3)))
    assert(my_asset_after[2][1].v1.equals(new Int(0)))
  })

  it('test_asset', async () => {
    await test_asset.test_asset.deploy({ as: alice })

    const my_asset_simple_before = await test_asset.test_asset.get_my_asset_simple()
    assert(my_asset_simple_before.length == 0)
    const my_asset_before = await test_asset.test_asset.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Int(0)))
    assert(my_asset_before[0][1].length == 0)
    const my_asset_all_before = await test_asset.test_asset.get_my_asset_all()
    assert(my_asset_all_before.length == 2)
    assert(my_asset_all_before[0][0].equals(new Address("tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg")))
    assert(my_asset_all_before[0][1].k.equals(new Int(4)))
    assert(my_asset_all_before[0][1].b == true)
    assert(my_asset_all_before[1][0].equals(new Address("tz1bfVgcJC4ukaQSHUe1EbrUd5SekXeP9CWk")))
    assert(my_asset_all_before[1][1].k.equals(new Int(8)))
    assert(my_asset_all_before[1][1].b == false)

    await test_asset.test_asset.exec({ as: alice })

    const my_asset_simple_after = await test_asset.test_asset.get_my_asset_simple()
    assert(my_asset_simple_after.length == 0)
    const my_asset_after = await test_asset.test_asset.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Int(0)))
    assert(my_asset_after[0][1].length == 0)
    const my_asset_all_after = await test_asset.test_asset.get_my_asset_all()
    assert(my_asset_all_after.length == 2)
    assert(my_asset_all_after[0][0].equals(new Address("tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg")))
    assert(my_asset_all_after[0][1].k.equals(new Int(4)))
    assert(my_asset_all_after[0][1].b == true)
    assert(my_asset_all_after[1][0].equals(new Address("tz1bfVgcJC4ukaQSHUe1EbrUd5SekXeP9CWk")))
    assert(my_asset_all_after[1][1].k.equals(new Int(8)))
    assert(my_asset_all_after[1][1].b == false)
  })

  it('test_asset_head_agg_0', async () => {
    await test_asset_head_agg_0.test_asset_head_agg_0.deploy({ as: alice })

    const my_asset_before = await test_asset_head_agg_0.test_asset_head_agg_0.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_head_agg_0.test_asset_head_agg_0.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_head_agg_0.test_asset_head_agg_0.get_res()
    assert(res_before.length == 0)

    await test_asset_head_agg_0.test_asset_head_agg_0.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_agg_0.test_asset_head_agg_0.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_head_agg_0.test_asset_head_agg_0.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_head_agg_0.test_asset_head_agg_0.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_head_agg_1', async () => {
    await test_asset_head_agg_1.test_asset_head_agg_1.deploy({ as: alice })

    const my_asset_before = await test_asset_head_agg_1.test_asset_head_agg_1.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_head_agg_1.test_asset_head_agg_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1] == "mystr0")
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1] == "mystr1")
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_head_agg_1.test_asset_head_agg_1.get_res()
    assert(res_before.length == 0)

    await test_asset_head_agg_1.test_asset_head_agg_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_agg_1.test_asset_head_agg_1.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_head_agg_1.test_asset_head_agg_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1] == "mystr0")
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1] == "mystr1")
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_head_agg_1.test_asset_head_agg_1.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_head_agg_2', async () => {
    await test_asset_head_agg_2.test_asset_head_agg_2.deploy({ as: alice })

    const my_asset_before = await test_asset_head_agg_2.test_asset_head_agg_2.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_head_agg_2.test_asset_head_agg_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1].s == "mystr0")
    assert(o_asset_before[0][1].b == true)
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1].s == "mystr1")
    assert(o_asset_before[1][1].b == true)
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1].s == "mystr2")
    assert(o_asset_before[2][1].b == true)
    const res_before = await test_asset_head_agg_2.test_asset_head_agg_2.get_res()
    assert(res_before.length == 0)

    await test_asset_head_agg_2.test_asset_head_agg_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_agg_2.test_asset_head_agg_2.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_head_agg_2.test_asset_head_agg_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1].s == "mystr0")
    assert(o_asset_after[0][1].b == true)
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1].s == "mystr1")
    assert(o_asset_after[1][1].b == true)
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1].s == "mystr2")
    assert(o_asset_after[2][1].b == true)
    const res_after = await test_asset_head_agg_2.test_asset_head_agg_2.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_head_coll_0', async () => {
    await test_asset_head_coll_0.test_asset_head_coll_0.deploy({ as: alice })

    const my_asset_before = await test_asset_head_coll_0.test_asset_head_coll_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_head_coll_0.test_asset_head_coll_0.get_res()
    assert(res_before.length == 0)

    await test_asset_head_coll_0.test_asset_head_coll_0.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_coll_0.test_asset_head_coll_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_head_coll_0.test_asset_head_coll_0.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_head_coll_1', async () => {
    await test_asset_head_coll_1.test_asset_head_coll_1.deploy({ as: alice })

    const my_asset_before = await test_asset_head_coll_1.test_asset_head_coll_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_head_coll_1.test_asset_head_coll_1.get_res()
    assert(res_before.length == 0)

    await test_asset_head_coll_1.test_asset_head_coll_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_coll_1.test_asset_head_coll_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_head_coll_1.test_asset_head_coll_1.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_head_coll_2', async () => {
    await test_asset_head_coll_2.test_asset_head_coll_2.deploy({ as: alice })

    const my_asset_before = await test_asset_head_coll_2.test_asset_head_coll_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_head_coll_2.test_asset_head_coll_2.get_res()
    assert(res_before.length == 0)

    await test_asset_head_coll_2.test_asset_head_coll_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_coll_2.test_asset_head_coll_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_head_coll_2.test_asset_head_coll_2.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_head_view_0', async () => {
    await test_asset_head_view_0.test_asset_head_view_0.deploy({ as: alice })

    const my_asset_before = await test_asset_head_view_0.test_asset_head_view_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_head_view_0.test_asset_head_view_0.get_res()
    assert(res_before.length == 0)

    await test_asset_head_view_0.test_asset_head_view_0.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_view_0.test_asset_head_view_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_head_view_0.test_asset_head_view_0.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_head_view_1', async () => {
    await test_asset_head_view_1.test_asset_head_view_1.deploy({ as: alice })

    const my_asset_before = await test_asset_head_view_1.test_asset_head_view_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_head_view_1.test_asset_head_view_1.get_res()
    assert(res_before.length == 0)

    await test_asset_head_view_1.test_asset_head_view_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_view_1.test_asset_head_view_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_head_view_1.test_asset_head_view_1.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_head_view_2', async () => {
    await test_asset_head_view_2.test_asset_head_view_2.deploy({ as: alice })

    const my_asset_before = await test_asset_head_view_2.test_asset_head_view_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_head_view_2.test_asset_head_view_2.get_res()
    assert(res_before.length == 0)

    await test_asset_head_view_2.test_asset_head_view_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_head_view_2.test_asset_head_view_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_head_view_2.test_asset_head_view_2.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_multi_key', async () => {
    await test_asset_multi_key.test_asset_multi_key.deploy({ as: alice })

    const my_asset_before = await test_asset_multi_key.test_asset_multi_key.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].i.equals(new Nat(0)))
    assert(my_asset_before[0][0].s == "mystr_0")
    assert(my_asset_before[0][1] == true)

    await test_asset_multi_key.test_asset_multi_key.exec({ as: alice })

    const my_asset_after = await test_asset_multi_key.test_asset_multi_key.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].i.equals(new Nat(0)))
    assert(my_asset_after[0][0].s == "mystr_0")
    assert(my_asset_after[0][1] == false)
  })

  it('test_asset_multi_key_complex', async () => {
    await test_asset_multi_key_complex.test_asset_multi_key_complex.deploy({ as: alice })

    const my_asset_before = await test_asset_multi_key_complex.test_asset_multi_key_complex.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].i.equals(new Nat(0)))
    assert(my_asset_before[0][0].s == "mystr_0")
    assert(my_asset_before[0][1] == true)

    await test_asset_multi_key_complex.test_asset_multi_key_complex.exec({ as: alice })

    const my_asset_after = await test_asset_multi_key_complex.test_asset_multi_key_complex.get_my_asset()
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0].i.equals(new Nat(0)))
    assert(my_asset_after[0][0].s == "mystr_0")
    assert(my_asset_after[0][1] == false)
    assert(my_asset_after[1][0].i.equals(new Nat(1)))
    assert(my_asset_after[1][0].s == "mystr_1")
    assert(my_asset_after[1][1] == false)
  })

  it('test_asset_nth_agg_0', async () => {
    await test_asset_nth_agg_0.test_asset_nth_agg_0.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_agg_0.test_asset_nth_agg_0.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_nth_agg_0.test_asset_nth_agg_0.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0] == "id0")
    assert(o_asset_before[1] == "id1")
    assert(o_asset_before[2] == "id2")
    const res_before = await test_asset_nth_agg_0.test_asset_nth_agg_0.get_res()
    assert(res_before == "")

    await test_asset_nth_agg_0.test_asset_nth_agg_0.exec(new Nat(1), { as: alice })

    const my_asset_after = await test_asset_nth_agg_0.test_asset_nth_agg_0.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0] == "id0")
    assert(my_asset_after[0][1][1] == "id1")
    assert(my_asset_after[0][1][2] == "id2")
    const o_asset_after = await test_asset_nth_agg_0.test_asset_nth_agg_0.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0] == "id0")
    assert(o_asset_after[1] == "id1")
    assert(o_asset_after[2] == "id2")
    const res_after = await test_asset_nth_agg_0.test_asset_nth_agg_0.get_res()
    assert(res_after == "id1")
  })

  it('test_asset_nth_agg_1', async () => {
    await test_asset_nth_agg_1.test_asset_nth_agg_1.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_agg_1.test_asset_nth_agg_1.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_nth_agg_1.test_asset_nth_agg_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0] == "id0")
    assert(o_asset_before[0][1] == true)
    assert(o_asset_before[1][0] == "id1")
    assert(o_asset_before[1][1] == true)
    assert(o_asset_before[2][0] == "id2")
    assert(o_asset_before[2][1] == true)
    const res_before = await test_asset_nth_agg_1.test_asset_nth_agg_1.get_res()
    assert(res_before == "")

    await test_asset_nth_agg_1.test_asset_nth_agg_1.exec(new Nat(1), { as: alice })

    const my_asset_after = await test_asset_nth_agg_1.test_asset_nth_agg_1.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0] == "id0")
    assert(my_asset_after[0][1][1] == "id1")
    assert(my_asset_after[0][1][2] == "id2")
    const o_asset_after = await test_asset_nth_agg_1.test_asset_nth_agg_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0] == "id0")
    assert(o_asset_after[0][1] == true)
    assert(o_asset_after[1][0] == "id1")
    assert(o_asset_after[1][1] == true)
    assert(o_asset_after[2][0] == "id2")
    assert(o_asset_after[2][1] == true)
    const res_after = await test_asset_nth_agg_1.test_asset_nth_agg_1.get_res()
    assert(res_after == "id1")
  })

  it('test_asset_nth_agg_2', async () => {
    await test_asset_nth_agg_2.test_asset_nth_agg_2.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_agg_2.test_asset_nth_agg_2.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_nth_agg_2.test_asset_nth_agg_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0] == "id0")
    assert(o_asset_before[0][1].v == true)
    assert(o_asset_before[0][1].a.equals(new Nat(0)))
    assert(o_asset_before[1][0] == "id1")
    assert(o_asset_before[1][1].v == true)
    assert(o_asset_before[1][1].a.equals(new Nat(1)))
    assert(o_asset_before[2][0] == "id2")
    assert(o_asset_before[2][1].v == true)
    assert(o_asset_before[2][1].a.equals(new Nat(2)))
    const res_before = await test_asset_nth_agg_2.test_asset_nth_agg_2.get_res()
    assert(res_before == "")

    await test_asset_nth_agg_2.test_asset_nth_agg_2.exec(new Nat(1), { as: alice })

    const my_asset_after = await test_asset_nth_agg_2.test_asset_nth_agg_2.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0] == "id0")
    assert(my_asset_after[0][1][1] == "id1")
    assert(my_asset_after[0][1][2] == "id2")
    const o_asset_after = await test_asset_nth_agg_2.test_asset_nth_agg_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0] == "id0")
    assert(o_asset_after[0][1].v == true)
    assert(o_asset_after[0][1].a.equals(new Nat(0)))
    assert(o_asset_after[1][0] == "id1")
    assert(o_asset_after[1][1].v == true)
    assert(o_asset_after[1][1].a.equals(new Nat(1)))
    assert(o_asset_after[2][0] == "id2")
    assert(o_asset_after[2][1].v == true)
    assert(o_asset_after[2][1].a.equals(new Nat(2)))
    const res_after = await test_asset_nth_agg_2.test_asset_nth_agg_2.get_res()
    assert(res_after == "id1")
  })

  it('test_asset_nth_coll_0', async () => {
    await test_asset_nth_coll_0.test_asset_nth_coll_0.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_coll_0.test_asset_nth_coll_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await test_asset_nth_coll_0.test_asset_nth_coll_0.get_res()
    assert(res_before == "")

    await expect_to_fail(async () => {
      await test_asset_nth_coll_0.test_asset_nth_coll_0.exec(new Nat(3), { as: alice })
    }, { string: "OUT_OF_BOUND" })

    await test_asset_nth_coll_0.test_asset_nth_coll_0.exec(new Nat(2), { as: alice })
    const my_asset_2 = await test_asset_nth_coll_0.test_asset_nth_coll_0.get_my_asset()
    assert(my_asset_2.length == 3)
    assert(my_asset_2[0] == "id0")
    assert(my_asset_2[1] == "id1")
    assert(my_asset_2[2] == "id2")
    const res_2 = await test_asset_nth_coll_0.test_asset_nth_coll_0.get_res()
    assert(res_2 == "id2")

    await test_asset_nth_coll_0.test_asset_nth_coll_0.exec(new Nat(1), { as: alice })
    const my_asset_1 = await test_asset_nth_coll_0.test_asset_nth_coll_0.get_my_asset()
    assert(my_asset_1.length == 3)
    assert(my_asset_1[0] == "id0")
    assert(my_asset_1[1] == "id1")
    assert(my_asset_1[2] == "id2")
    const res_1 = await test_asset_nth_coll_0.test_asset_nth_coll_0.get_res()
    assert(res_1 == "id1")

    await test_asset_nth_coll_0.test_asset_nth_coll_0.exec(new Nat(0), { as: alice })
    const my_asset_0 = await test_asset_nth_coll_0.test_asset_nth_coll_0.get_my_asset()
    assert(my_asset_0.length == 3)
    assert(my_asset_0[0] == "id0")
    assert(my_asset_0[1] == "id1")
    assert(my_asset_0[2] == "id2")
    const res_0 = await test_asset_nth_coll_0.test_asset_nth_coll_0.get_res()
    assert(res_0 == "id0")
  })

  it('test_asset_nth_coll_1', async () => {
    await test_asset_nth_coll_1.test_asset_nth_coll_1.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_coll_1.test_asset_nth_coll_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_before = await test_asset_nth_coll_1.test_asset_nth_coll_1.get_res()
    assert(res_before == "")

    await expect_to_fail(async () => {
      await test_asset_nth_coll_1.test_asset_nth_coll_1.exec(new Nat(3), { as: alice })
    }, { string: "OUT_OF_BOUND" })

    await test_asset_nth_coll_1.test_asset_nth_coll_1.exec(new Nat(2), { as: alice })
    const my_asset_2 = await test_asset_nth_coll_1.test_asset_nth_coll_1.get_my_asset()
    assert(my_asset_2.length == 3)
    assert(my_asset_2[0][0] == "id0")
    assert(my_asset_2[0][1].equals(new Int(0)))
    assert(my_asset_2[1][0] == "id1")
    assert(my_asset_2[1][1].equals(new Int(1)))
    assert(my_asset_2[2][0] == "id2")
    assert(my_asset_2[2][1].equals(new Int(2)))
    const res_2 = await test_asset_nth_coll_1.test_asset_nth_coll_1.get_res()
    assert(res_2 == "id2")

    await test_asset_nth_coll_1.test_asset_nth_coll_1.exec(new Nat(1), { as: alice })
    const my_asset_1 = await test_asset_nth_coll_1.test_asset_nth_coll_1.get_my_asset()
    assert(my_asset_1.length == 3)
    assert(my_asset_1[0][0] == "id0")
    assert(my_asset_1[0][1].equals(new Int(0)))
    assert(my_asset_1[1][0] == "id1")
    assert(my_asset_1[1][1].equals(new Int(1)))
    assert(my_asset_1[2][0] == "id2")
    assert(my_asset_1[2][1].equals(new Int(2)))
    const res_1 = await test_asset_nth_coll_1.test_asset_nth_coll_1.get_res()
    assert(res_1 == "id1")

    await test_asset_nth_coll_1.test_asset_nth_coll_1.exec(new Nat(0), { as: alice })
    const my_asset_0 = await test_asset_nth_coll_1.test_asset_nth_coll_1.get_my_asset()
    assert(my_asset_0.length == 3)
    assert(my_asset_0[0][0] == "id0")
    assert(my_asset_0[0][1].equals(new Int(0)))
    assert(my_asset_0[1][0] == "id1")
    assert(my_asset_0[1][1].equals(new Int(1)))
    assert(my_asset_0[2][0] == "id2")
    assert(my_asset_0[2][1].equals(new Int(2)))
    const res_0 = await test_asset_nth_coll_1.test_asset_nth_coll_1.get_res()
    assert(res_0 == "id0")
  })

  it('test_asset_nth_coll_2', async () => {
    await test_asset_nth_coll_2.test_asset_nth_coll_2.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_coll_2.test_asset_nth_coll_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].b == true)
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    const res_before = await test_asset_nth_coll_2.test_asset_nth_coll_2.get_res()
    assert(res_before == "")

    await expect_to_fail(async () => {
      await test_asset_nth_coll_2.test_asset_nth_coll_2.exec(new Nat(3), { as: alice })
    }, { string: "OUT_OF_BOUND" })

    await test_asset_nth_coll_2.test_asset_nth_coll_2.exec(new Nat(2), { as: alice })
    const my_asset_2 = await test_asset_nth_coll_2.test_asset_nth_coll_2.get_my_asset()
    assert(my_asset_2.length == 3)
    assert(my_asset_2[0][0] == "id0")
    assert(my_asset_2[0][1].b == true)
    assert(my_asset_2[0][1].value.equals(new Int(0)))
    assert(my_asset_2[1][0] == "id1")
    assert(my_asset_2[1][1].b == true)
    assert(my_asset_2[1][1].value.equals(new Int(1)))
    assert(my_asset_2[2][0] == "id2")
    assert(my_asset_2[2][1].b == true)
    assert(my_asset_2[2][1].value.equals(new Int(2)))
    const res_2 = await test_asset_nth_coll_2.test_asset_nth_coll_2.get_res()
    assert(res_2 == "id2")

    await test_asset_nth_coll_2.test_asset_nth_coll_2.exec(new Nat(1), { as: alice })
    const my_asset_1 = await test_asset_nth_coll_2.test_asset_nth_coll_2.get_my_asset()
    assert(my_asset_1.length == 3)
    assert(my_asset_1[0][0] == "id0")
    assert(my_asset_1[0][1].b == true)
    assert(my_asset_1[0][1].value.equals(new Int(0)))
    assert(my_asset_1[1][0] == "id1")
    assert(my_asset_1[1][1].b == true)
    assert(my_asset_1[1][1].value.equals(new Int(1)))
    assert(my_asset_1[2][0] == "id2")
    assert(my_asset_1[2][1].b == true)
    assert(my_asset_1[2][1].value.equals(new Int(2)))
    const res_1 = await test_asset_nth_coll_2.test_asset_nth_coll_2.get_res()
    assert(res_1 == "id1")

    await test_asset_nth_coll_2.test_asset_nth_coll_2.exec(new Nat(0), { as: alice })
    const my_asset_0 = await test_asset_nth_coll_2.test_asset_nth_coll_2.get_my_asset()
    assert(my_asset_0.length == 3)
    assert(my_asset_0[0][0] == "id0")
    assert(my_asset_0[0][1].b == true)
    assert(my_asset_0[0][1].value.equals(new Int(0)))
    assert(my_asset_0[1][0] == "id1")
    assert(my_asset_0[1][1].b == true)
    assert(my_asset_0[1][1].value.equals(new Int(1)))
    assert(my_asset_0[2][0] == "id2")
    assert(my_asset_0[2][1].b == true)
    assert(my_asset_0[2][1].value.equals(new Int(2)))
    const res_0 = await test_asset_nth_coll_2.test_asset_nth_coll_2.get_res()
    assert(res_0 == "id0")
  })

  it('test_asset_nth_view_0', async () => {
    await test_asset_nth_view_0.test_asset_nth_view_0.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_view_0.test_asset_nth_view_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0] == "id0")
    assert(my_asset_before[1] == "id1")
    assert(my_asset_before[2] == "id2")
    const res_before = await test_asset_nth_view_0.test_asset_nth_view_0.get_res()
    assert(res_before == "")

    await expect_to_fail(async () => {
      await test_asset_nth_view_0.test_asset_nth_view_0.exec(new Nat(3), { as: alice })
    }, { string: "OUT_OF_BOUND" })

    await test_asset_nth_view_0.test_asset_nth_view_0.exec(new Nat(2), { as: alice })
    const my_asset_2 = await test_asset_nth_view_0.test_asset_nth_view_0.get_my_asset()
    assert(my_asset_2.length == 3)
    assert(my_asset_2[0] == "id0")
    assert(my_asset_2[1] == "id1")
    assert(my_asset_2[2] == "id2")
    const res_2 = await test_asset_nth_view_0.test_asset_nth_view_0.get_res()
    assert(res_2 == "id2")

    await test_asset_nth_view_0.test_asset_nth_view_0.exec(new Nat(1), { as: alice })
    const my_asset_1 = await test_asset_nth_view_0.test_asset_nth_view_0.get_my_asset()
    assert(my_asset_1.length == 3)
    assert(my_asset_1[0] == "id0")
    assert(my_asset_1[1] == "id1")
    assert(my_asset_1[2] == "id2")
    const res_1 = await test_asset_nth_view_0.test_asset_nth_view_0.get_res()
    assert(res_1 == "id1")

    await test_asset_nth_view_0.test_asset_nth_view_0.exec(new Nat(0), { as: alice })
    const my_asset_0 = await test_asset_nth_view_0.test_asset_nth_view_0.get_my_asset()
    assert(my_asset_0.length == 3)
    assert(my_asset_0[0] == "id0")
    assert(my_asset_0[1] == "id1")
    assert(my_asset_0[2] == "id2")
    const res_0 = await test_asset_nth_view_0.test_asset_nth_view_0.get_res()
    assert(res_0 == "id0")
  })

  it('test_asset_nth_view_1', async () => {
    await test_asset_nth_view_1.test_asset_nth_view_1.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_view_1.test_asset_nth_view_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))
    const res_before = await test_asset_nth_view_1.test_asset_nth_view_1.get_res()
    assert(res_before == "")

    await expect_to_fail(async () => {
      await test_asset_nth_view_1.test_asset_nth_view_1.exec(new Nat(3), { as: alice })
    }, { string: "OUT_OF_BOUND" })

    await test_asset_nth_view_1.test_asset_nth_view_1.exec(new Nat(2), { as: alice })
    const my_asset_2 = await test_asset_nth_view_1.test_asset_nth_view_1.get_my_asset()
    assert(my_asset_2.length == 3)
    assert(my_asset_2[0][0] == "id0")
    assert(my_asset_2[0][1].equals(new Nat(0)))
    assert(my_asset_2[1][0] == "id1")
    assert(my_asset_2[1][1].equals(new Nat(1)))
    assert(my_asset_2[2][0] == "id2")
    assert(my_asset_2[2][1].equals(new Nat(2)))
    const res_2 = await test_asset_nth_view_1.test_asset_nth_view_1.get_res()
    assert(res_2 == "id2")

    await test_asset_nth_view_1.test_asset_nth_view_1.exec(new Nat(1), { as: alice })
    const my_asset_1 = await test_asset_nth_view_1.test_asset_nth_view_1.get_my_asset()
    assert(my_asset_1.length == 3)
    assert(my_asset_1[0][0] == "id0")
    assert(my_asset_1[0][1].equals(new Nat(0)))
    assert(my_asset_1[1][0] == "id1")
    assert(my_asset_1[1][1].equals(new Nat(1)))
    assert(my_asset_1[2][0] == "id2")
    assert(my_asset_1[2][1].equals(new Nat(2)))
    const res_1 = await test_asset_nth_view_1.test_asset_nth_view_1.get_res()
    assert(res_1 == "id1")

    await test_asset_nth_view_1.test_asset_nth_view_1.exec(new Nat(0), { as: alice })
    const my_asset_0 = await test_asset_nth_view_1.test_asset_nth_view_1.get_my_asset()
    assert(my_asset_0.length == 3)
    assert(my_asset_0[0][0] == "id0")
    assert(my_asset_0[0][1].equals(new Nat(0)))
    assert(my_asset_0[1][0] == "id1")
    assert(my_asset_0[1][1].equals(new Nat(1)))
    assert(my_asset_0[2][0] == "id2")
    assert(my_asset_0[2][1].equals(new Nat(2)))
    const res_0 = await test_asset_nth_view_1.test_asset_nth_view_1.get_res()
    assert(res_0 == "id0")
  })

  it('test_asset_nth_view_2', async () => {
    await test_asset_nth_view_2.test_asset_nth_view_2.deploy({ as: alice })

    const my_asset_before = await test_asset_nth_view_2.test_asset_nth_view_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[0][1].v.equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[1][1].v.equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].b == true)
    assert(my_asset_before[2][1].v.equals(new Nat(2)))
    const res_before = await test_asset_nth_view_2.test_asset_nth_view_2.get_res()
    assert(res_before == "")

    await expect_to_fail(async () => {
      await test_asset_nth_view_2.test_asset_nth_view_2.exec(new Nat(3), { as: alice })
    }, { string: "OUT_OF_BOUND" })

    await test_asset_nth_view_2.test_asset_nth_view_2.exec(new Nat(2), { as: alice })
    const my_asset_2 = await test_asset_nth_view_2.test_asset_nth_view_2.get_my_asset()
    assert(my_asset_2.length == 3)
    assert(my_asset_2[0][0] == "id0")
    assert(my_asset_2[0][1].b == true)
    assert(my_asset_2[0][1].v.equals(new Nat(0)))
    assert(my_asset_2[1][0] == "id1")
    assert(my_asset_2[1][1].b == true)
    assert(my_asset_2[1][1].v.equals(new Nat(1)))
    assert(my_asset_2[2][0] == "id2")
    assert(my_asset_2[2][1].b == true)
    assert(my_asset_2[2][1].v.equals(new Nat(2)))
    const res_2 = await test_asset_nth_view_2.test_asset_nth_view_2.get_res()
    assert(res_2 == "id2")

    await test_asset_nth_view_2.test_asset_nth_view_2.exec(new Nat(1), { as: alice })
    const my_asset_1 = await test_asset_nth_view_2.test_asset_nth_view_2.get_my_asset()
    assert(my_asset_1.length == 3)
    assert(my_asset_1[0][0] == "id0")
    assert(my_asset_1[0][1].b == true)
    assert(my_asset_1[0][1].v.equals(new Nat(0)))
    assert(my_asset_1[1][0] == "id1")
    assert(my_asset_1[1][1].b == true)
    assert(my_asset_1[1][1].v.equals(new Nat(1)))
    assert(my_asset_1[2][0] == "id2")
    assert(my_asset_1[2][1].b == true)
    assert(my_asset_1[2][1].v.equals(new Nat(2)))
    const res_1 = await test_asset_nth_view_2.test_asset_nth_view_2.get_res()
    assert(res_1 == "id1")

    await test_asset_nth_view_2.test_asset_nth_view_2.exec(new Nat(0), { as: alice })
    const my_asset_0 = await test_asset_nth_view_2.test_asset_nth_view_2.get_my_asset()
    assert(my_asset_0.length == 3)
    assert(my_asset_0[0][0] == "id0")
    assert(my_asset_0[0][1].b == true)
    assert(my_asset_0[0][1].v.equals(new Nat(0)))
    assert(my_asset_0[1][0] == "id1")
    assert(my_asset_0[1][1].b == true)
    assert(my_asset_0[1][1].v.equals(new Nat(1)))
    assert(my_asset_0[2][0] == "id2")
    assert(my_asset_0[2][1].b == true)
    assert(my_asset_0[2][1].v.equals(new Nat(2)))
    const res_0 = await test_asset_nth_view_2.test_asset_nth_view_2.get_res()
    assert(res_0 == "id0")
  })

  it('test_asset_select_agg_0', async () => {
    await test_asset_select_agg_0.test_asset_select_agg_0.deploy({ as: alice })

    const my_asset_before = await test_asset_select_agg_0.test_asset_select_agg_0.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_select_agg_0.test_asset_select_agg_0.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_select_agg_0.test_asset_select_agg_0.get_res()
    assert(res_before.length == 0)

    await test_asset_select_agg_0.test_asset_select_agg_0.exec(new Nat(1), { as: alice })

    const my_asset_after = await test_asset_select_agg_0.test_asset_select_agg_0.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_select_agg_0.test_asset_select_agg_0.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_select_agg_0.test_asset_select_agg_0.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_select_agg_1', async () => {
    await test_asset_select_agg_1.test_asset_select_agg_1.deploy({ as: alice })

    const my_asset_before = await test_asset_select_agg_1.test_asset_select_agg_1.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_select_agg_1.test_asset_select_agg_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1] == "mystr0")
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1] == "mystr1")
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_select_agg_1.test_asset_select_agg_1.get_res()
    assert(res_before.length == 0)

    await test_asset_select_agg_1.test_asset_select_agg_1.exec(new Nat(1), { as: alice })

    const my_asset_after = await test_asset_select_agg_1.test_asset_select_agg_1.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_select_agg_1.test_asset_select_agg_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1] == "mystr0")
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1] == "mystr1")
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_select_agg_1.test_asset_select_agg_1.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('test_asset_select_agg_2', async () => {
    await test_asset_select_agg_2.test_asset_select_agg_2.deploy({ as: alice })

    const my_asset_before = await test_asset_select_agg_2.test_asset_select_agg_2.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_select_agg_2.test_asset_select_agg_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1].s == "mystr0")
    assert(o_asset_before[0][1].b == true)
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1].s == "mystr1")
    assert(o_asset_before[1][1].b == true)
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1].s == "mystr2")
    assert(o_asset_before[2][1].b == true)
    const res_before = await test_asset_select_agg_2.test_asset_select_agg_2.get_res()
    assert(res_before.length == 0)

    await test_asset_select_agg_2.test_asset_select_agg_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_select_agg_2.test_asset_select_agg_2.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_select_agg_2.test_asset_select_agg_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1].s == "mystr0")
    assert(o_asset_after[0][1].b == true)
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1].s == "mystr1")
    assert(o_asset_after[1][1].b == true)
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1].s == "mystr2")
    assert(o_asset_after[2][1].b == true)
    const res_after = await test_asset_select_agg_2.test_asset_select_agg_2.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('test_asset_select_coll_0', async () => {
    await test_asset_select_coll_0.test_asset_select_coll_0.deploy({ as: alice })

    const my_asset_before = await test_asset_select_coll_0.test_asset_select_coll_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_select_coll_0.test_asset_select_coll_0.get_res()
    assert(res_before.length == 0)

    await test_asset_select_coll_0.test_asset_select_coll_0.exec(new Nat(1), { as: alice })

    const my_asset_after = await test_asset_select_coll_0.test_asset_select_coll_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_select_coll_0.test_asset_select_coll_0.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
  })

  it('test_asset_select_coll_1', async () => {
    await test_asset_select_coll_1.test_asset_select_coll_1.deploy({ as: alice })

    const my_asset_before = await test_asset_select_coll_1.test_asset_select_coll_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_select_coll_1.test_asset_select_coll_1.get_res()
    assert(res_before.length == 0)

    await test_asset_select_coll_1.test_asset_select_coll_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_select_coll_1.test_asset_select_coll_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_select_coll_1.test_asset_select_coll_1.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('test_asset_select_coll_2', async () => {
    await test_asset_select_coll_2.test_asset_select_coll_2.deploy({ as: alice })

    const my_asset_before = await test_asset_select_coll_2.test_asset_select_coll_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_select_coll_2.test_asset_select_coll_2.get_res()
    assert(res_before.length == 0)

    await test_asset_select_coll_2.test_asset_select_coll_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_select_coll_2.test_asset_select_coll_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_select_coll_2.test_asset_select_coll_2.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('test_asset_select_view_0', async () => {
    await test_asset_select_view_0.test_asset_select_view_0.deploy({ as: alice })

    const my_asset_before = await test_asset_select_view_0.test_asset_select_view_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_select_view_0.test_asset_select_view_0.get_res()
    assert(res_before.length == 0)

    await test_asset_select_view_0.test_asset_select_view_0.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_select_view_0.test_asset_select_view_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_select_view_0.test_asset_select_view_0.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('test_asset_select_view_1', async () => {
    await test_asset_select_view_1.test_asset_select_view_1.deploy({ as: alice })

    const my_asset_before = await test_asset_select_view_1.test_asset_select_view_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_select_view_1.test_asset_select_view_1.get_res()
    assert(res_before.length == 0)

    await test_asset_select_view_1.test_asset_select_view_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_select_view_1.test_asset_select_view_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_select_view_1.test_asset_select_view_1.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('test_asset_select_view_2', async () => {
    await test_asset_select_view_2.test_asset_select_view_2.deploy({ as: alice })

    const my_asset_before = await test_asset_select_view_2.test_asset_select_view_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_select_view_2.test_asset_select_view_2.get_res()
    assert(res_before.length == 0)

    await test_asset_select_view_2.test_asset_select_view_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_select_view_2.test_asset_select_view_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_select_view_2.test_asset_select_view_2.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(0)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(2)))
  })

  it('test_asset_sort_agg_0', async () => {
    await test_asset_sort_agg_0.test_asset_sort_agg_0.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_agg_0.test_asset_sort_agg_0.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_sort_agg_0.test_asset_sort_agg_0.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_sort_agg_0.test_asset_sort_agg_0.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_agg_0.test_asset_sort_agg_0.exec({ as: alice })

    const my_asset_after = await test_asset_sort_agg_0.test_asset_sort_agg_0.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_sort_agg_0.test_asset_sort_agg_0.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_sort_agg_0.test_asset_sort_agg_0.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sort_agg_1', async () => {
    await test_asset_sort_agg_1.test_asset_sort_agg_1.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_agg_1.test_asset_sort_agg_1.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_sort_agg_1.test_asset_sort_agg_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1] == "mystr0")
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1] == "mystr1")
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_sort_agg_1.test_asset_sort_agg_1.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_agg_1.test_asset_sort_agg_1.exec({ as: alice })

    const my_asset_after = await test_asset_sort_agg_1.test_asset_sort_agg_1.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_sort_agg_1.test_asset_sort_agg_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1] == "mystr0")
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1] == "mystr1")
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_sort_agg_1.test_asset_sort_agg_1.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sort_agg_2', async () => {
    await test_asset_sort_agg_2.test_asset_sort_agg_2.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_agg_2.test_asset_sort_agg_2.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_sort_agg_2.test_asset_sort_agg_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1].s == "mystr0")
    assert(o_asset_before[0][1].b == true)
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1].s == "mystr1")
    assert(o_asset_before[1][1].b == true)
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1].s == "mystr2")
    assert(o_asset_before[2][1].b == true)
    const res_before = await test_asset_sort_agg_2.test_asset_sort_agg_2.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_agg_2.test_asset_sort_agg_2.exec({ as: alice })

    const my_asset_after = await test_asset_sort_agg_2.test_asset_sort_agg_2.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_sort_agg_2.test_asset_sort_agg_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1].s == "mystr0")
    assert(o_asset_after[0][1].b == true)
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1].s == "mystr1")
    assert(o_asset_after[1][1].b == true)
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1].s == "mystr2")
    assert(o_asset_after[2][1].b == true)
    const res_after = await test_asset_sort_agg_2.test_asset_sort_agg_2.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sort_coll_0', async () => {
    await test_asset_sort_coll_0.test_asset_sort_coll_0.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_coll_0.test_asset_sort_coll_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_sort_coll_0.test_asset_sort_coll_0.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_coll_0.test_asset_sort_coll_0.exec({ as: alice })

    const my_asset_after = await test_asset_sort_coll_0.test_asset_sort_coll_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_sort_coll_0.test_asset_sort_coll_0.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sort_coll_1', async () => {
    await test_asset_sort_coll_1.test_asset_sort_coll_1.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_coll_1.test_asset_sort_coll_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_sort_coll_1.test_asset_sort_coll_1.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_coll_1.test_asset_sort_coll_1.exec({ as: alice })

    const my_asset_after = await test_asset_sort_coll_1.test_asset_sort_coll_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_sort_coll_1.test_asset_sort_coll_1.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sort_coll_2', async () => {
    await test_asset_sort_coll_2.test_asset_sort_coll_2.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_coll_2.test_asset_sort_coll_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_sort_coll_2.test_asset_sort_coll_2.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_coll_2.test_asset_sort_coll_2.exec({ as: alice })

    const my_asset_after = await test_asset_sort_coll_2.test_asset_sort_coll_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_sort_coll_2.test_asset_sort_coll_2.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sort_coll_complex', async () => {
    await test_asset_sort_coll_complex.test_asset_sort_coll_complex.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_coll_complex.test_asset_sort_coll_complex.get_my_asset()
    assert(my_asset_before.length == 8)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].n0.equals(new Nat(0)))
    assert(my_asset_before[0][1].n1.equals(new Nat(0)))
    assert(my_asset_before[0][1].n2.equals(new Nat(0)))
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].n0.equals(new Nat(0)))
    assert(my_asset_before[1][1].n1.equals(new Nat(0)))
    assert(my_asset_before[1][1].n2.equals(new Nat(1)))
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].n0.equals(new Nat(0)))
    assert(my_asset_before[2][1].n1.equals(new Nat(1)))
    assert(my_asset_before[2][1].n2.equals(new Nat(0)))
    assert(my_asset_before[3][0].equals(new Nat(3)))
    assert(my_asset_before[3][1].n0.equals(new Nat(0)))
    assert(my_asset_before[3][1].n1.equals(new Nat(1)))
    assert(my_asset_before[3][1].n2.equals(new Nat(1)))
    assert(my_asset_before[4][0].equals(new Nat(4)))
    assert(my_asset_before[4][1].n0.equals(new Nat(1)))
    assert(my_asset_before[4][1].n1.equals(new Nat(0)))
    assert(my_asset_before[4][1].n2.equals(new Nat(0)))
    assert(my_asset_before[5][0].equals(new Nat(5)))
    assert(my_asset_before[5][1].n0.equals(new Nat(1)))
    assert(my_asset_before[5][1].n1.equals(new Nat(0)))
    assert(my_asset_before[5][1].n2.equals(new Nat(1)))
    assert(my_asset_before[6][0].equals(new Nat(6)))
    assert(my_asset_before[6][1].n0.equals(new Nat(1)))
    assert(my_asset_before[6][1].n1.equals(new Nat(1)))
    assert(my_asset_before[6][1].n2.equals(new Nat(0)))
    assert(my_asset_before[7][0].equals(new Nat(7)))
    assert(my_asset_before[7][1].n0.equals(new Nat(1)))
    assert(my_asset_before[7][1].n1.equals(new Nat(1)))
    assert(my_asset_before[7][1].n2.equals(new Nat(1)))
    const res_before = await test_asset_sort_coll_complex.test_asset_sort_coll_complex.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_coll_complex.test_asset_sort_coll_complex.exec({ as: alice })

    const my_asset_after = await test_asset_sort_coll_complex.test_asset_sort_coll_complex.get_my_asset()
    assert(my_asset_after.length == 8)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].n0.equals(new Nat(0)))
    assert(my_asset_after[0][1].n1.equals(new Nat(0)))
    assert(my_asset_after[0][1].n2.equals(new Nat(0)))
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].n0.equals(new Nat(0)))
    assert(my_asset_after[1][1].n1.equals(new Nat(0)))
    assert(my_asset_after[1][1].n2.equals(new Nat(1)))
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].n0.equals(new Nat(0)))
    assert(my_asset_after[2][1].n1.equals(new Nat(1)))
    assert(my_asset_after[2][1].n2.equals(new Nat(0)))
    assert(my_asset_after[3][0].equals(new Nat(3)))
    assert(my_asset_after[3][1].n0.equals(new Nat(0)))
    assert(my_asset_after[3][1].n1.equals(new Nat(1)))
    assert(my_asset_after[3][1].n2.equals(new Nat(1)))
    assert(my_asset_after[4][0].equals(new Nat(4)))
    assert(my_asset_after[4][1].n0.equals(new Nat(1)))
    assert(my_asset_after[4][1].n1.equals(new Nat(0)))
    assert(my_asset_after[4][1].n2.equals(new Nat(0)))
    assert(my_asset_after[5][0].equals(new Nat(5)))
    assert(my_asset_after[5][1].n0.equals(new Nat(1)))
    assert(my_asset_after[5][1].n1.equals(new Nat(0)))
    assert(my_asset_after[5][1].n2.equals(new Nat(1)))
    assert(my_asset_after[6][0].equals(new Nat(6)))
    assert(my_asset_after[6][1].n0.equals(new Nat(1)))
    assert(my_asset_after[6][1].n1.equals(new Nat(1)))
    assert(my_asset_after[6][1].n2.equals(new Nat(0)))
    assert(my_asset_after[7][0].equals(new Nat(7)))
    assert(my_asset_after[7][1].n0.equals(new Nat(1)))
    assert(my_asset_after[7][1].n1.equals(new Nat(1)))
    assert(my_asset_after[7][1].n2.equals(new Nat(1)))
    const res_after = await test_asset_sort_coll_complex.test_asset_sort_coll_complex.get_res()
    assert(res_after.length == 8)
    assert(res_after[0].equals(new Nat(7)))
    assert(res_after[1].equals(new Nat(6)))
    assert(res_after[2].equals(new Nat(5)))
    assert(res_after[3].equals(new Nat(4)))
    assert(res_after[4].equals(new Nat(3)))
    assert(res_after[5].equals(new Nat(2)))
    assert(res_after[6].equals(new Nat(1)))
    assert(res_after[7].equals(new Nat(0)))
  })

  it('test_asset_sort_coll_random', async () => {
    await test_asset_sort_coll_random.test_asset_sort_coll_random.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_coll_random.test_asset_sort_coll_random.get_my_asset()
    assert(my_asset_before.length == 10)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "a")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "b")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "c")
    assert(my_asset_before[3][0].equals(new Nat(3)))
    assert(my_asset_before[3][1] == "d")
    assert(my_asset_before[4][0].equals(new Nat(4)))
    assert(my_asset_before[4][1] == "e")
    assert(my_asset_before[5][0].equals(new Nat(5)))
    assert(my_asset_before[5][1] == "f")
    assert(my_asset_before[6][0].equals(new Nat(6)))
    assert(my_asset_before[6][1] == "g")
    assert(my_asset_before[7][0].equals(new Nat(7)))
    assert(my_asset_before[7][1] == "h")
    assert(my_asset_before[8][0].equals(new Nat(8)))
    assert(my_asset_before[8][1] == "i")
    assert(my_asset_before[9][0].equals(new Nat(9)))
    assert(my_asset_before[9][1] == "j")
    const res_before = await test_asset_sort_coll_random.test_asset_sort_coll_random.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_coll_random.test_asset_sort_coll_random.exec({ as: alice })

    const my_asset_after = await test_asset_sort_coll_random.test_asset_sort_coll_random.get_my_asset()
    assert(my_asset_after.length == 10)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "a")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "b")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "c")
    assert(my_asset_after[3][0].equals(new Nat(3)))
    assert(my_asset_after[3][1] == "d")
    assert(my_asset_after[4][0].equals(new Nat(4)))
    assert(my_asset_after[4][1] == "e")
    assert(my_asset_after[5][0].equals(new Nat(5)))
    assert(my_asset_after[5][1] == "f")
    assert(my_asset_after[6][0].equals(new Nat(6)))
    assert(my_asset_after[6][1] == "g")
    assert(my_asset_after[7][0].equals(new Nat(7)))
    assert(my_asset_after[7][1] == "h")
    assert(my_asset_after[8][0].equals(new Nat(8)))
    assert(my_asset_after[8][1] == "i")
    assert(my_asset_after[9][0].equals(new Nat(9)))
    assert(my_asset_after[9][1] == "j")
    const res_after = await test_asset_sort_coll_random.test_asset_sort_coll_random.get_res()
    assert(res_after.length == 10)
    assert(res_after[0].equals(new Nat(9)))
    assert(res_after[1].equals(new Nat(8)))
    assert(res_after[2].equals(new Nat(7)))
    assert(res_after[3].equals(new Nat(6)))
    assert(res_after[4].equals(new Nat(5)))
    assert(res_after[5].equals(new Nat(4)))
    assert(res_after[6].equals(new Nat(3)))
    assert(res_after[7].equals(new Nat(2)))
    assert(res_after[8].equals(new Nat(1)))
    assert(res_after[9].equals(new Nat(0)))
  })

  it('test_asset_sort_coll_random2', async () => {
    await test_asset_sort_coll_random2.test_asset_sort_coll_random2.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_coll_random2.test_asset_sort_coll_random2.get_my_asset()
    assert(my_asset_before.length == 10)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "g")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "e")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "a")
    assert(my_asset_before[3][0].equals(new Nat(3)))
    assert(my_asset_before[3][1] == "j")
    assert(my_asset_before[4][0].equals(new Nat(4)))
    assert(my_asset_before[4][1] == "b")
    assert(my_asset_before[5][0].equals(new Nat(5)))
    assert(my_asset_before[5][1] == "h")
    assert(my_asset_before[6][0].equals(new Nat(6)))
    assert(my_asset_before[6][1] == "d")
    assert(my_asset_before[7][0].equals(new Nat(7)))
    assert(my_asset_before[7][1] == "f")
    assert(my_asset_before[8][0].equals(new Nat(8)))
    assert(my_asset_before[8][1] == "i")
    assert(my_asset_before[9][0].equals(new Nat(9)))
    assert(my_asset_before[9][1] == "c")
    const res_before = await test_asset_sort_coll_random2.test_asset_sort_coll_random2.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_coll_random2.test_asset_sort_coll_random2.exec({ as: alice })

    const my_asset_after = await test_asset_sort_coll_random2.test_asset_sort_coll_random2.get_my_asset()
    assert(my_asset_after.length == 10)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "g")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "e")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "a")
    assert(my_asset_after[3][0].equals(new Nat(3)))
    assert(my_asset_after[3][1] == "j")
    assert(my_asset_after[4][0].equals(new Nat(4)))
    assert(my_asset_after[4][1] == "b")
    assert(my_asset_after[5][0].equals(new Nat(5)))
    assert(my_asset_after[5][1] == "h")
    assert(my_asset_after[6][0].equals(new Nat(6)))
    assert(my_asset_after[6][1] == "d")
    assert(my_asset_after[7][0].equals(new Nat(7)))
    assert(my_asset_after[7][1] == "f")
    assert(my_asset_after[8][0].equals(new Nat(8)))
    assert(my_asset_after[8][1] == "i")
    assert(my_asset_after[9][0].equals(new Nat(9)))
    assert(my_asset_after[9][1] == "c")
    const res_after = await test_asset_sort_coll_random2.test_asset_sort_coll_random2.get_res()
    assert(res_after.length == 10)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(4)))
    assert(res_after[2].equals(new Nat(9)))
    assert(res_after[3].equals(new Nat(6)))
    assert(res_after[4].equals(new Nat(1)))
    assert(res_after[5].equals(new Nat(7)))
    assert(res_after[6].equals(new Nat(0)))
    assert(res_after[7].equals(new Nat(5)))
    assert(res_after[8].equals(new Nat(8)))
    assert(res_after[9].equals(new Nat(3)))
  })

  it('test_asset_sort_coll_rational', async () => {
    await test_asset_sort_coll_rational.test_asset_sort_coll_rational.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_coll_rational.test_asset_sort_coll_rational.get_my_asset()
    assert(my_asset_before.length == 6)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].equals(new Rational(0.0)))
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].equals(new Rational(0.1)))
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].equals(new Rational(0.2)))
    assert(my_asset_before[3][0].equals(new Nat(3)))
    assert(my_asset_before[3][1].equals(new Rational(0.3)))
    assert(my_asset_before[4][0].equals(new Nat(4)))
    assert(my_asset_before[4][1].equals(new Rational(0.4)))
    assert(my_asset_before[5][0].equals(new Nat(5)))
    assert(my_asset_before[5][1].equals(new Rational(0.5)))
    const res_before = await test_asset_sort_coll_rational.test_asset_sort_coll_rational.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_coll_rational.test_asset_sort_coll_rational.exec({ as: alice })

    const my_asset_after = await test_asset_sort_coll_rational.test_asset_sort_coll_rational.get_my_asset()
    assert(my_asset_after.length == 6)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].equals(new Rational(0.0)))
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].equals(new Rational(0.1)))
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].equals(new Rational(0.2)))
    assert(my_asset_after[3][0].equals(new Nat(3)))
    assert(my_asset_after[3][1].equals(new Rational(0.3)))
    assert(my_asset_after[4][0].equals(new Nat(4)))
    assert(my_asset_after[4][1].equals(new Rational(0.4)))
    assert(my_asset_after[5][0].equals(new Nat(5)))
    assert(my_asset_after[5][1].equals(new Rational(0.5)))
    const res_after = await test_asset_sort_coll_rational.test_asset_sort_coll_rational.get_res()
    assert(res_after.length == 6)
    assert(res_after[0].equals(new Nat(5)))
    assert(res_after[1].equals(new Nat(4)))
    assert(res_after[2].equals(new Nat(3)))
    assert(res_after[3].equals(new Nat(2)))
    assert(res_after[4].equals(new Nat(1)))
    assert(res_after[5].equals(new Nat(0)))
  })

  it('test_asset_sort_view_0', async () => {
    await test_asset_sort_view_0.test_asset_sort_view_0.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_view_0.test_asset_sort_view_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_sort_view_0.test_asset_sort_view_0.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_view_0.test_asset_sort_view_0.exec({ as: alice })

    const my_asset_after = await test_asset_sort_view_0.test_asset_sort_view_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_sort_view_0.test_asset_sort_view_0.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sort_view_1', async () => {
    await test_asset_sort_view_1.test_asset_sort_view_1.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_view_1.test_asset_sort_view_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_sort_view_1.test_asset_sort_view_1.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_view_1.test_asset_sort_view_1.exec({ as: alice })

    const my_asset_after = await test_asset_sort_view_1.test_asset_sort_view_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_sort_view_1.test_asset_sort_view_1.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sort_view_2', async () => {
    await test_asset_sort_view_2.test_asset_sort_view_2.deploy({ as: alice })

    const my_asset_before = await test_asset_sort_view_2.test_asset_sort_view_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_sort_view_2.test_asset_sort_view_2.get_res()
    assert(res_before.length == 0)

    await test_asset_sort_view_2.test_asset_sort_view_2.exec({ as: alice })

    const my_asset_after = await test_asset_sort_view_2.test_asset_sort_view_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_sort_view_2.test_asset_sort_view_2.get_res()
    assert(res_after.length == 3)
    assert(res_after[0].equals(new Nat(2)))
    assert(res_after[1].equals(new Nat(1)))
    assert(res_after[2].equals(new Nat(0)))
  })

  it('test_asset_sum_agg_0', async () => {
    await test_asset_sum_agg_0.test_asset_sum_agg_0.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_agg_0.test_asset_sum_agg_0.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_sum_agg_0.test_asset_sum_agg_0.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_sum_agg_0.test_asset_sum_agg_0.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_asset_sum_agg_0.test_asset_sum_agg_0.exec({ as: alice })

    const my_asset_after = await test_asset_sum_agg_0.test_asset_sum_agg_0.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_sum_agg_0.test_asset_sum_agg_0.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_sum_agg_0.test_asset_sum_agg_0.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('test_asset_sum_agg_1', async () => {
    await test_asset_sum_agg_1.test_asset_sum_agg_1.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_agg_1.test_asset_sum_agg_1.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_sum_agg_1.test_asset_sum_agg_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1].equals(new Int(0)))
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1].equals(new Int(1)))
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1].equals(new Int(2)))
    const res_before = await test_asset_sum_agg_1.test_asset_sum_agg_1.get_res()
    assert(res_before.equals(new Int(0)))

    await test_asset_sum_agg_1.test_asset_sum_agg_1.exec({ as: alice })

    const my_asset_after = await test_asset_sum_agg_1.test_asset_sum_agg_1.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_sum_agg_1.test_asset_sum_agg_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1].equals(new Int(0)))
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1].equals(new Int(1)))
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1].equals(new Int(2)))
    const res_after = await test_asset_sum_agg_1.test_asset_sum_agg_1.get_res()
    assert(res_after.equals(new Int(3)))
  })

  it('test_asset_sum_agg_2', async () => {
    await test_asset_sum_agg_2.test_asset_sum_agg_2.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_agg_2.test_asset_sum_agg_2.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_sum_agg_2.test_asset_sum_agg_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1].v.equals(new Int(0)))
    assert(o_asset_before[0][1].b == false)
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1].v.equals(new Int(1)))
    assert(o_asset_before[1][1].b == false)
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1].v.equals(new Int(2)))
    assert(o_asset_before[2][1].b == false)
    const res_before = await test_asset_sum_agg_2.test_asset_sum_agg_2.get_res()
    assert(res_before.equals(new Int(0)))

    await test_asset_sum_agg_2.test_asset_sum_agg_2.exec({ as: alice })

    const my_asset_after = await test_asset_sum_agg_2.test_asset_sum_agg_2.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_sum_agg_2.test_asset_sum_agg_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1].v.equals(new Int(0)))
    assert(o_asset_after[0][1].b == false)
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1].v.equals(new Int(1)))
    assert(o_asset_after[1][1].b == false)
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1].v.equals(new Int(2)))
    assert(o_asset_after[2][1].b == false)
    const res_after = await test_asset_sum_agg_2.test_asset_sum_agg_2.get_res()
    assert(res_after.equals(new Int(3)))
  })

  it('test_asset_sum_coll_0', async () => {
    await test_asset_sum_coll_0.test_asset_sum_coll_0.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_coll_0.test_asset_sum_coll_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_sum_coll_0.test_asset_sum_coll_0.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_asset_sum_coll_0.test_asset_sum_coll_0.exec({ as: alice })

    const my_asset_after = await test_asset_sum_coll_0.test_asset_sum_coll_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_sum_coll_0.test_asset_sum_coll_0.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('test_asset_sum_coll_1', async () => {
    await test_asset_sum_coll_1.test_asset_sum_coll_1.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_coll_1.test_asset_sum_coll_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_before = await test_asset_sum_coll_1.test_asset_sum_coll_1.get_res()
    assert(res_before.equals(new Int(0)))

    await test_asset_sum_coll_1.test_asset_sum_coll_1.exec({ as: alice })

    const my_asset_after = await test_asset_sum_coll_1.test_asset_sum_coll_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(2)))
    const res_after = await test_asset_sum_coll_1.test_asset_sum_coll_1.get_res()
    assert(res_after.equals(new Int(3)))
  })

  it('test_asset_sum_coll_2', async () => {
    await test_asset_sum_coll_2.test_asset_sum_coll_2.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_coll_2.test_asset_sum_coll_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_sum_coll_2.test_asset_sum_coll_2.get_res()
    assert(res_before.equals(new Int(0)))

    await test_asset_sum_coll_2.test_asset_sum_coll_2.exec({ as: alice })

    const my_asset_after = await test_asset_sum_coll_2.test_asset_sum_coll_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_sum_coll_2.test_asset_sum_coll_2.get_res()
    assert(res_after.equals(new Int(3)))
  })

  it('test_asset_sum_coll_rat', async () => {
    await test_asset_sum_coll_rat.test_asset_sum_coll_rat.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_coll_rat.test_asset_sum_coll_rat.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Rational(0.0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Rational(0.1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Rational(0.2)))
    const res_before = await test_asset_sum_coll_rat.test_asset_sum_coll_rat.get_res()
    assert(res_before.equals(new Rational(0)))

    await test_asset_sum_coll_rat.test_asset_sum_coll_rat.exec({ as: alice })

    const my_asset_after = await test_asset_sum_coll_rat.test_asset_sum_coll_rat.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Rational(0.0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Rational(0.1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Rational(0.2)))
    const res_after = await test_asset_sum_coll_rat.test_asset_sum_coll_rat.get_res()
    assert(res_after.equals(new Rational(0.3)))
  })

  it('test_asset_sum_view_0', async () => {
    await test_asset_sum_view_0.test_asset_sum_view_0.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_view_0.test_asset_sum_view_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_sum_view_0.test_asset_sum_view_0.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_asset_sum_view_0.test_asset_sum_view_0.exec({ as: alice })

    const my_asset_after = await test_asset_sum_view_0.test_asset_sum_view_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_sum_view_0.test_asset_sum_view_0.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('test_asset_sum_view_1', async () => {
    await test_asset_sum_view_1.test_asset_sum_view_1.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_view_1.test_asset_sum_view_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_before = await test_asset_sum_view_1.test_asset_sum_view_1.get_res()
    assert(res_before.equals(new Int(0)))

    await test_asset_sum_view_1.test_asset_sum_view_1.exec({ as: alice })

    const my_asset_after = await test_asset_sum_view_1.test_asset_sum_view_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(2)))
    const res_after = await test_asset_sum_view_1.test_asset_sum_view_1.get_res()
    assert(res_after.equals(new Int(3)))
  })

  it('test_asset_sum_view_2', async () => {
    await test_asset_sum_view_2.test_asset_sum_view_2.deploy({ as: alice })

    const my_asset_before = await test_asset_sum_view_2.test_asset_sum_view_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_sum_view_2.test_asset_sum_view_2.get_res()
    assert(res_before.equals(new Int(0)))

    await test_asset_sum_view_2.test_asset_sum_view_2.exec({ as: alice })

    const my_asset_after = await test_asset_sum_view_2.test_asset_sum_view_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_sum_view_2.test_asset_sum_view_2.get_res()
    assert(res_after.equals(new Int(3)))
  })

  it('test_asset_tail_agg_0', async () => {
    await test_asset_tail_agg_0.test_asset_tail_agg_0.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_agg_0.test_asset_tail_agg_0.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_tail_agg_0.test_asset_tail_agg_0.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_tail_agg_0.test_asset_tail_agg_0.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_agg_0.test_asset_tail_agg_0.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_agg_0.test_asset_tail_agg_0.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_tail_agg_0.test_asset_tail_agg_0.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_tail_agg_0.test_asset_tail_agg_0.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_tail_agg_1', async () => {
    await test_asset_tail_agg_1.test_asset_tail_agg_1.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_agg_1.test_asset_tail_agg_1.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_tail_agg_1.test_asset_tail_agg_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1] == "mystr0")
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1] == "mystr1")
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_tail_agg_1.test_asset_tail_agg_1.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_agg_1.test_asset_tail_agg_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_agg_1.test_asset_tail_agg_1.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_tail_agg_1.test_asset_tail_agg_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1] == "mystr0")
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1] == "mystr1")
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_tail_agg_1.test_asset_tail_agg_1.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_tail_agg_2', async () => {
    await test_asset_tail_agg_2.test_asset_tail_agg_2.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_agg_2.test_asset_tail_agg_2.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_asset_tail_agg_2.test_asset_tail_agg_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1].s == "mystr0")
    assert(o_asset_before[0][1].b == true)
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1].s == "mystr1")
    assert(o_asset_before[1][1].b == true)
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1].s == "mystr2")
    assert(o_asset_before[2][1].b == true)
    const res_before = await test_asset_tail_agg_2.test_asset_tail_agg_2.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_agg_2.test_asset_tail_agg_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_agg_2.test_asset_tail_agg_2.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    const o_asset_after = await test_asset_tail_agg_2.test_asset_tail_agg_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1].s == "mystr0")
    assert(o_asset_after[0][1].b == true)
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1].s == "mystr1")
    assert(o_asset_after[1][1].b == true)
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1].s == "mystr2")
    assert(o_asset_after[2][1].b == true)
    const res_after = await test_asset_tail_agg_2.test_asset_tail_agg_2.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_tail_coll_0', async () => {
    await test_asset_tail_coll_0.test_asset_tail_coll_0.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_coll_0.test_asset_tail_coll_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_tail_coll_0.test_asset_tail_coll_0.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_coll_0.test_asset_tail_coll_0.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_coll_0.test_asset_tail_coll_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_tail_coll_0.test_asset_tail_coll_0.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_tail_coll_1', async () => {
    await test_asset_tail_coll_1.test_asset_tail_coll_1.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_coll_1.test_asset_tail_coll_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_tail_coll_1.test_asset_tail_coll_1.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_coll_1.test_asset_tail_coll_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_coll_1.test_asset_tail_coll_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_tail_coll_1.test_asset_tail_coll_1.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_tail_coll_2', async () => {
    await test_asset_tail_coll_2.test_asset_tail_coll_2.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_coll_2.test_asset_tail_coll_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_tail_coll_2.test_asset_tail_coll_2.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_coll_2.test_asset_tail_coll_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_coll_2.test_asset_tail_coll_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_tail_coll_2.test_asset_tail_coll_2.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_tail_view_0', async () => {
    await test_asset_tail_view_0.test_asset_tail_view_0.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_view_0.test_asset_tail_view_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    const res_before = await test_asset_tail_view_0.test_asset_tail_view_0.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_view_0.test_asset_tail_view_0.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_view_0.test_asset_tail_view_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    const res_after = await test_asset_tail_view_0.test_asset_tail_view_0.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_tail_view_1', async () => {
    await test_asset_tail_view_1.test_asset_tail_view_1.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_view_1.test_asset_tail_view_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    const res_before = await test_asset_tail_view_1.test_asset_tail_view_1.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_view_1.test_asset_tail_view_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_view_1.test_asset_tail_view_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "mystr0")
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1] == "mystr1")
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1] == "mystr2")
    const res_after = await test_asset_tail_view_1.test_asset_tail_view_1.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_tail_view_2', async () => {
    await test_asset_tail_view_2.test_asset_tail_view_2.deploy({ as: alice })

    const my_asset_before = await test_asset_tail_view_2.test_asset_tail_view_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == true)
    const res_before = await test_asset_tail_view_2.test_asset_tail_view_2.get_res()
    assert(res_before.length == 0)

    await test_asset_tail_view_2.test_asset_tail_view_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_tail_view_2.test_asset_tail_view_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1].s == "mystr0")
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0].equals(new Nat(1)))
    assert(my_asset_after[1][1].s == "mystr1")
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0].equals(new Nat(2)))
    assert(my_asset_after[2][1].s == "mystr2")
    assert(my_asset_after[2][1].b == true)
    const res_after = await test_asset_tail_view_2.test_asset_tail_view_2.get_res()
    assert(res_after.length == 2)
    assert(res_after[0].equals(new Nat(1)))
    assert(res_after[1].equals(new Nat(2)))
  })

  it('test_asset_update', async () => {
    await test_asset_update.test_asset_update.deploy({ as: alice })

    const my_asset_before = await test_asset_update.test_asset_update.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(2)))

    await test_asset_update.test_asset_update.exec(new Nat(4), { as: alice })

    const my_asset_after = await test_asset_update.test_asset_update.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(4)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(2)))
  })

  it('test_asset_update_2', async () => {
    await test_asset_update_2.test_asset_update_2.deploy({ as: alice })

    const my_asset_before = await test_asset_update_2.test_asset_update_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Nat(0)))
    assert(my_asset_before[0][1].b == true)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Nat(1)))
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Nat(2)))
    assert(my_asset_before[2][1].b == true)

    await test_asset_update_2.test_asset_update_2.exec(new Nat(4), { as: alice })

    const my_asset_after = await test_asset_update_2.test_asset_update_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Nat(0)))
    assert(my_asset_after[0][1].b == true)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Nat(4)))
    assert(my_asset_after[1][1].b == true)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Nat(2)))
    assert(my_asset_after[2][1].b == true)
  })

  it('test_asset_update_3', async () => {
    await test_asset_update_3.test_asset_update_3.deploy({ as: alice })

    const my_asset_before = await test_asset_update_3.test_asset_update_3.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].v1 == false)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].v1 == false)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].v1 == false)

    await test_asset_update_3.test_asset_update_3.exec(new Nat(4), { as: alice })

    const my_asset_after = await test_asset_update_3.test_asset_update_3.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].v1 == false)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(4)))
    assert(my_asset_after[1][1].v1 == true)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].v1 == false)
  })

  it('test_asset_update_4', async () => {
    await test_asset_update_4.test_asset_update_4.deploy({ as: alice })

    const my_asset_before = await test_asset_update_4.test_asset_update_4.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].v1 == false)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].v1 == false)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].v1 == false)

    await test_asset_update_4.test_asset_update_4.exec(new Nat(4), true, { as: alice })

    const my_asset_after = await test_asset_update_4.test_asset_update_4.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].v1 == false)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(4)))
    assert(my_asset_after[1][1].v1 == true)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].v1 == false)
  })

  it('test_asset_update_5', async () => {
    await test_asset_update_5.test_asset_update_5.deploy({ as: alice })

    const my_asset_before = await test_asset_update_5.test_asset_update_5.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].v1 == false)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].v1 == false)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].v1 == false)

    await test_asset_update_5.test_asset_update_5.exec({ as: alice })

    const my_asset_after = await test_asset_update_5.test_asset_update_5.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].v1 == false)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(2)))
    assert(my_asset_after[1][1].v1 == false)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].v1 == false)
  })

  it('test_asset_update_aggregate_1', async () => {
    await test_asset_update_aggregate_1.test_asset_update_aggregate_1.deploy({ as: alice })

    const my_asset_before = await test_asset_update_aggregate_1.test_asset_update_aggregate_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_aggregate_1.test_asset_update_aggregate_1.get_o_asset()
    assert(o_asset_before.length == 5)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    assert(o_asset_before[3].equals(new Nat(3)))
    assert(o_asset_before[4].equals(new Nat(4)))

    await test_asset_update_aggregate_1.test_asset_update_aggregate_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_aggregate_1.test_asset_update_aggregate_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(1)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_aggregate_1.test_asset_update_aggregate_1.get_o_asset()
    assert(o_asset_after.length == 5)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
    assert(o_asset_after[4].equals(new Nat(4)))
  })

  it('test_asset_update_aggregate_2', async () => {
    await test_asset_update_aggregate_2.test_asset_update_aggregate_2.deploy({ as: alice })

    const my_asset_before = await test_asset_update_aggregate_2.test_asset_update_aggregate_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 1)
    assert(my_asset_before[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_aggregate_2.test_asset_update_aggregate_2.get_o_asset()
    assert(o_asset_before.length == 5)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    assert(o_asset_before[3].equals(new Nat(3)))
    assert(o_asset_before[4].equals(new Nat(4)))

    await test_asset_update_aggregate_2.test_asset_update_aggregate_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_aggregate_2.test_asset_update_aggregate_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 3)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(1)))
    assert(my_asset_after[1][1].c[2].equals(new Nat(2)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_aggregate_2.test_asset_update_aggregate_2.get_o_asset()
    assert(o_asset_after.length == 5)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
    assert(o_asset_after[4].equals(new Nat(4)))
  })

  it('test_asset_update_aggregate_3', async () => {
    await test_asset_update_aggregate_3.test_asset_update_aggregate_3.deploy({ as: alice })

    const my_asset_before = await test_asset_update_aggregate_3.test_asset_update_aggregate_3.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[1].equals(new Nat(1)))
    assert(my_asset_before[1][1].c[2].equals(new Nat(2)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_aggregate_3.test_asset_update_aggregate_3.get_o_asset()
    assert(o_asset_before.length == 5)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    assert(o_asset_before[3].equals(new Nat(3)))
    assert(o_asset_before[4].equals(new Nat(4)))

    await test_asset_update_aggregate_3.test_asset_update_aggregate_3.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_aggregate_3.test_asset_update_aggregate_3.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 1)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_aggregate_3.test_asset_update_aggregate_3.get_o_asset()
    assert(o_asset_after.length == 5)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
    assert(o_asset_after[4].equals(new Nat(4)))
  })

  it('test_asset_update_partition_1', async () => {
    await test_asset_update_partition_1.test_asset_update_partition_1.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_1.test_asset_update_partition_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_1.test_asset_update_partition_1.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_1.test_asset_update_partition_1.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_1.test_asset_update_partition_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(5)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_partition_1.test_asset_update_partition_1.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0].equals(new Nat(2)))
    assert(o_asset_after[1].equals(new Nat(5)))
  })

  it('test_asset_update_partition_2', async () => {
    await test_asset_update_partition_2.test_asset_update_partition_2.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_2.test_asset_update_partition_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_2.test_asset_update_partition_2.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_2.test_asset_update_partition_2.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_2.test_asset_update_partition_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(5)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_partition_2.test_asset_update_partition_2.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0].equals(new Nat(2)))
    assert(o_asset_after[1].equals(new Nat(5)))
  })

  it('test_asset_update_partition_3', async () => {
    await test_asset_update_partition_3.test_asset_update_partition_3.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_3.test_asset_update_partition_3.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[1].equals(new Nat(2)))
    assert(my_asset_before[1][1].c[2].equals(new Nat(5)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_3.test_asset_update_partition_3.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_3.test_asset_update_partition_3.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_3.test_asset_update_partition_3.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 1)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    // TODO: Bug
    // const o_asset_after = await test_asset_update_partition_3.test_asset_update_partition_3.get_o_asset()
    // assert(o_asset_after.length == 1)
    // assert(o_asset_after[0].equals(new Nat(0)))
  })

  it('test_asset_update_partition_4', async () => {
    await test_asset_update_partition_4.test_asset_update_partition_4.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_4.test_asset_update_partition_4.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_4.test_asset_update_partition_4.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_4.test_asset_update_partition_4.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_4.test_asset_update_partition_4.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(5)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_partition_4.test_asset_update_partition_4.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0][0].equals(new Nat(2)))
    assert(o_asset_after[0][1] == "strn")
    assert(o_asset_after[1][0].equals(new Nat(5)))
    assert(o_asset_after[1][1] == "str5")
  })

  it('test_asset_update_partition_5', async () => {
    await test_asset_update_partition_5.test_asset_update_partition_5.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_5.test_asset_update_partition_5.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_5.test_asset_update_partition_5.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_5.test_asset_update_partition_5.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_5.test_asset_update_partition_5.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(5)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_partition_5.test_asset_update_partition_5.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0][0].equals(new Nat(2)))
    assert(o_asset_after[0][1] == "strn")
    assert(o_asset_after[1][0].equals(new Nat(5)))
    assert(o_asset_after[1][1] == "str5")
  })

  it('test_asset_update_partition_6', async () => {
    await test_asset_update_partition_6.test_asset_update_partition_6.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_6.test_asset_update_partition_6.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[1].equals(new Nat(2)))
    assert(my_asset_before[1][1].c[2].equals(new Nat(5)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_6.test_asset_update_partition_6.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_6.test_asset_update_partition_6.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_6.test_asset_update_partition_6.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 1)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    // TODO: Bug
    // const o_asset_after = await test_asset_update_partition_3.test_asset_update_partition_3.get_o_asset()
    // assert(o_asset_after.length == 1)
    // assert(o_asset_after[0].equals(new Nat(0)))
  })

  it('test_asset_update_partition_7', async () => {
    await test_asset_update_partition_7.test_asset_update_partition_7.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_7.test_asset_update_partition_7.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_7.test_asset_update_partition_7.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_7.test_asset_update_partition_7.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_7.test_asset_update_partition_7.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(5)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_partition_7.test_asset_update_partition_7.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0][0].equals(new Nat(2)))
    assert(o_asset_after[0][1].v == "strn")
    assert(o_asset_after[0][1].i.equals(new Int(0)))
    assert(o_asset_after[1][0].equals(new Nat(5)))
    assert(o_asset_after[1][1].v == "str5")
    assert(o_asset_after[1][1].i.equals(new Int(5)))
  })

  it('test_asset_update_partition_8', async () => {
    await test_asset_update_partition_8.test_asset_update_partition_8.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_8.test_asset_update_partition_8.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_8.test_asset_update_partition_8.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_8.test_asset_update_partition_8.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_8.test_asset_update_partition_8.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 2)
    assert(my_asset_after[1][1].c[0].equals(new Nat(2)))
    assert(my_asset_after[1][1].c[1].equals(new Nat(5)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    const o_asset_after = await test_asset_update_partition_8.test_asset_update_partition_8.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0][0].equals(new Nat(2)))
    assert(o_asset_after[0][1].v == "strn")
    assert(o_asset_after[0][1].i.equals(new Int(0)))
    assert(o_asset_after[1][0].equals(new Nat(5)))
    assert(o_asset_after[1][1].v == "str5")
    assert(o_asset_after[1][1].i.equals(new Int(5)))
  })

  it('test_asset_update_partition_9', async () => {
    await test_asset_update_partition_9.test_asset_update_partition_9.deploy({ as: alice })

    const my_asset_before = await test_asset_update_partition_9.test_asset_update_partition_9.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v0.equals(new Nat(0)))
    assert(my_asset_before[0][1].c.length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v0.equals(new Nat(1)))
    assert(my_asset_before[1][1].c.length == 3)
    assert(my_asset_before[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_before[1][1].c[1].equals(new Nat(2)))
    assert(my_asset_before[1][1].c[2].equals(new Nat(5)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v0.equals(new Nat(2)))
    assert(my_asset_before[2][1].c.length == 0)
    const o_asset_before = await test_asset_update_partition_9.test_asset_update_partition_9.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_asset_update_partition_9.test_asset_update_partition_9.exec(new Nat(2), { as: alice })

    const my_asset_after = await test_asset_update_partition_9.test_asset_update_partition_9.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v0.equals(new Nat(0)))
    assert(my_asset_after[0][1].c.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v0.equals(new Nat(1)))
    assert(my_asset_after[1][1].c.length == 1)
    assert(my_asset_after[1][1].c[0].equals(new Nat(0)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v0.equals(new Nat(2)))
    assert(my_asset_after[2][1].c.length == 0)
    // TODO: Bug
    // const o_asset_after = await test_asset_update_partition_3.test_asset_update_partition_3.get_o_asset()
    // assert(o_asset_after.length == 1)
    // assert(o_asset_after[0].equals(new Nat(0)))
  })

  it('test_asset_view', async () => {
    await test_asset_view.test_asset_view.deploy({ as: alice })

    const my_asset_before = await test_asset_view.test_asset_view.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_before = await test_asset_view.test_asset_view.get_res()
    assert(res_before.length == 0)

    await test_asset_view.test_asset_view.exec({ as: alice })

    const my_asset_after = await test_asset_view.test_asset_view.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(2)))
    const res_after = await test_asset_view.test_asset_view.get_res()
    assert(res_after.length == 2)
    assert(res_after[0] == "id1")
    assert(res_after[1] == "id2")
  })

  it('test_bound_value', async () => {
    await test_bound_value.test_bound_value.deploy({ as: alice })

    const x_before = await test_bound_value.test_bound_value.get_x()
    assert(x_before.equals(new Int(1)))

    await test_bound_value.test_bound_value.exec({ as: alice })

    const x_after = await test_bound_value.test_bound_value.get_x()
    assert(x_after.equals(new Int(0)))
  })

  it('test_caller_getter', async () => {
    await test_caller_getter.test_caller_getter.deploy({ as: alice })

    const res_before = await test_caller_getter.test_caller_getter.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_caller_getter.test_caller_getter.exec(test_caller_getter.test_caller_getter.get_address(), { as: alice })

    const res_after = await test_caller_getter.test_caller_getter.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('test_cmp_bool', async () => {
    await test_cmp_bool.test_cmp_bool.deploy({ as: alice })

    await test_cmp_bool.test_cmp_bool.exec({ as: alice })
  })

  it('test_complex_sum', async () => {
    await test_complex_sum.test_complex_sum.deploy({ as: alice })

    const my_asset_before = await test_complex_sum.test_complex_sum.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].v1.equals(new Int(0)))
    assert(my_asset_before[0][1].v2.equals(new Int(3)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].v1.equals(new Int(1)))
    assert(my_asset_before[1][1].v2.equals(new Int(3)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].v1.equals(new Int(2)))
    assert(my_asset_before[2][1].v2.equals(new Int(3)))
    const res_before = await test_complex_sum.test_complex_sum.get_res()
    assert(res_before.equals(new Int(0)))

    await test_complex_sum.test_complex_sum.exec({ as: alice })

    const my_asset_after = await test_complex_sum.test_complex_sum.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].v1.equals(new Int(0)))
    assert(my_asset_after[0][1].v2.equals(new Int(3)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].v1.equals(new Int(1)))
    assert(my_asset_after[1][1].v2.equals(new Int(3)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].v1.equals(new Int(2)))
    assert(my_asset_after[2][1].v2.equals(new Int(3)))
    const res_after = await test_complex_sum.test_complex_sum.get_res()
    assert(res_after.equals(new Int(6)))
  })

  it('test_conditions', async () => {
    await test_conditions.test_conditions.deploy({ as: alice })

    const i_before = await test_conditions.test_conditions.get_i()
    assert(i_before.equals(new Int(0)))

    await test_conditions.test_conditions.a1({ as: alice })

    const i_1 = await test_conditions.test_conditions.get_i()
    assert(i_1.equals(new Int(0)))

    await test_conditions.test_conditions.a2({ as: alice })

    const i_after = await test_conditions.test_conditions.get_i()
    assert(i_after.equals(new Int(1)))
  })

  it('test_contains_get', async () => {
    await test_contains_get.test_contains_get.deploy({ as: alice })

    const my_asset_before = await test_contains_get.test_contains_get.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id1")
    assert(my_asset_before[0][1].equals(new Int(2)))
    const res_before = await test_contains_get.test_contains_get.get_res()
    assert(res_before.equals(new Int(0)))

    await test_contains_get.test_contains_get.exec({ as: alice })

    const my_asset_after = await test_contains_get.test_contains_get.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id1")
    assert(my_asset_after[0][1].equals(new Int(2)))
    const res_after = await test_contains_get.test_contains_get.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('test_contract', async () => {
    await test_contract.test_contract.deploy({ amount: new Tez(1), as: alice })

    await test_contract.test_contract.exec(test_contract.test_contract.get_address(), { as: alice })
  })

  it('test_contract_self', async () => {
    await test_contract_self.test_contract_self.deploy({ as: alice })

    const res_before = await test_contract_self.test_contract_self.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_contract_self.test_contract_self.exec({ as: alice })

    const res_after = await test_contract_self.test_contract_self.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('test_create_contract_arl', async () => {
    await test_create_contract_arl.test_create_contract_arl.deploy({ as: alice })

    await test_create_contract_arl.test_create_contract_arl.exec({ as: alice })
  })

  it('test_create_contract_arl_fa1', async () => {
    await test_create_contract_arl_fa1.test_create_contract_arl_fa1.deploy({ as: alice })
  })

  it('test_create_contract_arl_fa2', async () => {
    await test_create_contract_arl_fa2.test_create_contract_arl_fa2.deploy({ as: alice })
  })

  it('test_create_contract_arl_string', async () => {
    await test_create_contract_arl_string.test_create_contract_arl_string.deploy({ as: alice })

    await test_create_contract_arl_string.test_create_contract_arl_string.exec({ as: alice })
  })

  it('test_create_contract_arl_with_param', async () => {
    await test_create_contract_arl_with_param.test_create_contract_arl_with_param.deploy({ as: alice })

    await test_create_contract_arl_with_param.test_create_contract_arl_with_param.exec({ as: alice })
  })

  it('test_create_contract_arl_with_param_const', async () => {
    await test_create_contract_arl_with_param_const.test_create_contract_arl_with_param_const.deploy({ as: alice })

    await test_create_contract_arl_with_param_const.test_create_contract_arl_with_param_const.exec({ as: alice })
  })

  it('test_create_contract_arl_with_param_with_default', async () => {
    await test_create_contract_arl_with_param_with_default.test_create_contract_arl_with_param_with_default.deploy({ as: alice })

    await test_create_contract_arl_with_param_with_default.test_create_contract_arl_with_param_with_default.exec({ as: alice })
  })

  it('test_create_contract_bytes', async () => {
    await test_create_contract_bytes.test_create_contract_bytes.deploy({ as: alice })

    await test_create_contract_bytes.test_create_contract_bytes.exec({ as: alice })
  })

  it('test_create_contract_inline', async () => {
    await test_create_contract_inline.test_create_contract_inline.deploy({ as: alice })

    await test_create_contract_inline.test_create_contract_inline.exec({ as: alice })
  })

  it('test_create_contract_tz_with_import', async () => {
    await test_create_contract_tz_with_import.test_create_contract_tz_with_import.deploy({ as: alice })

    await test_create_contract_tz_with_import.test_create_contract_tz_with_import.exec({ as: alice })
  })

  it('test_create_contract_tz_with_path', async () => {
    await test_create_contract_tz_with_path.test_create_contract_tz_with_path.deploy({ as: alice })

    await test_create_contract_tz_with_path.test_create_contract_tz_with_path.exec({ as: alice })
  })

  it('test_fget', async () => {
    await test_fget.test_fget.deploy({ as: alice })

    const owner_before = await test_fget.test_fget.get_owner()
    assert(owner_before.length == 0)
    const mile_before = await test_fget.test_fget.get_mile()
    assert(mile_before.length == 0)

    await test_fget.test_fget.deploy({ as: alice })

    const owner_after = await test_fget.test_fget.get_owner()
    assert(owner_after.length == 0)
    const mile_after = await test_fget.test_fget.get_mile()
    assert(mile_after.length == 0)
  })

  it('test_for_list_alt', async () => {
    await test_for_list_alt.test_for_list_alt.deploy({ as: alice })

    const res_before = await test_for_list_alt.test_for_list_alt.get_res()
    assert(res_before.equals(new Int(0)))

    await test_for_list_alt.test_for_list_alt.exec({ as: alice })

    const res_after = await test_for_list_alt.test_for_list_alt.get_res()
    assert(res_after.equals(new Int(6)))
  })

  it('test_fun0', async () => {
    await test_fun0.test_fun0.deploy({ as: alice })

    const res_before = await test_fun0.test_fun0.get_res()
    assert(res_before.equals(new Rational(0)))

    await test_fun0.test_fun0.exec(new Rational(2), { as: alice })

    const res_after = await test_fun0.test_fun0.get_res()
    assert(res_after.equals(new Rational(1)))
  })

  it('test_fun1', async () => {
    await test_fun1.test_fun1.deploy({ as: alice })

    const res_before = await test_fun1.test_fun1.get_res()
    assert(res_before == false)

    await test_fun1.test_fun1.e({ as: alice })

    const res_after = await test_fun1.test_fun1.get_res()
    assert(res_after == true)
  })

  it('test_fun2', async () => {
    await test_fun2.test_fun2.deploy({ as: alice })

    const res_before = await test_fun2.test_fun2.get_res()
    assert(res_before.equals(new Rational(0)))

    await test_fun2.test_fun2.e({ as: alice })

    const res_after = await test_fun2.test_fun2.get_res()
    assert(res_after.equals(new Rational(0.15)))
  })

  it('test_fun3', async () => {
    await test_fun3.test_fun3.deploy({ as: alice })

    const res_before = await test_fun3.test_fun3.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_fun3.test_fun3.e({ as: alice })

    const res_after = await test_fun3.test_fun3.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('test_fun4', async () => {
    await test_fun4.test_fun4.deploy({ as: alice })

    const res_before = await test_fun4.test_fun4.get_res()
    assert(res_before.equals(new Rational(0)))

    await test_fun4.test_fun4.e({ as: alice })

    const res_after = await test_fun4.test_fun4.get_res()
    assert(res_after.equals(new Rational(0.15)))
  })

  it('test_fun5', async () => {
    await test_fun5.test_fun5.deploy({ as: alice })

    const res_before = await test_fun5.test_fun5.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_fun5.test_fun5.e({ as: alice })

    const res_after = await test_fun5.test_fun5.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('test_fun6', async () => {
    await test_fun6.test_fun6.deploy({ as: alice })

    const res_before = await test_fun6.test_fun6.get_res()
    assert(res_before.equals(new Rational(0)))

    await test_fun6.test_fun6.e({ as: alice })

    const res_after = await test_fun6.test_fun6.get_res()
    assert(res_after.equals(new Rational(0.15)))
  })

  it('test_fun7', async () => {
    await test_fun7.test_fun7.deploy({ as: alice })

    const res_before = await test_fun7.test_fun7.get_res()
    assert(res_before.equals(new Nat(0)))
    const i_before = await test_fun7.test_fun7.get_i()
    assert(i_before.equals(new Int(2)))

    await test_fun7.test_fun7.e({ as: alice })

    const res_after = await test_fun7.test_fun7.get_res()
    assert(res_after.equals(new Nat(3)))
    const i_after = await test_fun7.test_fun7.get_i()
    assert(i_after.equals(new Int(2)))
  })

  it('test_fun8', async () => {
    await test_fun8.test_fun8.deploy({ as: alice })

    const permissions_descriptor_before = await test_fun8.test_fun8.get_permissions_descriptor()
    assert(permissions_descriptor_before.equals(new test_fun8.permissions(new test_fun8.basic_permissions(new test_fun8.No_transfer(), new test_fun8.Owner_no_hook(), new test_fun8.Owner_no_hook()), Option.None())))

    await test_fun8.test_fun8.exec({ as: alice })

    const permissions_descriptor_after = await test_fun8.test_fun8.get_permissions_descriptor()
    assert(permissions_descriptor_after.equals(new test_fun8.permissions(new test_fun8.basic_permissions(new test_fun8.No_transfer(), new test_fun8.Owner_no_hook(), new test_fun8.Owner_no_hook()), Option.None())))
  })

  it('test_fun_asset', async () => {
    await test_fun_asset.test_fun_asset.deploy({ as: alice })

    const my_asset_before = await test_fun_asset.test_fun_asset.get_my_asset()
    assert(my_asset_before.length == 4)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    assert(my_asset_before[3].equals(new Nat(3)))
    const res_before = await test_fun_asset.test_fun_asset.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_fun_asset.test_fun_asset.exec({ as: alice })

    const my_asset_after = await test_fun_asset.test_fun_asset.get_my_asset()
    assert(my_asset_after.length == 4)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    assert(my_asset_after[3].equals(new Nat(3)))
    const res_after = await test_fun_asset.test_fun_asset.get_res()
    assert(res_after.equals(new Nat(4)))
  })

  it('test_fun_asset2', async () => {
    await test_fun_asset2.test_fun_asset2.deploy({ as: alice })

    const my_asset_before = await test_fun_asset2.test_fun_asset2.get_my_asset()
    assert(my_asset_before.length == 4)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    assert(my_asset_before[3].equals(new Nat(3)))
    const r_before = await test_fun_asset2.test_fun_asset2.get_r()
    assert(r_before.equals(new test_fun_asset2.rt(new Nat(0), new Int(1))))
    const res_before = await test_fun_asset2.test_fun_asset2.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_fun_asset2.test_fun_asset2.exec({ as: alice })

    const my_asset_after = await test_fun_asset2.test_fun_asset2.get_my_asset()
    assert(my_asset_after.length == 4)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
    assert(my_asset_after[3].equals(new Nat(3)))
    const r_after = await test_fun_asset2.test_fun_asset2.get_r()
    assert(r_after.equals(new test_fun_asset2.rt(new Nat(0), new Int(1))))
    const res_after = await test_fun_asset2.test_fun_asset2.get_res()
    assert(res_after.equals(new Nat(4)))
  })

  it('test_fun_fail', async () => {
    await test_fun_fail.test_fun_fail.deploy({ as: alice })

    await expect_to_fail(async () => {
      await test_fun_fail.test_fun_fail.exec({ as: alice })
    }, { string: "error" })
  })

  it('test_getter', async () => {
    await test_getter.test_getter.deploy({ as: alice })

    const n_before = await test_getter.test_getter.get_n();
    assert(n_before.equals(new Nat(2)))

    const n = await test_getter.test_getter.getN({ as: alice });
    assert(n.equals(new Nat(2)))

    const n_after = await test_getter.test_getter.get_n();
    assert(n_after.equals(new Nat(2)))
  })

  it('test_getter2', async () => {
    await test_getter2.test_getter2.deploy({ as: alice })

    const n_before = await test_getter2.test_getter2.get_n();
    assert(n_before.equals(new Nat(2)))

    await test_getter2.test_getter2.a({ as: alice })

    const n = await test_getter2.test_getter2.getN({ as: alice });
    assert(n.equals(new Nat(2)))

    const n_after = await test_getter2.test_getter2.get_n();
    assert(n_after.equals(new Nat(2)))
  })

  it('test_getter_with_arg', async () => {
    await test_getter_with_arg.test_getter_with_arg.deploy({ as: alice })

    const s = await test_getter_with_arg.test_getter_with_arg.getArg("mystr", { as: alice });
    assert(s == "mystr")
  })

  it('test_getter_with_args', async () => {
    await test_getter_with_args.test_getter_with_args.deploy({ as: alice })

    const n = await test_getter_with_args.test_getter_with_args.getSum(new Nat(1), new Nat(2), { as: alice });
    assert(n.equals(new Nat(3)))
  })

  it('test_global_constant', async () => {
    await register_global_constant(new Nat(2).to_mich(), { as: alice })
    await test_global_constant.test_global_constant.deploy({ as: alice })

    const res_before = await test_global_constant.test_global_constant.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_global_constant.test_global_constant.exec({ as: alice })

    const res_after = await test_global_constant.test_global_constant.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('test_if_fail_expr', async () => {
    await test_if_fail_expr.test_if_fail_expr.deploy({ as: alice })

    const res_before = await test_if_fail_expr.test_if_fail_expr.get_res()
    assert(res_before.equals(new Nat(0)))

    await expect_to_fail(async () => {
      await test_if_fail_expr.test_if_fail_expr.exec(Option.None(), { as: alice })
    }, { string: "error" })

    await test_if_fail_expr.test_if_fail_expr.exec(Option.Some(new Nat(2)), { as: alice })

    const res_after = await test_if_fail_expr.test_if_fail_expr.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('test_if_int_nat', async () => {
    await test_if_int_nat.test_if_int_nat.deploy({ as: alice })

    const res_before = await test_if_int_nat.test_if_int_nat.get_res()
    assert(res_before.equals(new Int(0)))

    await test_if_int_nat.test_if_int_nat.exec(new Nat(2), new Int(1), { as: alice })

    const res_after = await test_if_int_nat.test_if_int_nat.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('test_init_asset', async () => {
    await test_init_asset.test_init_asset.deploy({ as: alice })

    const my_asset_before = await test_init_asset.test_init_asset.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "my_id")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].myaggregate.length == 0)
    const o_asset_before = await test_init_asset.test_init_asset.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_init_asset.test_init_asset.exec({ as: alice })

    const my_asset_after = await test_init_asset.test_init_asset.get_my_asset()
    assert(my_asset_after.length == 0)
    const o_asset_after = await test_init_asset.test_init_asset.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('test_init_asset2', async () => {
    await test_init_asset2.test_init_asset2.deploy({ as: alice })

    const my_asset_before = await test_init_asset2.test_init_asset2.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Address("tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg")))
    assert(my_asset_before[0][1].equals(new Int(1000000)))
  })

  it('test_init_asset3', async () => {
    await test_init_asset3.test_init_asset3.deploy({ as: alice })

    const my_asset_before = await test_init_asset3.test_init_asset3.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].equals(new Int(1000000)))
  })

  it('test_init_rat_with_nat', async () => {
    await test_init_rat_with_nat.test_init_rat_with_nat.deploy({ as: alice })

    const res = await test_init_rat_with_nat.test_init_rat_with_nat.get_res()
    assert(res.equals(new Rational(0)))
  })

  it('test_init_storage_arith', async () => {
    await test_init_storage_arith.test_init_storage_arith.deploy({ as: alice })

    const bool_bool_and = await test_init_storage_arith.test_init_storage_arith.get_bool_bool_and()
    assert(bool_bool_and == false)
    const bool_bool_or = await test_init_storage_arith.test_init_storage_arith.get_bool_bool_or()
    assert(bool_bool_or == true)
    const bool_bool_not = await test_init_storage_arith.test_init_storage_arith.get_bool_bool_not()
    assert(bool_bool_not == false)
    const nat_nat_plus = await test_init_storage_arith.test_init_storage_arith.get_nat_nat_plus()
    assert(nat_nat_plus.equals(new Nat(3)))
    const nat_nat_minus = await test_init_storage_arith.test_init_storage_arith.get_nat_nat_minus()
    assert(nat_nat_minus.equals(new Int(-1)))
    const nat_nat_mult = await test_init_storage_arith.test_init_storage_arith.get_nat_nat_mult()
    assert(nat_nat_mult.equals(new Nat(2)))
    const nat_nat_ediv = await test_init_storage_arith.test_init_storage_arith.get_nat_nat_ediv()
    assert(nat_nat_ediv.equals(new Nat(0)))
    const nat_nat_modulo = await test_init_storage_arith.test_init_storage_arith.get_nat_nat_modulo()
    assert(nat_nat_modulo.equals(new Nat(1)))
    const int_int_plus = await test_init_storage_arith.test_init_storage_arith.get_int_int_plus()
    assert(int_int_plus.equals(new Int(3)))
    const int_int_minus = await test_init_storage_arith.test_init_storage_arith.get_int_int_minus()
    assert(int_int_minus.equals(new Int(-1)))
    const int_int_mult = await test_init_storage_arith.test_init_storage_arith.get_int_int_mult()
    assert(int_int_mult.equals(new Int(2)))
    const int_int_ediv = await test_init_storage_arith.test_init_storage_arith.get_int_int_ediv()
    assert(int_int_ediv.equals(new Int(0)))
    const int_int_modulo = await test_init_storage_arith.test_init_storage_arith.get_int_int_modulo()
    assert(int_int_modulo.equals(new Nat(1)))
    const rat_rat_plus = await test_init_storage_arith.test_init_storage_arith.get_rat_rat_plus()
    assert(rat_rat_plus.equals(new Rational(2.3)))
    const rat_rat_minus = await test_init_storage_arith.test_init_storage_arith.get_rat_rat_minus()
    assert(rat_rat_minus.equals(new Rational(-0.1)))
    const rat_rat_mult = await test_init_storage_arith.test_init_storage_arith.get_rat_rat_mult()
    assert(rat_rat_mult.equals(new Rational(1.32)))
    const rat_rat_div = await test_init_storage_arith.test_init_storage_arith.get_rat_rat_div()
    assert(rat_rat_div.equals(new Rational(1.1, new BigNumber(1.2))))
    const int_rat_plus = await test_init_storage_arith.test_init_storage_arith.get_int_rat_plus()
    assert(int_rat_plus.equals(new Rational(2.2)))
    const int_rat_minus = await test_init_storage_arith.test_init_storage_arith.get_int_rat_minus()
    assert(int_rat_minus.equals(new Rational(-0.2)))
    const int_rat_mult = await test_init_storage_arith.test_init_storage_arith.get_int_rat_mult()
    assert(int_rat_mult.equals(new Rational(1.2)))
    const int_rat_div = await test_init_storage_arith.test_init_storage_arith.get_int_rat_div()
    assert(int_rat_div.equals(new Rational(1, new BigNumber(1.2))))
    const rat_int_plus = await test_init_storage_arith.test_init_storage_arith.get_rat_int_plus()
    assert(rat_int_plus.equals(new Rational(3.1)))
    const rat_int_minus = await test_init_storage_arith.test_init_storage_arith.get_rat_int_minus()
    assert(rat_int_minus.equals(new Rational(-0.9)))
    const rat_int_mult = await test_init_storage_arith.test_init_storage_arith.get_rat_int_mult()
    assert(rat_int_mult.equals(new Rational(2.2)))
    const rat_int_div = await test_init_storage_arith.test_init_storage_arith.get_rat_int_div()
    assert(rat_int_div.equals(new Rational(1.1, new BigNumber(2))))
    const date_date_minus = await test_init_storage_arith.test_init_storage_arith.get_date_date_minus()
    assert(date_date_minus.equals(new Duration("1d")))
    const dur_dur_plus = await test_init_storage_arith.test_init_storage_arith.get_dur_dur_plus()
    assert(dur_dur_plus.equals(new Duration("1h2s")))
    const dur_dur_minus = await test_init_storage_arith.test_init_storage_arith.get_dur_dur_minus()
    assert(dur_dur_minus.equals(new Duration("59m58s")))
    const dur_dur_div = await test_init_storage_arith.test_init_storage_arith.get_dur_dur_div()
    assert(dur_dur_div.equals(new Rational(8)))
    const dur_dur_ediv = await test_init_storage_arith.test_init_storage_arith.get_dur_dur_ediv()
    assert(dur_dur_ediv.equals(new Int(8)))
    const int_dur_mult = await test_init_storage_arith.test_init_storage_arith.get_int_dur_mult()
    assert(int_dur_mult.equals(new Duration("2h")))
    const dur_int_ediv = await test_init_storage_arith.test_init_storage_arith.get_dur_int_ediv()
    assert(dur_int_ediv.equals(new Duration("30m")))
    const date_dur_plus = await test_init_storage_arith.test_init_storage_arith.get_date_dur_plus()
    assert(date_dur_plus.toISOString() == '2020-01-02T00:00:00.000Z')
    const date_dur_minus = await test_init_storage_arith.test_init_storage_arith.get_date_dur_minus()
    assert(date_dur_minus.toISOString() == '2019-12-31T00:00:00.000Z')
    const dur_date_plus = await test_init_storage_arith.test_init_storage_arith.get_dur_date_plus()
    assert(dur_date_plus.toISOString() == '2020-01-02T00:00:00.000Z')
    const str_str_plus = await test_init_storage_arith.test_init_storage_arith.get_str_str_plus()
    assert(str_str_plus == "str1str2")
    const tez_tez_plus = await test_init_storage_arith.test_init_storage_arith.get_tez_tez_plus()
    assert(tez_tez_plus.equals(new Tez(3)))
    const tez_tez_minus = await test_init_storage_arith.test_init_storage_arith.get_tez_tez_minus()
    assert(tez_tez_minus.equals(new Tez(1)))
    const int_tez_mult = await test_init_storage_arith.test_init_storage_arith.get_int_tez_mult()
    assert(int_tez_mult.equals(new Tez(2)))
    const rat_tez_mult = await test_init_storage_arith.test_init_storage_arith.get_rat_tez_mult()
    assert(rat_tez_mult.equals(new Tez(1.1)))
    const int_tez_ediv = await test_init_storage_arith.test_init_storage_arith.get_int_tez_ediv()
    assert(int_tez_ediv.equals(new Tez(0.5)))
  })

  it('test_init_storage_cmp', async () => {
    await test_init_storage_cmp.test_init_storage_cmp.deploy({ as: alice })

    const eq_int_int = await test_init_storage_cmp.test_init_storage_cmp.get_eq_int_int()
    assert(eq_int_int == false)
    const ne_int_int = await test_init_storage_cmp.test_init_storage_cmp.get_ne_int_int()
    assert(ne_int_int == true)
    const gt_int_int = await test_init_storage_cmp.test_init_storage_cmp.get_gt_int_int()
    assert(gt_int_int == true)
    const ge_int_int = await test_init_storage_cmp.test_init_storage_cmp.get_ge_int_int()
    assert(ge_int_int == true)
    const lt_int_int = await test_init_storage_cmp.test_init_storage_cmp.get_lt_int_int()
    assert(lt_int_int == false)
    const le_int_int = await test_init_storage_cmp.test_init_storage_cmp.get_le_int_int()
    assert(le_int_int == false)
    const eq_rat_int = await test_init_storage_cmp.test_init_storage_cmp.get_eq_rat_int()
    assert(eq_rat_int == false)
    const ne_rat_int = await test_init_storage_cmp.test_init_storage_cmp.get_ne_rat_int()
    assert(ne_rat_int == true)
    const gt_rat_int = await test_init_storage_cmp.test_init_storage_cmp.get_gt_rat_int()
    assert(gt_rat_int == true)
    const ge_rat_int = await test_init_storage_cmp.test_init_storage_cmp.get_ge_rat_int()
    assert(ge_rat_int == true)
    const lt_rat_int = await test_init_storage_cmp.test_init_storage_cmp.get_lt_rat_int()
    assert(lt_rat_int == false)
    const le_rat_int = await test_init_storage_cmp.test_init_storage_cmp.get_le_rat_int()
    assert(le_rat_int == false)
    const eq_int_rat = await test_init_storage_cmp.test_init_storage_cmp.get_eq_int_rat()
    assert(eq_int_rat == false)
    const ne_int_rat = await test_init_storage_cmp.test_init_storage_cmp.get_ne_int_rat()
    assert(ne_int_rat == true)
    const gt_int_rat = await test_init_storage_cmp.test_init_storage_cmp.get_gt_int_rat()
    assert(gt_int_rat == true)
    const ge_int_rat = await test_init_storage_cmp.test_init_storage_cmp.get_ge_int_rat()
    assert(ge_int_rat == true)
    const lt_int_rat = await test_init_storage_cmp.test_init_storage_cmp.get_lt_int_rat()
    assert(lt_int_rat == false)
    const le_int_rat = await test_init_storage_cmp.test_init_storage_cmp.get_le_int_rat()
    assert(le_int_rat == false)
    const eq_rat_rat = await test_init_storage_cmp.test_init_storage_cmp.get_eq_rat_rat()
    assert(eq_rat_rat == false)
    const ne_rat_rat = await test_init_storage_cmp.test_init_storage_cmp.get_ne_rat_rat()
    assert(ne_rat_rat == true)
    const gt_rat_rat = await test_init_storage_cmp.test_init_storage_cmp.get_gt_rat_rat()
    assert(gt_rat_rat == true)
    const ge_rat_rat = await test_init_storage_cmp.test_init_storage_cmp.get_ge_rat_rat()
    assert(ge_rat_rat == true)
    const lt_rat_rat = await test_init_storage_cmp.test_init_storage_cmp.get_lt_rat_rat()
    assert(lt_rat_rat == false)
    const le_rat_rat = await test_init_storage_cmp.test_init_storage_cmp.get_le_rat_rat()
    assert(le_rat_rat == false)
    const eq_tez_tez = await test_init_storage_cmp.test_init_storage_cmp.get_eq_tez_tez()
    assert(eq_tez_tez == false)
    const ne_tez_tez = await test_init_storage_cmp.test_init_storage_cmp.get_ne_tez_tez()
    assert(ne_tez_tez == true)
    const gt_tez_tez = await test_init_storage_cmp.test_init_storage_cmp.get_gt_tez_tez()
    assert(gt_tez_tez == true)
    const ge_tez_tez = await test_init_storage_cmp.test_init_storage_cmp.get_ge_tez_tez()
    assert(ge_tez_tez == true)
    const lt_tez_tez = await test_init_storage_cmp.test_init_storage_cmp.get_lt_tez_tez()
    assert(lt_tez_tez == false)
    const le_tez_tez = await test_init_storage_cmp.test_init_storage_cmp.get_le_tez_tez()
    assert(le_tez_tez == false)
    const eq_dur_dur = await test_init_storage_cmp.test_init_storage_cmp.get_eq_dur_dur()
    assert(eq_dur_dur == false)
    const ne_dur_dur = await test_init_storage_cmp.test_init_storage_cmp.get_ne_dur_dur()
    assert(ne_dur_dur == true)
    const gt_dur_dur = await test_init_storage_cmp.test_init_storage_cmp.get_gt_dur_dur()
    assert(gt_dur_dur == true)
    const ge_dur_dur = await test_init_storage_cmp.test_init_storage_cmp.get_ge_dur_dur()
    assert(ge_dur_dur == true)
    const lt_dur_dur = await test_init_storage_cmp.test_init_storage_cmp.get_lt_dur_dur()
    assert(lt_dur_dur == false)
    const le_dur_dur = await test_init_storage_cmp.test_init_storage_cmp.get_le_dur_dur()
    assert(le_dur_dur == false)
    const eq_dat_dat = await test_init_storage_cmp.test_init_storage_cmp.get_eq_dat_dat()
    assert(eq_dat_dat == false)
    const ne_dat_dat = await test_init_storage_cmp.test_init_storage_cmp.get_ne_dat_dat()
    assert(ne_dat_dat == true)
    const gt_dat_dat = await test_init_storage_cmp.test_init_storage_cmp.get_gt_dat_dat()
    assert(gt_dat_dat == true)
    const ge_dat_dat = await test_init_storage_cmp.test_init_storage_cmp.get_ge_dat_dat()
    assert(ge_dat_dat == true)
    const lt_dat_dat = await test_init_storage_cmp.test_init_storage_cmp.get_lt_dat_dat()
    assert(lt_dat_dat == false)
    const le_dat_dat = await test_init_storage_cmp.test_init_storage_cmp.get_le_dat_dat()
    assert(le_dat_dat == false)
    const eq_addr_addr = await test_init_storage_cmp.test_init_storage_cmp.get_eq_addr_addr()
    assert(eq_addr_addr == false)
    const ne_addr_addr = await test_init_storage_cmp.test_init_storage_cmp.get_ne_addr_addr()
    assert(ne_addr_addr == true)
    const gt_addr_addr = await test_init_storage_cmp.test_init_storage_cmp.get_gt_addr_addr()
    assert(gt_addr_addr == true)
    const ge_addr_addr = await test_init_storage_cmp.test_init_storage_cmp.get_ge_addr_addr()
    assert(ge_addr_addr == true)
    const lt_addr_addr = await test_init_storage_cmp.test_init_storage_cmp.get_lt_addr_addr()
    assert(lt_addr_addr == false)
    const le_addr_addr = await test_init_storage_cmp.test_init_storage_cmp.get_le_addr_addr()
    assert(le_addr_addr == false)
    const eq_str_str = await test_init_storage_cmp.test_init_storage_cmp.get_eq_str_str()
    assert(eq_str_str == false)
    const ne_str_str = await test_init_storage_cmp.test_init_storage_cmp.get_ne_str_str()
    assert(ne_str_str == true)
    const gt_str_str = await test_init_storage_cmp.test_init_storage_cmp.get_gt_str_str()
    assert(gt_str_str == true)
    const ge_str_str = await test_init_storage_cmp.test_init_storage_cmp.get_ge_str_str()
    assert(ge_str_str == true)
    const lt_str_str = await test_init_storage_cmp.test_init_storage_cmp.get_lt_str_str()
    assert(lt_str_str == false)
    const le_str_str = await test_init_storage_cmp.test_init_storage_cmp.get_le_str_str()
    assert(le_str_str == false)
    const eq_bool_bool = await test_init_storage_cmp.test_init_storage_cmp.get_eq_bool_bool()
    assert(eq_bool_bool == false)
    const ne_bool_bool = await test_init_storage_cmp.test_init_storage_cmp.get_ne_bool_bool()
    assert(ne_bool_bool == true)
  })

  it('test_init_storage_funs', async () => {
    await test_init_storage_funs.test_init_storage_funs.deploy({ as: alice })

    const min_int_int = await test_init_storage_funs.test_init_storage_funs.get_min_int_int()
    assert(min_int_int.equals(new Int(1)))
    const max_int_int = await test_init_storage_funs.test_init_storage_funs.get_max_int_int()
    assert(max_int_int.equals(new Int(2)))
    const min_dur_dur = await test_init_storage_funs.test_init_storage_funs.get_min_dur_dur()
    assert(min_dur_dur.equals(new Duration("1s")))
    const max_dur_dur = await test_init_storage_funs.test_init_storage_funs.get_max_dur_dur()
    assert(max_dur_dur.equals(new Duration("1h")))
    const min_tez_tez = await test_init_storage_funs.test_init_storage_funs.get_min_tez_tez()
    assert(min_tez_tez.equals(new Tez(1)))
    const max_tez_tez = await test_init_storage_funs.test_init_storage_funs.get_max_tez_tez()
    assert(max_tez_tez.equals(new Tez(2)))
    const floor_rat = await test_init_storage_funs.test_init_storage_funs.get_floor_rat()
    assert(floor_rat.equals(new Int(1)))
    const ceil_rat = await test_init_storage_funs.test_init_storage_funs.get_ceil_rat()
    assert(ceil_rat.equals(new Int(2)))
    const nfloor_rat = await test_init_storage_funs.test_init_storage_funs.get_nfloor_rat()
    assert(nfloor_rat.equals(new Int(-2)))
    const nceil_rat = await test_init_storage_funs.test_init_storage_funs.get_nceil_rat()
    assert(nceil_rat.equals(new Int(-1)))
    const abs_int = await test_init_storage_funs.test_init_storage_funs.get_abs_int()
    assert(abs_int.equals(new Int(1)))
    const abs_rat = await test_init_storage_funs.test_init_storage_funs.get_abs_rat()
    assert(abs_rat.equals(new Rational(0.5)))
    const concat_str = await test_init_storage_funs.test_init_storage_funs.get_concat_str()
    assert(concat_str == "abcdef")
    const slice_str = await test_init_storage_funs.test_init_storage_funs.get_slice_str()
    assert(slice_str.equals(Option.Some<string>("bc")))
    const length_str = await test_init_storage_funs.test_init_storage_funs.get_length_str()
    assert(length_str.equals(new Nat(6)))
    const concat_byt = await test_init_storage_funs.test_init_storage_funs.get_concat_byt()
    assert(concat_byt.equals(new Bytes("12ef")))
    const slice_byt = await test_init_storage_funs.test_init_storage_funs.get_slice_byt()
    assert(slice_byt.equals(Option.Some<Bytes>(new Bytes("cdef"))))
  })

  it('test_init_storage_literals', async () => {
    await test_init_storage_literals.test_init_storage_literals.deploy({ as: alice })

    const x = await test_init_storage_literals.test_init_storage_literals.get_x()
    assert(x == true)
    const y = await test_init_storage_literals.test_init_storage_literals.get_y()
    assert(y == false)
    const n = await test_init_storage_literals.test_init_storage_literals.get_n()
    assert(n.equals(new Nat(1)))
    const i = await test_init_storage_literals.test_init_storage_literals.get_i()
    assert(i.equals(new Int(1)))
    const j = await test_init_storage_literals.test_init_storage_literals.get_j()
    assert(j.equals(new Int(-1)))
    const n_ = await test_init_storage_literals.test_init_storage_literals.get_n_()
    assert(n_.equals(new Nat(100_000)))
    const i_ = await test_init_storage_literals.test_init_storage_literals.get_i_()
    assert(i_.equals(new Int(100_000)))
    const f = await test_init_storage_literals.test_init_storage_literals.get_f()
    assert(f.equals(new Rational(1.1)))
    const g = await test_init_storage_literals.test_init_storage_literals.get_g()
    assert(g.equals(new Rational(-1.1)))
    const r = await test_init_storage_literals.test_init_storage_literals.get_r()
    assert(r.equals(new Rational(1, new BigNumber(3))))
    const t = await test_init_storage_literals.test_init_storage_literals.get_t()
    assert(t.equals(new Rational(-1, new BigNumber(3))))
    const u = await test_init_storage_literals.test_init_storage_literals.get_u()
    assert(u.equals(new Rational("80%")))
    const s = await test_init_storage_literals.test_init_storage_literals.get_s()
    assert(s == "str")
    const ctz = await test_init_storage_literals.test_init_storage_literals.get_ctz()
    assert(ctz.equals(new Tez(1)))
    const cmtz = await test_init_storage_literals.test_init_storage_literals.get_cmtz()
    assert(cmtz.equals(new Tez(1000, "mutez")))
    const cutz = await test_init_storage_literals.test_init_storage_literals.get_cutz()
    assert(cutz.equals(new Tez(1, "mutez")))
    const a = await test_init_storage_literals.test_init_storage_literals.get_a()
    assert(a.equals(new Address("tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg")))
    const d = await test_init_storage_literals.test_init_storage_literals.get_d()
    assert(d.equals(new Duration("3w8d4h34m18s")))
    const date0 = await test_init_storage_literals.test_init_storage_literals.get_date0()
    assert(date0.toISOString() == '2019-01-01T00:00:00.000Z')
    const date1 = await test_init_storage_literals.test_init_storage_literals.get_date1()
    assert(date1.toISOString() == '2019-01-01T01:02:03.000Z')
    const date2 = await test_init_storage_literals.test_init_storage_literals.get_date2()
    assert(date2.toISOString() == '2019-01-01T01:02:03.000Z')
    const date3 = await test_init_storage_literals.test_init_storage_literals.get_date3()
    assert(date3.toISOString() == '2018-12-31T23:00:00.000Z')
    const date4 = await test_init_storage_literals.test_init_storage_literals.get_date4()
    assert(date4.toISOString() == '2019-01-01T05:30:00.000Z')
    const myset = await test_init_storage_literals.test_init_storage_literals.get_myset()
    assert(myset.length == 3)
    assert(myset[0].equals(new Nat(1)))
    assert(myset[1].equals(new Nat(2)))
    assert(myset[2].equals(new Nat(3)))
    const mylist = await test_init_storage_literals.test_init_storage_literals.get_mylist()
    assert(mylist.length == 3)
    assert(mylist[0].equals(new Nat(1)))
    assert(mylist[1].equals(new Nat(2)))
    assert(mylist[2].equals(new Nat(3)))
    const mymap = await test_init_storage_literals.test_init_storage_literals.get_mymap()
    assert(mymap.length == 3)
    assert(mymap[0][0].equals(new Nat(1)))
    assert(mymap[0][1] == "mystr1")
    assert(mymap[1][0].equals(new Nat(2)))
    assert(mymap[1][1] == "mystr2")
    assert(mymap[2][0].equals(new Nat(3)))
    assert(mymap[2][1] == "mystr3")
    const mytuple = await test_init_storage_literals.test_init_storage_literals.get_mytuple()
    assert(mytuple[0].equals(new Int(1)))
    assert(mytuple[1].equals(new Int(2)))
    const op1 = await test_init_storage_literals.test_init_storage_literals.get_op1()
    assert(op1.equals(Option.None()))
    const op2 = await test_init_storage_literals.test_init_storage_literals.get_op2()
    assert(op2.equals(Option.Some(new Nat(0))))
    const b = await test_init_storage_literals.test_init_storage_literals.get_b()
    assert(b.equals(new Bytes("ff")))
    const vunit = await test_init_storage_literals.test_init_storage_literals.get_vunit()
    assert(vunit.equals(new Unit()))
    const oleft = await test_init_storage_literals.test_init_storage_literals.get_oleft()
    assert(oleft.equals(Or.Left<string, Nat>("str")))
    const oright = await test_init_storage_literals.test_init_storage_literals.get_oright()
    assert(oright.equals(Or.Right(new Nat(0))))
  })

  it('test_init_storage_simple', async () => {
    await test_init_storage_simple.test_init_storage_simple.deploy({ as: alice })

    const n = await test_init_storage_simple.test_init_storage_simple.get_n()
    assert(n.equals(new Nat(0)))
    const i = await test_init_storage_simple.test_init_storage_simple.get_i()
    assert(i.equals(new Int(1)))
    const s = await test_init_storage_simple.test_init_storage_simple.get_s()
    assert(s == "str")
  })

  it('test_initialized_with', async () => {
    await test_initialized_with.test_initialized_with.deploy({ as: alice })

    const my_asset = await test_initialized_with.test_initialized_with.get_my_asset()
    assert(my_asset.length == 3)
    assert(my_asset[0][0] == "id0")
    assert(my_asset[0][1].v1.equals(new Int(0)))
    assert(my_asset[0][1].v2.equals(new Int(3)))
    assert(my_asset[1][0] == "id1")
    assert(my_asset[1][1].v1.equals(new Int(1)))
    assert(my_asset[1][1].v2.equals(new Int(3)))
    assert(my_asset[2][0] == "id2")
    assert(my_asset[2][1].v1.equals(new Int(2)))
    assert(my_asset[2][1].v2.equals(new Int(3)))
  })

  it('test_initialized_with_asset', async () => {
    await test_initialized_with_asset.test_initialized_with_asset.deploy({ as: alice })

    const my_asset = await test_initialized_with_asset.test_initialized_with_asset.get_my_asset()
    assert(my_asset.length == 1)
    assert(my_asset[0][0] == "my_id")
    assert(my_asset[0][1].value.equals(new Int(2)))
    assert(my_asset[0][1].myaggregate.length == 1)
    assert(my_asset[0][1].myaggregate[0].equals(new Nat(0)))
    const o_asset = await test_initialized_with_asset.test_initialized_with_asset.get_o_asset()
    assert(o_asset.length == 1)
    assert(o_asset[0].equals(new Nat(0)))
  })

  it('test_is_implicit_address', async () => {
    await test_is_implicit_address.test_is_implicit_address.deploy({ as: alice })

    const res_before = await test_is_implicit_address.test_is_implicit_address.get_res()
    assert(res_before == false)

    await test_is_implicit_address.test_is_implicit_address.exec(new Address("tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb"), { as: alice })

    const res_tz1 = await test_is_implicit_address.test_is_implicit_address.get_res()
    assert(res_tz1 == true)

    await test_is_implicit_address.test_is_implicit_address.exec(new Address("tz2BFTyPeYRzxd5aiBchbXN3WCZhx7BqbMBq"), { as: alice })

    const res_tz2 = await test_is_implicit_address.test_is_implicit_address.get_res()
    assert(res_tz2 == true)

    await test_is_implicit_address.test_is_implicit_address.exec(new Address("tz3hFR7NZtjT2QtzgMQnWb4xMuD6yt2YzXUt"), { as: alice })

    const res_tz3 = await test_is_implicit_address.test_is_implicit_address.get_res()
    assert(res_tz3 == true)

    await test_is_implicit_address.test_is_implicit_address.exec(new Address("tz4HVR6aty9KwsQFHh81C1G7gBdhxT8kuytm"), { as: alice })

    const res_tz4 = await test_is_implicit_address.test_is_implicit_address.get_res()
    assert(res_tz4 == true)

    await test_is_implicit_address.test_is_implicit_address.exec(new Address("KT1Ns7vKToTAx1F4hJdyDTRUzUERWKaXXt1e"), { as: alice })

    const res_kt1 = await test_is_implicit_address.test_is_implicit_address.get_res()
    assert(res_kt1 == false)
  })

  it('test_iter', async () => {
    await test_iter.test_iter.deploy({ as: alice })

    const res_before = await test_iter.test_iter.get_res()
    assert(res_before.equals(new Int(0)))

    await test_iter.test_iter.exec(new Int(0), new Int(4), { as: alice })

    const res_0_4 = await test_iter.test_iter.get_res()
    assert(res_0_4.equals(new Int(10)))

    await test_iter.test_iter.exec(new Int(1), new Int(3), { as: alice })

    const res_1_3 = await test_iter.test_iter.get_res()
    assert(res_1_3.equals(new Int(6)))

    await test_iter.test_iter.exec(new Int(0), new Int(0), { as: alice })

    const res_0_0 = await test_iter.test_iter.get_res()
    assert(res_0_0.equals(new Int(0)))
  })

  it('test_iter2', async () => {
    await test_iter2.test_iter2.deploy({ as: alice })

    const res_before = await test_iter2.test_iter2.get_res()
    assert(res_before.equals(new Int(0)))

    await test_iter2.test_iter2.exec({ as: alice })

    const res_after = await test_iter2.test_iter2.get_res()
    assert(res_after.equals(new Int(6)))
  })

  it('test_length_operations', async () => {
    await test_length_operations.test_length_operations.deploy({ amount: new Tez(1), as: alice })

    const res_before = await test_length_operations.test_length_operations.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_length_operations.test_length_operations.exec({ as: alice })

    const res_after = await test_length_operations.test_length_operations.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('test_list_contains', async () => {
    await test_list_contains.test_list_contains.deploy({ as: alice })

    const rf_before = await test_list_contains.test_list_contains.get_rf()
    assert(rf_before == false)
    const rt_before = await test_list_contains.test_list_contains.get_rt()
    assert(rt_before == false)

    await test_list_contains.test_list_contains.exec({ as: alice })

    const rf_after = await test_list_contains.test_list_contains.get_rf()
    assert(rf_after == true)
    const rt_after = await test_list_contains.test_list_contains.get_rt()
    assert(rt_after == true)
  })

  it('test_list_contains2', async () => {
    await test_list_contains2.test_list_contains2.deploy({ as: alice })

    const rf_before = await test_list_contains2.test_list_contains2.get_rf()
    assert(rf_before == false)
    const rt_before = await test_list_contains2.test_list_contains2.get_rt()
    assert(rt_before == false)
    const rt2_before = await test_list_contains2.test_list_contains2.get_rt2()
    assert(rt2_before == false)

    await test_list_contains2.test_list_contains2.exec({ as: alice })

    const rf_after = await test_list_contains2.test_list_contains2.get_rf()
    assert(rf_after == true)
    const rt_after = await test_list_contains2.test_list_contains2.get_rt()
    assert(rt_after == true)
    const rt2_after = await test_list_contains2.test_list_contains2.get_rt2()
    assert(rt2_after == true)
  })

  it('test_list_mynth', async () => {
    await test_list_mynth.test_list_mynth.deploy({ as: alice })

    const res_before = await test_list_mynth.test_list_mynth.get_res()
    assert(res_before.equals(Option.None()))

    await test_list_mynth.test_list_mynth.exec({ as: alice })

    const res_after = await test_list_mynth.test_list_mynth.get_res()
    assert(res_after.equals(Option.Some<string>("2")))
  })

  it('test_list_mynth2', async () => {
    await test_list_mynth2.test_list_mynth2.deploy({ as: alice })

    const res_before = await test_list_mynth2.test_list_mynth2.get_res()
    assert(res_before.equals(Option.None()))

    await test_list_mynth2.test_list_mynth2.exec({ as: alice })

    const res_after = await test_list_mynth2.test_list_mynth2.get_res()
    assert(res_after.equals(Option.Some<string>("2")))
  })

  it('test_list_mynth3', async () => {
    await test_list_mynth3.test_list_mynth3.deploy({ as: alice })

    const res_before = await test_list_mynth3.test_list_mynth3.get_res()
    assert(res_before.equals(Option.None()))

    await test_list_mynth3.test_list_mynth3.exec({ as: alice })

    const res_after = await test_list_mynth3.test_list_mynth3.get_res()
    assert(res_after.equals(Option.Some<string>("2")))
  })

  it('test_list_nth', async () => {
    await test_list_nth.test_list_nth.deploy({ as: alice })

    const res_before = await test_list_nth.test_list_nth.get_res()
    assert(res_before == "")

    await test_list_nth.test_list_nth.exec({ as: alice })

    const res_after = await test_list_nth.test_list_nth.get_res()
    assert(res_after == "2")
  })

  it('test_metadata', async () => {
    await test_metadata.test_metadata.deploy({ as: alice })

    const value_before = await test_metadata.test_metadata.get_metadata_value("")
    assert(value_before == undefined)

    await test_metadata.test_metadata.exec({ as: alice })

    const value_after = await test_metadata.test_metadata.get_metadata_value("")
    assert(value_after?.equals(new Bytes("00")))
  })

  it('test_operations', async () => {
    await test_operations.test_operations.deploy({ amount: new Tez(1), as: alice })

    await test_operations.test_operations.exec(alice.get_address(), { as: alice })
  })

  it('test_oracle', async () => {
    await test_oracle.test_oracle.deploy({ as: alice })
    await test_oracle_called.test_oracle_called.deploy({ as: alice })

    const v_before = await test_oracle.test_oracle.get_v()
    assert(v_before[0] == "")
    assert(v_before[1].toISOString() == '2020-01-01T00:00:00.000Z')
    assert(v_before[2].equals(new Nat(0)))

    await test_oracle.test_oracle.exec(test_oracle_called.test_oracle_called.get_address(), { as: alice })

    const v_after = await test_oracle.test_oracle.get_v()
    assert(v_after[0] == "XTZ-USD")
    assert(v_after[1].toISOString() == '2022-01-01T00:00:00.000Z')
    assert(v_after[2].equals(new Nat(2)))
  })

  it('test_oracle_called', async () => {
    await test_oracle_called.test_oracle_called.deploy({ as: alice })
  })

  it('test_parameter', async () => {
    await test_parameter.test_parameter.deploy(new Nat(2), "mystr", { as: alice })

    const res_before = await test_parameter.test_parameter.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_parameter.test_parameter.exec({ as: alice })

    const res_after = await test_parameter.test_parameter.get_res()
    assert(res_after.equals(new Nat(7)))
  })

  it('test_parameter_const', async () => {
    await test_parameter_const.test_parameter_const.deploy(new Nat(2), { as: alice })

    const res_before = await test_parameter_const.test_parameter_const.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_parameter_const.test_parameter_const.exec({ as: alice })

    const res_after = await test_parameter_const.test_parameter_const.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('test_prec', async () => {
    await test_prec.test_prec.deploy({ as: alice })

    const x0 = await test_prec.test_prec.get_x0()
    assert(x0.equals(new Nat(6)))
    const y0 = await test_prec.test_prec.get_y0()
    assert(y0.equals(new Nat(6)))
    const z0 = await test_prec.test_prec.get_z0()
    assert(z0.equals(new Nat(6)))

    const x1 = await test_prec.test_prec.get_x1()
    assert(x1.equals(new Nat(7)))
    const y1 = await test_prec.test_prec.get_y1()
    assert(y1.equals(new Nat(9)))
    const z1 = await test_prec.test_prec.get_z1()
    assert(z1.equals(new Nat(7)))

    const x2 = await test_prec.test_prec.get_x2()
    assert(x2.equals(new Nat(5)))
    const y2 = await test_prec.test_prec.get_y2()
    assert(y2.equals(new Nat(5)))
    const z2 = await test_prec.test_prec.get_z2()
    assert(z2.equals(new Nat(5)))
  })

  it('test_rational', async () => {
    await test_rational.test_rational.deploy({ as: alice })

    const res_before = await test_rational.test_rational.get_res()
    assert(res_before == false)

    await test_rational.test_rational.exec({ as: alice })

    const res_after = await test_rational.test_rational.get_res()
    assert(res_after == true)
  })

  it('test_read_asset_after_operation', async () => {
    await test_read_asset_after_operation.test_read_asset_after_operation.deploy({ as: alice })

    const my_asset_before = await test_read_asset_after_operation.test_read_asset_after_operation.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].f1.equals(new Int(1)))
    assert(my_asset_before[0][1].f2.equals(new Int(2)))

    await test_read_asset_after_operation.test_read_asset_after_operation.exec({ as: alice })

    const my_asset_after = await test_read_asset_after_operation.test_read_asset_after_operation.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].f1.equals(new Int(1)))
    assert(my_asset_after[0][1].f2.equals(new Int(2)))
  })

  it('test_read_asset_after_update', async () => {
    await test_read_asset_after_update.test_read_asset_after_update.deploy({ as: alice })

    const my_asset_before = await test_read_asset_after_update.test_read_asset_after_update.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id")
    assert(my_asset_before[0][1].equals(new Int(1)))

    await test_read_asset_after_update.test_read_asset_after_update.exec({ as: alice })

    const my_asset_after = await test_read_asset_after_update.test_read_asset_after_update.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0] == "id")
    assert(my_asset_after[0][1].equals(new Int(0)))
  })

  it('test_record', async () => {
    await test_record.test_record.deploy({ as: alice })

    await test_record.test_record.exec({ as: alice })
  })

  it('test_record_access_0', async () => {
    await test_record_access_0.test_record_access_0.deploy({ as: alice })

    const res_before = await test_record_access_0.test_record_access_0.get_res()
    assert(res_before == "")

    await test_record_access_0.test_record_access_0.exec({ as: alice })

    const res_after = await test_record_access_0.test_record_access_0.get_res()
    assert(res_after == "mystr")
  })

  it('test_record_access_1', async () => {
    await test_record_access_1.test_record_access_1.deploy({ as: alice })

    const rid_before = await test_record_access_1.test_record_access_1.get_rid()
    assert(rid_before == "")
    const rv_before = await test_record_access_1.test_record_access_1.get_rv()
    assert(rv_before.equals(new Int(0)))

    await test_record_access_1.test_record_access_1.exec({ as: alice })

    const rid_after = await test_record_access_1.test_record_access_1.get_rid()
    assert(rid_after == "mystr")
    const rv_after = await test_record_access_1.test_record_access_1.get_rv()
    assert(rv_after.equals(new Int(2)))
  })

  it('test_record_access_2', async () => {
    await test_record_access_2.test_record_access_2.deploy({ as: alice })

    const rid_before = await test_record_access_2.test_record_access_2.get_rid()
    assert(rid_before == "")
    const rv_before = await test_record_access_2.test_record_access_2.get_rv()
    assert(rv_before.equals(new Int(0)))
    const rb_before = await test_record_access_2.test_record_access_2.get_rb()
    assert(rb_before == false)

    await test_record_access_2.test_record_access_2.exec({ as: alice })

    const rid_after = await test_record_access_2.test_record_access_2.get_rid()
    assert(rid_after == "mystr")
    const rv_after = await test_record_access_2.test_record_access_2.get_rv()
    assert(rv_after.equals(new Int(2)))
    const rb_after = await test_record_access_2.test_record_access_2.get_rb()
    assert(rb_after == true)

  })

  it('test_record_access_3', async () => {
    await test_record_access_3.test_record_access_3.deploy({ as: alice })

    const rid_before = await test_record_access_3.test_record_access_3.get_rid()
    assert(rid_before == "")
    const rv_before = await test_record_access_3.test_record_access_3.get_rv()
    assert(rv_before.equals(new Int(0)))
    const rb_before = await test_record_access_3.test_record_access_3.get_rb()
    assert(rb_before == false)
    const rn_before = await test_record_access_3.test_record_access_3.get_rn()
    assert(rn_before.equals(new Nat(0)))

    await test_record_access_3.test_record_access_3.exec({ as: alice })

    const rid_after = await test_record_access_3.test_record_access_3.get_rid()
    assert(rid_after == "mystr")
    const rv_after = await test_record_access_3.test_record_access_3.get_rv()
    assert(rv_after.equals(new Int(2)))
    const rb_after = await test_record_access_3.test_record_access_3.get_rb()
    assert(rb_after == true)
    const rn_after = await test_record_access_3.test_record_access_3.get_rn()
    assert(rn_after.equals(new Nat(3)))
  })

  it('test_record_assign_1', async () => {
    await test_record_assign_1.test_record_assign_1.deploy({ as: alice })

    const res_before = await test_record_assign_1.test_record_assign_1.get_res()
    assert(res_before.equals(new test_record_assign_1.my_record("", new Nat(0))))

    await test_record_assign_1.test_record_assign_1.exec("mystr", { as: alice })

    const res_after = await test_record_assign_1.test_record_assign_1.get_res()
    assert(res_after.equals(new test_record_assign_1.my_record("mystr", new Nat(0))))
  })

  it('test_record_assign_2', async () => {
    await test_record_assign_2.test_record_assign_2.deploy({ as: alice })

    const res_before = await test_record_assign_2.test_record_assign_2.get_res()
    assert(res_before.equals(new test_record_assign_2.my_record("", new Nat(0))))

    await test_record_assign_2.test_record_assign_2.exec(new Nat(2), { as: alice })

    const res_after = await test_record_assign_2.test_record_assign_2.get_res()
    assert(res_after.equals(new test_record_assign_2.my_record("", new Nat(2))))
  })

  it('test_record_assign_3', async () => {
    await test_record_assign_3.test_record_assign_3.deploy({ as: alice })

    const res_before = await test_record_assign_3.test_record_assign_3.get_res()
    assert(res_before.equals(new test_record_assign_3.my_record("", new Nat(0), new Int(0))))

    await test_record_assign_3.test_record_assign_3.exec(new Int(3), { as: alice })

    const res_after = await test_record_assign_3.test_record_assign_3.get_res()
    assert(res_after.equals(new test_record_assign_3.my_record("", new Nat(0), new Int(3))))
  })

  it('test_record_assign_full', async () => {
    await test_record_assign_full.test_record_assign_full.deploy({ as: alice })

    const res_before = await test_record_assign_full.test_record_assign_full.get_res()
    assert(res_before.equals(new test_record_assign_full.my_record("", new Nat(0), new Int(0), false)))

    await test_record_assign_full.test_record_assign_full.setv0("mystr", { as: alice })

    const res_v0 = await test_record_assign_full.test_record_assign_full.get_res()
    assert(res_v0.equals(new test_record_assign_full.my_record("mystr", new Nat(0), new Int(0), false)))

    await test_record_assign_full.test_record_assign_full.setv1(new Nat(2), { as: alice })

    const res_v1 = await test_record_assign_full.test_record_assign_full.get_res()
    assert(res_v1.equals(new test_record_assign_full.my_record("mystr", new Nat(2), new Int(0), false)))

    await test_record_assign_full.test_record_assign_full.setv2(new Int(3), { as: alice })

    const res_v2 = await test_record_assign_full.test_record_assign_full.get_res()
    assert(res_v2.equals(new test_record_assign_full.my_record("mystr", new Nat(2), new Int(3), false)))

    await test_record_assign_full.test_record_assign_full.setv3(true, { as: alice })

    const res_v3 = await test_record_assign_full.test_record_assign_full.get_res()
    assert(res_v3.equals(new test_record_assign_full.my_record("mystr", new Nat(2), new Int(3), true)))
  })

  it('test_record_assign_var', async () => {
    await test_record_assign_var.test_record_assign_var.deploy({ as: alice })

    const res_before = await test_record_assign_var.test_record_assign_var.get_res()
    assert(res_before.equals(new test_record_assign_var.my_record("", new Nat(0), new Int(0))))

    await test_record_assign_var.test_record_assign_var.exec(new Int(3), { as: alice })

    const res_after = await test_record_assign_var.test_record_assign_var.get_res()
    assert(res_after.equals(new test_record_assign_var.my_record("", new Nat(0), new Int(3))))
  })

  it('test_record_simple', async () => {
    await test_record_simple.test_record_simple.deploy({ as: alice })

    const res_before = await test_record_simple.test_record_simple.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_record_simple.test_record_simple.exec({ as: alice })

    const res_after = await test_record_simple.test_record_simple.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('test_remove_asset_with_partition', async () => {
    await test_remove_asset_with_partition.test_remove_asset_with_partition.deploy({ as: alice })

    const my_asset_before = await test_remove_asset_with_partition.test_remove_asset_with_partition.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0] == "id3")
    assert(my_asset_before[0][1].length == 0)
    const o_asset_before = await test_remove_asset_with_partition.test_remove_asset_with_partition.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_remove_asset_with_partition.test_remove_asset_with_partition.init({ as: alice })

    const my_asset_init = await test_remove_asset_with_partition.test_remove_asset_with_partition.get_my_asset()
    assert(my_asset_init.length == 1)
    assert(my_asset_init[0][0] == "id3")
    assert(my_asset_init[0][1].length == 1)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    const o_asset_init = await test_remove_asset_with_partition.test_remove_asset_with_partition.get_o_asset()
    assert(o_asset_init.length == 1)
    assert(o_asset_init[0].equals(new Nat(0)))

    await test_remove_asset_with_partition.test_remove_asset_with_partition.exec({ as: alice })

    const my_asset_after = await test_remove_asset_with_partition.test_remove_asset_with_partition.get_my_asset()
    assert(my_asset_after.length == 0)
    const o_asset_after = await test_remove_asset_with_partition.test_remove_asset_with_partition.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('test_removeall_aggregate', async () => {
    await test_removeall_aggregate.test_removeall_aggregate.deploy({ as: alice })

    const my_asset_before = await test_removeall_aggregate.test_removeall_aggregate.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].value.equals(new Int(0)))
    assert(my_asset_before[0][1].col.length == 3)
    assert(my_asset_before[0][1].col[0].equals(new Nat(0)))
    assert(my_asset_before[0][1].col[1].equals(new Nat(1)))
    assert(my_asset_before[0][1].col[2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].value.equals(new Int(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].value.equals(new Int(2)))
    assert(my_asset_before[2][1].col.length == 0)
    const o_asset_before = await test_removeall_aggregate.test_removeall_aggregate.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await test_removeall_aggregate.test_removeall_aggregate.exec({ as: alice })

    const my_asset_after = await test_removeall_aggregate.test_removeall_aggregate.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].value.equals(new Int(0)))
    assert(my_asset_after[0][1].col.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].value.equals(new Int(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].value.equals(new Int(2)))
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await test_removeall_aggregate.test_removeall_aggregate.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('test_removeall_aggregate_1', async () => {
    await test_removeall_aggregate_1.test_removeall_aggregate_1.deploy({ as: alice })

    const my_asset_before = await test_removeall_aggregate_1.test_removeall_aggregate_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removeall_aggregate_1.test_removeall_aggregate_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await test_removeall_aggregate_1.test_removeall_aggregate_1.exec({ as: alice })

    const my_asset_after = await test_removeall_aggregate_1.test_removeall_aggregate_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removeall_aggregate_1.test_removeall_aggregate_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('test_removeall_aggregate_2', async () => {
    await test_removeall_aggregate_2.test_removeall_aggregate_2.deploy({ as: alice })

    const my_asset_before = await test_removeall_aggregate_2.test_removeall_aggregate_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].val.equals(new Nat(0)))
    assert(my_asset_before[0][1].col.length == 3)
    assert(my_asset_before[0][1].col[0].equals(new Nat(0)))
    assert(my_asset_before[0][1].col[1].equals(new Nat(1)))
    assert(my_asset_before[0][1].col[2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].val.equals(new Nat(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].val.equals(new Nat(2)))
    assert(my_asset_before[2][1].col.length == 0)
    const o_asset_before = await test_removeall_aggregate_2.test_removeall_aggregate_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await test_removeall_aggregate_2.test_removeall_aggregate_2.exec({ as: alice })

    const my_asset_after = await test_removeall_aggregate_2.test_removeall_aggregate_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].val.equals(new Nat(0)))
    assert(my_asset_after[0][1].col.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].val.equals(new Nat(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].val.equals(new Nat(2)))
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await test_removeall_aggregate_2.test_removeall_aggregate_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('test_removeall_partition_1', async () => {
    await test_removeall_partition_1.test_removeall_partition_1.deploy({ as: alice })

    const my_asset_before = await test_removeall_partition_1.test_removeall_partition_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removeall_partition_1.test_removeall_partition_1.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_removeall_partition_1.test_removeall_partition_1.init({ as: alice })

    const my_asset_init = await test_removeall_partition_1.test_removeall_partition_1.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await test_removeall_partition_1.test_removeall_partition_1.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))

    await test_removeall_partition_1.test_removeall_partition_1.exec({ as: alice })

    const my_asset_after = await test_removeall_partition_1.test_removeall_partition_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removeall_partition_1.test_removeall_partition_1.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('test_removeall_partition_2', async () => {
    await test_removeall_partition_2.test_removeall_partition_2.deploy({ as: alice })

    const my_asset_before = await test_removeall_partition_2.test_removeall_partition_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].col.length == 0)
    assert(my_asset_before[0][1].val.equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[1][1].val.equals(new Nat(0)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].col.length == 0)
    assert(my_asset_before[2][1].val.equals(new Nat(0)))
    const o_asset_before = await test_removeall_partition_2.test_removeall_partition_2.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_removeall_partition_2.test_removeall_partition_2.init({ as: alice })

    const my_asset_init = await test_removeall_partition_2.test_removeall_partition_2.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].col.length == 3)
    assert(my_asset_init[0][1].col[0].equals(new Nat(0)))
    assert(my_asset_init[0][1].col[1].equals(new Nat(1)))
    assert(my_asset_init[0][1].col[2].equals(new Nat(2)))
    assert(my_asset_init[0][1].val.equals(new Nat(0)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].col.length == 0)
    assert(my_asset_init[1][1].val.equals(new Nat(0)))
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].col.length == 0)
    assert(my_asset_init[2][1].val.equals(new Nat(0)))
    const o_asset_init = await test_removeall_partition_2.test_removeall_partition_2.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))

    await test_removeall_partition_2.test_removeall_partition_2.exec({ as: alice })

    const my_asset_after = await test_removeall_partition_2.test_removeall_partition_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].col.length == 0)
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await test_removeall_partition_2.test_removeall_partition_2.get_o_asset()
    assert(o_asset_after.length == 0)
  })

  it('test_removefield_aggregate_1', async () => {
    await test_removefield_aggregate_1.test_removefield_aggregate_1.deploy({ as: alice })

    const my_asset_before = await test_removefield_aggregate_1.test_removefield_aggregate_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 3)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removefield_aggregate_1.test_removefield_aggregate_1.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await test_removefield_aggregate_1.test_removefield_aggregate_1.exec({ as: alice })

    const my_asset_after = await test_removefield_aggregate_1.test_removefield_aggregate_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 2)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removefield_aggregate_1.test_removefield_aggregate_1.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('test_removefield_aggregate_2', async () => {
    await test_removefield_aggregate_2.test_removefield_aggregate_2.deploy({ as: alice })

    const my_asset_before = await test_removefield_aggregate_2.test_removefield_aggregate_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].val.equals(new Nat(0)))
    assert(my_asset_before[0][1].col.length == 3)
    assert(my_asset_before[0][1].col[0].equals(new Nat(0)))
    assert(my_asset_before[0][1].col[1].equals(new Nat(1)))
    assert(my_asset_before[0][1].col[2].equals(new Nat(2)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].val.equals(new Nat(1)))
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].val.equals(new Nat(2)))
    assert(my_asset_before[2][1].col.length == 0)
    const o_asset_before = await test_removefield_aggregate_2.test_removefield_aggregate_2.get_o_asset()
    assert(o_asset_before.length == 3)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))

    await test_removefield_aggregate_2.test_removefield_aggregate_2.exec({ as: alice })

    const my_asset_after = await test_removefield_aggregate_2.test_removefield_aggregate_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].val.equals(new Nat(0)))
    assert(my_asset_after[0][1].col.length == 2)
    assert(my_asset_after[0][1].col[0].equals(new Nat(0)))
    assert(my_asset_after[0][1].col[1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].val.equals(new Nat(1)))
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].val.equals(new Nat(2)))
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await test_removefield_aggregate_2.test_removefield_aggregate_2.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('test_removefield_partition_1', async () => {
    await test_removefield_partition_1.test_removefield_partition_1.deploy({ as: alice })

    const my_asset_before = await test_removefield_partition_1.test_removefield_partition_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removefield_partition_1.test_removefield_partition_1.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_removefield_partition_1.test_removefield_partition_1.init({ as: alice })

    const my_asset_init = await test_removefield_partition_1.test_removefield_partition_1.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 3)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await test_removefield_partition_1.test_removefield_partition_1.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))

    await test_removefield_partition_1.test_removefield_partition_1.exec({ as: alice })

    const my_asset_after = await test_removefield_partition_1.test_removefield_partition_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 2)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removefield_partition_1.test_removefield_partition_1.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(2)))
  })

  it('test_removefield_partition_2', async () => {
    await test_removefield_partition_2.test_removefield_partition_2.deploy({ as: alice })

    const my_asset_before = await test_removefield_partition_2.test_removefield_partition_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].col.length == 0)
    assert(my_asset_before[0][1].val.equals(new Nat(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].col.length == 0)
    assert(my_asset_before[1][1].val.equals(new Nat(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].col.length == 0)
    assert(my_asset_before[2][1].val.equals(new Nat(2)))
    const o_asset_before = await test_removefield_partition_2.test_removefield_partition_2.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_removefield_partition_2.test_removefield_partition_2.init({ as: alice })

    const my_asset_init = await test_removefield_partition_2.test_removefield_partition_2.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].col.length == 3)
    assert(my_asset_init[0][1].col[0].equals(new Nat(0)))
    assert(my_asset_init[0][1].col[1].equals(new Nat(1)))
    assert(my_asset_init[0][1].col[2].equals(new Nat(2)))
    assert(my_asset_init[0][1].val.equals(new Nat(0)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].col.length == 0)
    assert(my_asset_init[1][1].val.equals(new Nat(1)))
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].col.length == 0)
    assert(my_asset_init[2][1].val.equals(new Nat(2)))
    const o_asset_init = await test_removefield_partition_2.test_removefield_partition_2.get_o_asset()
    assert(o_asset_init.length == 3)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))

    await test_removefield_partition_2.test_removefield_partition_2.exec({ as: alice })

    const my_asset_after = await test_removefield_partition_2.test_removefield_partition_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].col.length == 2)
    assert(my_asset_after[0][1].col[0].equals(new Nat(0)))
    assert(my_asset_after[0][1].col[1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].col.length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].col.length == 0)
    const o_asset_after = await test_removefield_partition_2.test_removefield_partition_2.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(2)))
  })

  it('test_removeif_agg_0', async () => {
    await test_removeif_agg_0.test_removeif_agg_0.deploy({ as: alice })

    const my_asset_before = await test_removeif_agg_0.test_removeif_agg_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 6)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[0][1][3].equals(new Nat(3)))
    assert(my_asset_before[0][1][4].equals(new Nat(4)))
    assert(my_asset_before[0][1][5].equals(new Nat(5)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removeif_agg_0.test_removeif_agg_0.get_o_asset()
    assert(o_asset_before.length == 6)
    assert(o_asset_before[0].equals(new Nat(0)))
    assert(o_asset_before[1].equals(new Nat(1)))
    assert(o_asset_before[2].equals(new Nat(2)))
    assert(o_asset_before[3].equals(new Nat(3)))
    assert(o_asset_before[4].equals(new Nat(4)))
    assert(o_asset_before[5].equals(new Nat(5)))

    await test_removeif_agg_0.test_removeif_agg_0.exec({ as: alice })

    const my_asset_after = await test_removeif_agg_0.test_removeif_agg_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removeif_agg_0.test_removeif_agg_0.get_o_asset()
    assert(o_asset_after.length == 6)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
    assert(o_asset_after[3].equals(new Nat(3)))
    assert(o_asset_after[4].equals(new Nat(4)))
    assert(o_asset_after[5].equals(new Nat(5)))
  })

  it('test_removeif_agg_1', async () => {
    await test_removeif_agg_1.test_removeif_agg_1.deploy({ as: alice })

    const my_asset_before = await test_removeif_agg_1.test_removeif_agg_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 6)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[0][1][3].equals(new Nat(3)))
    assert(my_asset_before[0][1][4].equals(new Nat(4)))
    assert(my_asset_before[0][1][5].equals(new Nat(5)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removeif_agg_1.test_removeif_agg_1.get_o_asset()
    assert(o_asset_before.length == 6)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1] == "mystr0")
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1] == "mystr1")
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1] == "mystr2")
    assert(o_asset_before[3][0].equals(new Nat(3)))
    assert(o_asset_before[3][1] == "mystr3")
    assert(o_asset_before[4][0].equals(new Nat(4)))
    assert(o_asset_before[4][1] == "mystr4")
    assert(o_asset_before[5][0].equals(new Nat(5)))
    assert(o_asset_before[5][1] == "mystr5")

    await test_removeif_agg_1.test_removeif_agg_1.exec({ as: alice })

    const my_asset_after = await test_removeif_agg_1.test_removeif_agg_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 2)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    assert(my_asset_after[0][1][1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removeif_agg_1.test_removeif_agg_1.get_o_asset()
    assert(o_asset_after.length == 6)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1] == "mystr0")
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1] == "mystr1")
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1] == "mystr2")
    assert(o_asset_after[3][0].equals(new Nat(3)))
    assert(o_asset_after[3][1] == "mystr3")
    assert(o_asset_after[4][0].equals(new Nat(4)))
    assert(o_asset_after[4][1] == "mystr4")
    assert(o_asset_after[5][0].equals(new Nat(5)))
    assert(o_asset_after[5][1] == "mystr5")
  })

  it('test_removeif_agg_2', async () => {
    await test_removeif_agg_2.test_removeif_agg_2.deploy({ as: alice })

    const my_asset_before = await test_removeif_agg_2.test_removeif_agg_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 6)
    assert(my_asset_before[0][1][0].equals(new Nat(0)))
    assert(my_asset_before[0][1][1].equals(new Nat(1)))
    assert(my_asset_before[0][1][2].equals(new Nat(2)))
    assert(my_asset_before[0][1][3].equals(new Nat(3)))
    assert(my_asset_before[0][1][4].equals(new Nat(4)))
    assert(my_asset_before[0][1][5].equals(new Nat(5)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removeif_agg_2.test_removeif_agg_2.get_o_asset()
    assert(o_asset_before.length == 6)
    assert(o_asset_before[0][0].equals(new Nat(0)))
    assert(o_asset_before[0][1].s == "mystr0")
    assert(o_asset_before[0][1].b == false)
    assert(o_asset_before[1][0].equals(new Nat(1)))
    assert(o_asset_before[1][1].s == "mystr1")
    assert(o_asset_before[1][1].b == true)
    assert(o_asset_before[2][0].equals(new Nat(2)))
    assert(o_asset_before[2][1].s == "mystr2")
    assert(o_asset_before[2][1].b == false)
    assert(o_asset_before[3][0].equals(new Nat(3)))
    assert(o_asset_before[3][1].s == "mystr3")
    assert(o_asset_before[3][1].b == false)
    assert(o_asset_before[4][0].equals(new Nat(4)))
    assert(o_asset_before[4][1].s == "mystr4")
    assert(o_asset_before[4][1].b == false)
    assert(o_asset_before[5][0].equals(new Nat(5)))
    assert(o_asset_before[5][1].s == "mystr5")
    assert(o_asset_before[5][1].b == false)

    await test_removeif_agg_2.test_removeif_agg_2.exec({ as: alice })

    const my_asset_after = await test_removeif_agg_2.test_removeif_agg_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removeif_agg_2.test_removeif_agg_2.get_o_asset()
    assert(o_asset_after.length == 6)
    assert(o_asset_after[0][0].equals(new Nat(0)))
    assert(o_asset_after[0][1].s == "mystr0")
    assert(o_asset_after[0][1].b == false)
    assert(o_asset_after[1][0].equals(new Nat(1)))
    assert(o_asset_after[1][1].s == "mystr1")
    assert(o_asset_after[1][1].b == true)
    assert(o_asset_after[2][0].equals(new Nat(2)))
    assert(o_asset_after[2][1].s == "mystr2")
    assert(o_asset_after[2][1].b == false)
    assert(o_asset_after[3][0].equals(new Nat(3)))
    assert(o_asset_after[3][1].s == "mystr3")
    assert(o_asset_after[3][1].b == false)
    assert(o_asset_after[4][0].equals(new Nat(4)))
    assert(o_asset_after[4][1].s == "mystr4")
    assert(o_asset_after[4][1].b == false)
    assert(o_asset_after[5][0].equals(new Nat(5)))
    assert(o_asset_after[5][1].s == "mystr5")
    assert(o_asset_after[5][1].b == false)
  })

  it('test_removeif_coll_0', async () => {
    await test_removeif_coll_0.test_removeif_coll_0.deploy({ as: alice })

    const my_asset_before = await test_removeif_coll_0.test_removeif_coll_0.get_my_asset()
    assert(my_asset_before.length == 6)
    assert(my_asset_before[0].equals(new Nat(0)))
    assert(my_asset_before[1].equals(new Nat(1)))
    assert(my_asset_before[2].equals(new Nat(2)))
    assert(my_asset_before[3].equals(new Nat(3)))
    assert(my_asset_before[4].equals(new Nat(4)))
    assert(my_asset_before[5].equals(new Nat(5)))

    await test_removeif_coll_0.test_removeif_coll_0.exec({ as: alice })

    const my_asset_after = await test_removeif_coll_0.test_removeif_coll_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0].equals(new Nat(0)))
    assert(my_asset_after[1].equals(new Nat(1)))
    assert(my_asset_after[2].equals(new Nat(2)))
  })

  it('test_removeif_coll_1', async () => {
    await test_removeif_coll_1.test_removeif_coll_1.deploy({ as: alice })

    const my_asset_before = await test_removeif_coll_1.test_removeif_coll_1.get_my_asset()
    assert(my_asset_before.length == 6)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "mystr0")
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1] == "mystr1")
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1] == "mystr2")
    assert(my_asset_before[3][0].equals(new Nat(3)))
    assert(my_asset_before[3][1] == "mystr3")
    assert(my_asset_before[4][0].equals(new Nat(4)))
    assert(my_asset_before[4][1] == "mystr4")
    assert(my_asset_before[5][0].equals(new Nat(5)))
    assert(my_asset_before[5][1] == "mystr5")

    await test_removeif_coll_1.test_removeif_coll_1.exec({ as: alice })

    const my_asset_after = await test_removeif_coll_1.test_removeif_coll_1.get_my_asset()
    assert(my_asset_after.length == 2)
    assert(my_asset_after[0][0].equals(new Nat(1)))
    assert(my_asset_after[0][1] == "mystr1")
    assert(my_asset_after[1][0].equals(new Nat(2)))
    assert(my_asset_after[1][1] == "mystr2")
  })

  it('test_removeif_coll_2', async () => {
    await test_removeif_coll_2.test_removeif_coll_2.deploy({ as: alice })

    const my_asset_before = await test_removeif_coll_2.test_removeif_coll_2.get_my_asset()
    assert(my_asset_before.length == 6)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1].s == "mystr0")
    assert(my_asset_before[0][1].b == false)
    assert(my_asset_before[1][0].equals(new Nat(1)))
    assert(my_asset_before[1][1].s == "mystr1")
    assert(my_asset_before[1][1].b == true)
    assert(my_asset_before[2][0].equals(new Nat(2)))
    assert(my_asset_before[2][1].s == "mystr2")
    assert(my_asset_before[2][1].b == false)
    assert(my_asset_before[3][0].equals(new Nat(3)))
    assert(my_asset_before[3][1].s == "mystr3")
    assert(my_asset_before[3][1].b == false)
    assert(my_asset_before[4][0].equals(new Nat(4)))
    assert(my_asset_before[4][1].s == "mystr4")
    assert(my_asset_before[4][1].b == false)
    assert(my_asset_before[5][0].equals(new Nat(5)))
    assert(my_asset_before[5][1].s == "mystr5")
    assert(my_asset_before[5][1].b == false)

    await test_removeif_coll_2.test_removeif_coll_2.exec({ as: alice })

    const my_asset_after = await test_removeif_coll_2.test_removeif_coll_2.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(2)))
    assert(my_asset_after[0][1].s == "mystr2")
    assert(my_asset_after[0][1].b == false)
  })

  it('test_removeif_part_0', async () => {
    await test_removeif_part_0.test_removeif_part_0.deploy({ as: alice })

    const my_asset_before = await test_removeif_part_0.test_removeif_part_0.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removeif_part_0.test_removeif_part_0.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_removeif_part_0.test_removeif_part_0.init({ as: alice })

    const my_asset_init = await test_removeif_part_0.test_removeif_part_0.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 6)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[0][1][3].equals(new Nat(3)))
    assert(my_asset_init[0][1][4].equals(new Nat(4)))
    assert(my_asset_init[0][1][5].equals(new Nat(5)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await test_removeif_part_0.test_removeif_part_0.get_o_asset()
    assert(o_asset_init.length == 6)
    assert(o_asset_init[0].equals(new Nat(0)))
    assert(o_asset_init[1].equals(new Nat(1)))
    assert(o_asset_init[2].equals(new Nat(2)))
    assert(o_asset_init[3].equals(new Nat(3)))
    assert(o_asset_init[4].equals(new Nat(4)))
    assert(o_asset_init[5].equals(new Nat(5)))

    await test_removeif_part_0.test_removeif_part_0.exec({ as: alice })

    const my_asset_after = await test_removeif_part_0.test_removeif_part_0.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 3)
    assert(my_asset_after[0][1][0].equals(new Nat(0)))
    assert(my_asset_after[0][1][1].equals(new Nat(1)))
    assert(my_asset_after[0][1][2].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removeif_part_0.test_removeif_part_0.get_o_asset()
    assert(o_asset_after.length == 3)
    assert(o_asset_after[0].equals(new Nat(0)))
    assert(o_asset_after[1].equals(new Nat(1)))
    assert(o_asset_after[2].equals(new Nat(2)))
  })

  it('test_removeif_part_1', async () => {
    await test_removeif_part_1.test_removeif_part_1.deploy({ as: alice })

    const my_asset_before = await test_removeif_part_1.test_removeif_part_1.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removeif_part_1.test_removeif_part_1.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_removeif_part_1.test_removeif_part_1.init({ as: alice })

    const my_asset_init = await test_removeif_part_1.test_removeif_part_1.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 6)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[0][1][3].equals(new Nat(3)))
    assert(my_asset_init[0][1][4].equals(new Nat(4)))
    assert(my_asset_init[0][1][5].equals(new Nat(5)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await test_removeif_part_1.test_removeif_part_1.get_o_asset()
    assert(o_asset_init.length == 6)
    assert(o_asset_init[0][0].equals(new Nat(0)))
    assert(o_asset_init[0][1] == "mystr0")
    assert(o_asset_init[1][0].equals(new Nat(1)))
    assert(o_asset_init[1][1] == "mystr1")
    assert(o_asset_init[2][0].equals(new Nat(2)))
    assert(o_asset_init[2][1] == "mystr2")
    assert(o_asset_init[3][0].equals(new Nat(3)))
    assert(o_asset_init[3][1] == "mystr3")
    assert(o_asset_init[4][0].equals(new Nat(4)))
    assert(o_asset_init[4][1] == "mystr4")
    assert(o_asset_init[5][0].equals(new Nat(5)))
    assert(o_asset_init[5][1] == "mystr5")

    await test_removeif_part_1.test_removeif_part_1.exec({ as: alice })

    const my_asset_after = await test_removeif_part_1.test_removeif_part_1.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 2)
    assert(my_asset_after[0][1][0].equals(new Nat(1)))
    assert(my_asset_after[0][1][1].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removeif_part_1.test_removeif_part_1.get_o_asset()
    assert(o_asset_after.length == 2)
    assert(o_asset_after[0][0].equals(new Nat(1)))
    assert(o_asset_after[0][1] == "mystr1")
    assert(o_asset_after[1][0].equals(new Nat(2)))
    assert(o_asset_after[1][1] == "mystr2")
  })

  it('test_removeif_part_2', async () => {
    await test_removeif_part_2.test_removeif_part_2.deploy({ as: alice })

    const my_asset_before = await test_removeif_part_2.test_removeif_part_2.get_my_asset()
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].length == 0)
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].length == 0)
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].length == 0)
    const o_asset_before = await test_removeif_part_2.test_removeif_part_2.get_o_asset()
    assert(o_asset_before.length == 0)

    await test_removeif_part_2.test_removeif_part_2.init({ as: alice })

    const my_asset_init = await test_removeif_part_2.test_removeif_part_2.get_my_asset()
    assert(my_asset_init.length == 3)
    assert(my_asset_init[0][0] == "id0")
    assert(my_asset_init[0][1].length == 6)
    assert(my_asset_init[0][1][0].equals(new Nat(0)))
    assert(my_asset_init[0][1][1].equals(new Nat(1)))
    assert(my_asset_init[0][1][2].equals(new Nat(2)))
    assert(my_asset_init[0][1][3].equals(new Nat(3)))
    assert(my_asset_init[0][1][4].equals(new Nat(4)))
    assert(my_asset_init[0][1][5].equals(new Nat(5)))
    assert(my_asset_init[1][0] == "id1")
    assert(my_asset_init[1][1].length == 0)
    assert(my_asset_init[2][0] == "id2")
    assert(my_asset_init[2][1].length == 0)
    const o_asset_init = await test_removeif_part_2.test_removeif_part_2.get_o_asset()
    assert(o_asset_init.length == 6)
    assert(o_asset_init[0][0].equals(new Nat(0)))
    assert(o_asset_init[0][1].s == "mystr0")
    assert(o_asset_init[0][1].b == false)
    assert(o_asset_init[1][0].equals(new Nat(1)))
    assert(o_asset_init[1][1].s == "mystr1")
    assert(o_asset_init[1][1].b == true)
    assert(o_asset_init[2][0].equals(new Nat(2)))
    assert(o_asset_init[2][1].s == "mystr2")
    assert(o_asset_init[2][1].b == false)
    assert(o_asset_init[3][0].equals(new Nat(3)))
    assert(o_asset_init[3][1].s == "mystr3")
    assert(o_asset_init[3][1].b == false)
    assert(o_asset_init[4][0].equals(new Nat(4)))
    assert(o_asset_init[4][1].s == "mystr4")
    assert(o_asset_init[4][1].b == false)
    assert(o_asset_init[5][0].equals(new Nat(5)))
    assert(o_asset_init[5][1].s == "mystr5")
    assert(o_asset_init[5][1].b == false)

    await test_removeif_part_2.test_removeif_part_2.exec({ as: alice })

    const my_asset_after = await test_removeif_part_2.test_removeif_part_2.get_my_asset()
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].length == 1)
    assert(my_asset_after[0][1][0].equals(new Nat(2)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].length == 0)
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].length == 0)
    const o_asset_after = await test_removeif_part_2.test_removeif_part_2.get_o_asset()
    assert(o_asset_after.length == 1)
    assert(o_asset_after[0][0].equals(new Nat(2)))
    assert(o_asset_after[0][1].s == "mystr2")
    assert(o_asset_after[0][1].b == false)
  })

  it('test_result', async () => {
    await test_result.test_result.deploy({ as: alice })

    const res_before = await test_result.test_result.get_res()
    assert(res_before.equals(new Int(0)))

    await test_result.test_result.exec({ as: alice })

    const res_after = await test_result.test_result.get_res()
    assert(res_after.equals(new Int(2)))
  })

  it('test_split_ticket', async () => {
    await test_split_ticket.test_split_ticket.deploy({ as: alice })

    const ticket_alice_before = await test_split_ticket.test_split_ticket.get_mt_value(alice.get_address());
    assert(ticket_alice_before === undefined)

    const ticket_bob_before = await test_split_ticket.test_split_ticket.get_mt_value(bob.get_address());
    assert(ticket_bob_before === undefined)

    await test_split_ticket.test_split_ticket.create(new Nat(20), { as: alice })

    const ticket_alice_create = await test_split_ticket.test_split_ticket.get_mt_value(alice.get_address());
    assert(ticket_alice_create?.equals(new Ticket(test_split_ticket.test_split_ticket.get_address(), new Unit(), new Nat(20))))

    const ticket_bob_create = await test_split_ticket.test_split_ticket.get_mt_value(bob.get_address());
    assert(ticket_bob_create === undefined)

    await test_split_ticket.test_split_ticket.split(new Nat(10), bob.get_address(), { as: alice })

    const ticket_alice_1 = await test_split_ticket.test_split_ticket.get_mt_value(alice.get_address());
    assert(ticket_alice_1?.equals(new Ticket(test_split_ticket.test_split_ticket.get_address(), new Unit(), new Nat(10))))

    const ticket_bob_1 = await test_split_ticket.test_split_ticket.get_mt_value(bob.get_address());
    assert(ticket_bob_1?.equals(new Ticket(test_split_ticket.test_split_ticket.get_address(), new Unit(), new Nat(10))))

    await test_split_ticket.test_split_ticket.split(new Nat(5), bob.get_address(), { as: alice })

    const ticket_alice_2 = await test_split_ticket.test_split_ticket.get_mt_value(alice.get_address());
    assert(ticket_alice_2?.equals(new Ticket(test_split_ticket.test_split_ticket.get_address(), new Unit(), new Nat(5))))

    const ticket_bob_2 = await test_split_ticket.test_split_ticket.get_mt_value(bob.get_address());
    assert(ticket_bob_2?.equals(new Ticket(test_split_ticket.test_split_ticket.get_address(), new Unit(), new Nat(15))))
  })

  it('test_tez', async () => {
    await test_tez.test_tez.deploy({ as: alice })

    const a = await test_tez.test_tez.get_a()
    assert(a.equals(new Tez(1)))
    const b = await test_tez.test_tez.get_b()
    assert(b.equals(new Tez(1.2)))
    const c = await test_tez.test_tez.get_c()
    assert(c.equals(new Tez(1000, "mutez")))
    const d = await test_tez.test_tez.get_d()
    assert(d.equals(new Tez(1200, "mutez")))
    const e = await test_tez.test_tez.get_e()
    assert(e.equals(new Tez(1, "mutez")))
    const f = await test_tez.test_tez.get_f()
    assert(f.equals(new Tez(1, "mutez")))
  })

  it('test_transfer', async () => {
    await test_transfer.test_transfer.deploy({ amount: new Tez(1), as: alice })

    const res_before = await test_transfer.test_transfer.get_res()
    assert(res_before.equals(new Nat(0)))

    await test_transfer.test_transfer.exec(alice.get_address(), test_transfer.test_transfer.get_address(), { as: alice })

    const res_after = await test_transfer.test_transfer.get_res()
    assert(res_after.equals(new Nat(3)))
  })

  it('test_transition', async () => {
    await test_transition.test_transition.deploy({ as: alice })

    const state_before = await test_transition.test_transition.get_state()
    assert(state_before == test_transition.states.First)

    await test_transition.test_transition.mytr({ as: alice })

    const state_0 = await test_transition.test_transition.get_state()
    assert(state_0 == test_transition.states.Second)

    await test_transition.test_transition.mytr_b({ as: alice })

    const state_1 = await test_transition.test_transition.get_state()
    assert(state_1 == test_transition.states.Third)

    await test_transition.test_transition.mytr_a({ as: alice })

    const state_2 = await test_transition.test_transition.get_state()
    assert(state_2 == test_transition.states.Third)

    await expect_to_fail(async () => {
      await test_transition.test_transition.mytr({ as: alice })
    }, { string: "INVALID_STATE" })

    const state_3 = await test_transition.test_transition.get_state()
    assert(state_3 == test_transition.states.Third)

    await expect_to_fail(async () => {
      await test_transition.test_transition.mytr_b({ as: alice })
    }, { string: "INVALID_STATE" })

    const state_4 = await test_transition.test_transition.get_state()
    assert(state_4 == test_transition.states.Third)

    await test_transition.test_transition.mytr_a({ as: alice })

    const state_after = await test_transition.test_transition.get_state()
    assert(state_after == test_transition.states.Third)
  })

  it('test_tuple_access_1', async () => {
    await test_tuple_access_1.test_tuple_access_1.deploy({ as: alice })

    const rid_before = await test_tuple_access_1.test_tuple_access_1.get_rid()
    assert(rid_before == "")
    const rv_before = await test_tuple_access_1.test_tuple_access_1.get_rv()
    assert(rv_before.equals(new Int(0)))

    await test_tuple_access_1.test_tuple_access_1.exec({ as: alice })

    const rid_after = await test_tuple_access_1.test_tuple_access_1.get_rid()
    assert(rid_after == "mystr")
    const rv_after = await test_tuple_access_1.test_tuple_access_1.get_rv()
    assert(rv_after.equals(new Int(2)))
  })

  it('test_tuple_access_2', async () => {
    await test_tuple_access_2.test_tuple_access_2.deploy({ as: alice })

    const rid_before = await test_tuple_access_2.test_tuple_access_2.get_rid()
    assert(rid_before == "")
    const rv_before = await test_tuple_access_2.test_tuple_access_2.get_rv()
    assert(rv_before.equals(new Int(0)))
    const rb_before = await test_tuple_access_2.test_tuple_access_2.get_rb()
    assert(rb_before == false)

    await test_tuple_access_2.test_tuple_access_2.exec({ as: alice })

    const rid_after = await test_tuple_access_2.test_tuple_access_2.get_rid()
    assert(rid_after == "mystr")
    const rv_after = await test_tuple_access_2.test_tuple_access_2.get_rv()
    assert(rv_after.equals(new Int(2)))
    const rb_after = await test_tuple_access_2.test_tuple_access_2.get_rb()
    assert(rb_after == true)
  })

  it('test_tuple_access_3', async () => {
    await test_tuple_access_3.test_tuple_access_3.deploy({ as: alice })

    const rid_before = await test_tuple_access_3.test_tuple_access_3.get_rid()
    assert(rid_before == "")
    const rv_before = await test_tuple_access_3.test_tuple_access_3.get_rv()
    assert(rv_before.equals(new Int(0)))
    const rb_before = await test_tuple_access_3.test_tuple_access_3.get_rb()
    assert(rb_before == false)
    const rn_before = await test_tuple_access_3.test_tuple_access_3.get_rn()
    assert(rn_before.equals(new Nat(0)))

    await test_tuple_access_3.test_tuple_access_3.exec({ as: alice })

    const rid_after = await test_tuple_access_3.test_tuple_access_3.get_rid()
    assert(rid_after == "mystr")
    const rv_after = await test_tuple_access_3.test_tuple_access_3.get_rv()
    assert(rv_after.equals(new Int(2)))
    const rb_after = await test_tuple_access_3.test_tuple_access_3.get_rb()
    assert(rb_after == true)
    const rn_after = await test_tuple_access_3.test_tuple_access_3.get_rn()
    assert(rn_after.equals(new Nat(3)))
  })

  it('test_update', async () => {
    await test_update.test_update.deploy({ as: alice })

    const my_asset_before = await test_update.test_update.get_my_asset()
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Int(2)))
    assert(my_asset_before[0][1] == "mystr")
    const my_asset_2_before = await test_update.test_update.get_my_asset_2()
    assert(my_asset_2_before.length == 1)
    assert(my_asset_2_before[0][0].equals(new Int(1)))
    assert(my_asset_2_before[0][1].equals(new Int(2)))

    await test_update.test_update.exec({ as: alice })

    const my_asset_after = await test_update.test_update.get_my_asset()
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Int(2)))
    assert(my_asset_after[0][1] == "value")
    const my_asset_2_after = await test_update.test_update.get_my_asset_2()
    assert(my_asset_2_after.length == 1)
    assert(my_asset_2_after[0][0].equals(new Int(1)))
    assert(my_asset_2_after[0][1].equals(new Int(2)))
  })

  it('test_var', async () => {
    await test_var.test_var.deploy({ as: alice })

    const n_before = await test_var.test_var.get_n()
    assert(n_before.equals(new Int(0)))

    await test_var.test_var.exec({ as: alice })

    const n_after = await test_var.test_var.get_n()
    assert(n_after.equals(new Int(2)))
  })

  it('test_voting', async () => {
    await test_voting.test_voting.deploy({ as: alice })

    const total_before = await test_voting.test_voting.get_total()
    assert(total_before.equals(new Nat(0)))
    const power_before = await test_voting.test_voting.get_power()
    assert(power_before.equals(new Nat(0)))

    await test_voting.test_voting.exec({ as: alice })

    const total_after = await test_voting.test_voting.get_total()
    assert(total_after.equals(new Nat(20000000000000)))
    const power_after = await test_voting.test_voting.get_power()
    assert(power_after.equals(new Nat(0)))
  })

  it('ticket_create_ticket', async () => {
    await ticket_create_ticket.ticket_create_ticket.deploy({ as: alice })
    const t_before = await ticket_create_ticket.ticket_create_ticket.get_t();
    assert(t_before.equals(Option.None()))
    await ticket_create_ticket.ticket_create_ticket.exec({ as: alice });
    const t_after = await ticket_create_ticket.ticket_create_ticket.get_t();
    assert(t_after.equals(Option.Some(new Ticket<string>(ticket_create_ticket.ticket_create_ticket.get_address(), "mystr", new Nat(10)))))
  })

  it('ticket_create_ticket_list_prepend', async () => {
    await ticket_create_ticket_list_prepend.ticket_create_ticket_list_prepend.deploy({ as: alice })
    const res_before = await ticket_create_ticket_list_prepend.ticket_create_ticket_list_prepend.get_res();
    assert(res_before.length == 0)
    await ticket_create_ticket_list_prepend.ticket_create_ticket_list_prepend.exec({ as: alice })
    const res_after = await ticket_create_ticket_list_prepend.ticket_create_ticket_list_prepend.get_res();
    assert(res_after.length == 1)
    assert(res_after[0].equals(new Ticket<string>(ticket_create_ticket_list_prepend.ticket_create_ticket_list_prepend.get_address(), "mystr", new Nat(10))))
  })

  it('ticket_detach_big_map', async () => {
    await ticket_detach_big_map.ticket_detach_big_map.deploy({ as: alice })
    const input_before = await ticket_detach_big_map.ticket_detach_big_map.get_input_value(new Nat(0));
    assert(input_before === undefined)
    const output_before = await ticket_detach_big_map.ticket_detach_big_map.get_output();
    assert(output_before.equals(Option.None()))
    await ticket_detach_big_map.ticket_detach_big_map.init({ as: alice })
    const input_init = await ticket_detach_big_map.ticket_detach_big_map.get_input_value(new Nat(0));
    assert(input_init?.equals(new Ticket<string>(ticket_detach_big_map.ticket_detach_big_map.get_address(), "info", new Nat(1))))
    const output_init = await ticket_detach_big_map.ticket_detach_big_map.get_output();
    assert(output_init.equals(Option.None()))
    await ticket_detach_big_map.ticket_detach_big_map.exec({ as: alice })
    const input_after = await ticket_detach_big_map.ticket_detach_big_map.get_input_value(new Nat(0));
    assert(input_after == undefined)
    const output_after = await ticket_detach_big_map.ticket_detach_big_map.get_output();
    assert(output_after.equals(Option.Some(new Ticket<string>(ticket_detach_big_map.ticket_detach_big_map.get_address(), "info", new Nat(1)))))
  })

  it('ticket_detach_big_map_record', async () => {
    await ticket_detach_big_map_record.ticket_detach_big_map_record.deploy({ as: alice })
    const input_before = await ticket_detach_big_map_record.ticket_detach_big_map_record.get_input_value(new Nat(0));
    assert(input_before === undefined)
    const output_before = await ticket_detach_big_map_record.ticket_detach_big_map_record.get_output();
    assert(output_before.equals(Option.None()))
    await ticket_detach_big_map_record.ticket_detach_big_map_record.init({ as: alice })
    const input_init = await ticket_detach_big_map_record.ticket_detach_big_map_record.get_input_value(new Nat(0));
    assert(input_init?.equals(new ticket_detach_big_map_record.my_record("mystr", new Ticket<string>(ticket_detach_big_map_record.ticket_detach_big_map_record.get_address(), "info", new Nat(1)))))
    const output_init = await ticket_detach_big_map_record.ticket_detach_big_map_record.get_output();
    assert(output_init.equals(Option.None()))
    await ticket_detach_big_map_record.ticket_detach_big_map_record.exec({ as: alice })
    const input_after = await ticket_detach_big_map_record.ticket_detach_big_map_record.get_input_value(new Nat(0));
    assert(input_after == undefined)
    const output_after = await ticket_detach_big_map_record.ticket_detach_big_map_record.get_output();
    assert(output_after.equals(Option.Some(new Ticket<string>(ticket_detach_big_map_record.ticket_detach_big_map_record.get_address(), "info", new Nat(1)))))
  })

  it('ticket_detach_big_map_tuple', async () => {
    await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.deploy({ as: alice })
    const input_before = await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.get_input_value(new Nat(0));
    assert(input_before === undefined)
    const output_before = await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.get_output();
    assert(output_before.equals(Option.None()))
    await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.init({ as: alice })
    const input_init = await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.get_input_value(new Nat(0));
    assert(input_init && input_init[0] == "mystr")
    assert(input_init && input_init[1].equals(new Ticket<string>(ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.get_address(), "info", new Nat(1))))
    const output_init = await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.get_output();
    assert(output_init.equals(Option.None()))
    await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.exec({ as: alice })
    const input_after = await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.get_input_value(new Nat(0));
    assert(input_after == undefined)
    const output_after = await ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.get_output();
    assert(output_after.equals(Option.Some(new Ticket<string>(ticket_detach_big_map_tuple.ticket_detach_big_map_tuple.get_address(), "info", new Nat(1)))))
  })

  it('ticket_detach_map', async () => {
    await ticket_detach_map.ticket_detach_map.deploy({ as: alice })
    const input_before = await ticket_detach_map.ticket_detach_map.get_input();
    assert(input_before.length == 0)
    const output_before = await ticket_detach_map.ticket_detach_map.get_output();
    assert(output_before.equals(Option.None()))
    await ticket_detach_map.ticket_detach_map.init({ as: alice })
    const input_init = await ticket_detach_map.ticket_detach_map.get_input();
    assert(input_init.length == 1)
    assert(input_init[0][0].equals(new Nat(0)))
    assert(input_init[0][1].equals(new Ticket<string>(ticket_detach_map.ticket_detach_map.get_address(), "info", new Nat(1))))
    const output_init = await ticket_detach_map.ticket_detach_map.get_output();
    assert(output_init.equals(Option.None()))
    await ticket_detach_map.ticket_detach_map.exec({ as: alice })
    const input_after = await ticket_detach_map.ticket_detach_map.get_input();
    assert(input_after.length == 0)
    const output_after = await ticket_detach_map.ticket_detach_map.get_output();
    assert(output_after.equals(Option.Some(new Ticket<string>(ticket_detach_map.ticket_detach_map.get_address(), "info", new Nat(1)))))
  })

  it('ticket_detach_map_record', async () => {
    await ticket_detach_map_record.ticket_detach_map_record.deploy({ as: alice })
    const input_before = await ticket_detach_map_record.ticket_detach_map_record.get_input();
    assert(input_before.length == 0)
    const output_before = await ticket_detach_map_record.ticket_detach_map_record.get_output();
    assert(output_before.equals(Option.None()))
    await ticket_detach_map_record.ticket_detach_map_record.init({ as: alice })
    const input_init = await ticket_detach_map_record.ticket_detach_map_record.get_input();
    assert(input_init.length == 1)
    assert(input_init[0][0].equals(new Nat(0)))
    assert(input_init[0][1].equals(new ticket_detach_map_record.my_record("mystr", new Ticket<string>(ticket_detach_map_record.ticket_detach_map_record.get_address(), "info", new Nat(1)))))
    const output_init = await ticket_detach_map_record.ticket_detach_map_record.get_output();
    assert(output_init.equals(Option.None()))
    await ticket_detach_map_record.ticket_detach_map_record.exec({ as: alice })
    const input_after = await ticket_detach_map_record.ticket_detach_map_record.get_input();
    assert(input_after.length == 0)
    const output_after = await ticket_detach_map_record.ticket_detach_map_record.get_output();
    assert(output_after.equals(Option.Some(new Ticket<string>(ticket_detach_map_record.ticket_detach_map_record.get_address(), "info", new Nat(1)))))
  })

  it('ticket_detach_map_tuple', async () => {
    await ticket_detach_map_tuple.ticket_detach_map_tuple.deploy({ as: alice })
    const input_before = await ticket_detach_map_tuple.ticket_detach_map_tuple.get_input();
    assert(input_before.length == 0)
    const output_before = await ticket_detach_map_tuple.ticket_detach_map_tuple.get_output();
    assert(output_before.equals(Option.None()))
    await ticket_detach_map_tuple.ticket_detach_map_tuple.init({ as: alice })
    const input_init = await ticket_detach_map_tuple.ticket_detach_map_tuple.get_input();
    assert(input_init.length == 1)
    assert(input_init[0][0].equals(new Nat(0)))
    assert(input_init[0][1][0] == "mystr")
    assert(input_init[0][1][1].equals(new Ticket<string>(ticket_detach_map_tuple.ticket_detach_map_tuple.get_address(), "info", new Nat(1))))
    const output_init = await ticket_detach_map_tuple.ticket_detach_map_tuple.get_output();
    assert(output_init.equals(Option.None()))
    await ticket_detach_map_tuple.ticket_detach_map_tuple.exec({ as: alice })
    const input_after = await ticket_detach_map_tuple.ticket_detach_map_tuple.get_input();
    assert(input_after.length == 0)
    const output_after = await ticket_detach_map_tuple.ticket_detach_map_tuple.get_output();
    assert(output_after.equals(Option.Some(new Ticket<string>(ticket_detach_map_tuple.ticket_detach_map_tuple.get_address(), "info", new Nat(1)))))
  })

  it('ticket_detach_option', async () => {
    await ticket_detach_option.ticket_detach_option.deploy({ as: alice })
    const input_before = await ticket_detach_option.ticket_detach_option.get_input();
    assert(input_before.equals(Option.None()))
    const output_before = await ticket_detach_option.ticket_detach_option.get_output();
    assert(output_before.equals(Option.None()))
    await ticket_detach_option.ticket_detach_option.init({ as: alice })
    const input_init = await ticket_detach_option.ticket_detach_option.get_input();
    assert(input_init.equals(Option.Some(new Ticket<string>(ticket_detach_option.ticket_detach_option.get_address(), "info", new Nat(1)))))
    const output_init = await ticket_detach_option.ticket_detach_option.get_output();
    assert(output_init.equals(Option.None()))
    await ticket_detach_option.ticket_detach_option.exec({ as: alice })
    const input_after = await ticket_detach_option.ticket_detach_option.get_input();
    assert(input_after.equals(Option.None()))
    const output_after = await ticket_detach_option.ticket_detach_option.get_output();
    assert(output_after.equals(Option.Some(new Ticket<string>(ticket_detach_option.ticket_detach_option.get_address(), "info", new Nat(1)))))
  })

  it('ticket_fun_join_tickets', async () => {
    await ticket_fun_join_tickets.ticket_fun_join_tickets.deploy({ as: alice })
    const res_before = await ticket_fun_join_tickets.ticket_fun_join_tickets.get_res();
    assert(res_before.equals(Option.None()))
    await ticket_fun_join_tickets.ticket_fun_join_tickets.exec({ as: alice });
    const res_after = await ticket_fun_join_tickets.ticket_fun_join_tickets.get_res();
    assert(res_after.equals(Option.Some(new Ticket<string>(ticket_fun_join_tickets.ticket_fun_join_tickets.get_address(), "mystr", new Nat(3)))))
  })

  it('ticket_fun_split_ticket', async () => {
    await ticket_fun_split_ticket.ticket_fun_split_ticket.deploy({ as: alice })
    const res_before = await ticket_fun_split_ticket.ticket_fun_split_ticket.get_res();
    assert(res_before.equals(Option.None()))
    await ticket_fun_split_ticket.ticket_fun_split_ticket.exec({ as: alice });
    const res_after = await ticket_fun_split_ticket.ticket_fun_split_ticket.get_res();
    assert(res_after.equals(Option.Some([new Ticket<string>(ticket_fun_split_ticket.ticket_fun_split_ticket.get_address(), "mystr", new Nat(1)), new Ticket<string>(ticket_fun_split_ticket.ticket_fun_split_ticket.get_address(), "mystr", new Nat(2))])))
  })

  it('ticket_in_view', async () => {
    await ticket_in_view.ticket_in_view.deploy({ as: alice })

    const res = await ticket_in_view.ticket_in_view.view_check({ as: alice })
    assert(res !== undefined && !res)
  })

  it('ticket_read_ticket', async () => {
    await ticket_read_ticket.ticket_read_ticket.deploy({ as: alice })
    const res_before = await ticket_read_ticket.ticket_read_ticket.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    await ticket_read_ticket.ticket_read_ticket.exec({ as: alice })
    const res_after = await ticket_read_ticket.ticket_read_ticket.get_res()
    assert(res_after[0].equals(ticket_read_ticket.ticket_read_ticket.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
  })

  it('ticket_read_ticket_arg', async () => {
    await ticket_read_ticket_arg.ticket_read_ticket_arg.deploy({ as: alice })
    const res_before = await ticket_read_ticket_arg.ticket_read_ticket_arg.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    await ticket_read_ticket_arg.ticket_read_ticket_arg.exec({ as: alice })
    const res_after = await ticket_read_ticket_arg.ticket_read_ticket_arg.get_res()
    assert(res_after[0].equals(ticket_read_ticket_arg.ticket_read_ticket_arg.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
  })

  it('ticket_read_ticket_arg_list', async () => {
    await ticket_read_ticket_arg_list.ticket_read_ticket_arg_list.deploy({ as: alice })
    const res_before = await ticket_read_ticket_arg_list.ticket_read_ticket_arg_list.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    await ticket_read_ticket_arg_list.ticket_read_ticket_arg_list.exec({ as: alice })
    const res_after = await ticket_read_ticket_arg_list.ticket_read_ticket_arg_list.get_res()
    assert(res_after[0].equals(ticket_read_ticket_arg_list.ticket_read_ticket_arg_list.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
  })

  it('ticket_read_ticket_arg_record_list', async () => {
    await ticket_read_ticket_arg_record_list.ticket_read_ticket_arg_record_list.deploy({ as: alice })
    const res_before = await ticket_read_ticket_arg_record_list.ticket_read_ticket_arg_record_list.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    await ticket_read_ticket_arg_record_list.ticket_read_ticket_arg_record_list.exec({ as: alice })
    const res_after = await ticket_read_ticket_arg_record_list.ticket_read_ticket_arg_record_list.get_res()
    assert(res_after[0].equals(ticket_read_ticket_arg_record_list.ticket_read_ticket_arg_record_list.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
  })

  it('ticket_read_ticket_arg_record_list2', async () => {
    await ticket_read_ticket_arg_record_list2.ticket_read_ticket_arg_record_list2.deploy({ as: alice })
    const res_before = await ticket_read_ticket_arg_record_list2.ticket_read_ticket_arg_record_list2.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    const ra_before = await ticket_read_ticket_arg_record_list2.ticket_read_ticket_arg_record_list2.get_ra();
    assert(ra_before.equals(new Nat(0)))
    await ticket_read_ticket_arg_record_list2.ticket_read_ticket_arg_record_list2.exec({ as: alice })
    const res_after = await ticket_read_ticket_arg_record_list2.ticket_read_ticket_arg_record_list2.get_res()
    assert(res_after[0].equals(ticket_read_ticket_arg_record_list2.ticket_read_ticket_arg_record_list2.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
    const ra_after = await ticket_read_ticket_arg_record_list2.ticket_read_ticket_arg_record_list2.get_ra();
    assert(ra_after.equals(new Nat(2)))
  })

  it('ticket_read_ticket_arg_tuple_2_list', async () => {
    await ticket_read_ticket_arg_tuple_2_list.ticket_read_ticket_arg_tuple_2_list.deploy({ as: alice })
    const res_before = await ticket_read_ticket_arg_tuple_2_list.ticket_read_ticket_arg_tuple_2_list.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    await ticket_read_ticket_arg_tuple_2_list.ticket_read_ticket_arg_tuple_2_list.exec({ as: alice })
    const res_after = await ticket_read_ticket_arg_tuple_2_list.ticket_read_ticket_arg_tuple_2_list.get_res()
    assert(res_after[0].equals(ticket_read_ticket_arg_tuple_2_list.ticket_read_ticket_arg_tuple_2_list.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
  })

  it('ticket_read_ticket_arg_tuple_3_list', async () => {
    await ticket_read_ticket_arg_tuple_3_list.ticket_read_ticket_arg_tuple_3_list.deploy({ as: alice })
    const res_before = await ticket_read_ticket_arg_tuple_3_list.ticket_read_ticket_arg_tuple_3_list.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    await ticket_read_ticket_arg_tuple_3_list.ticket_read_ticket_arg_tuple_3_list.exec({ as: alice })
    const res_after = await ticket_read_ticket_arg_tuple_3_list.ticket_read_ticket_arg_tuple_3_list.get_res()
    assert(res_after[0].equals(ticket_read_ticket_arg_tuple_3_list.ticket_read_ticket_arg_tuple_3_list.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
  })

  it('ticket_read_ticket_record', async () => {
    await ticket_read_ticket_record.ticket_read_ticket_record.deploy({ as: alice })
    const res_before = await ticket_read_ticket_record.ticket_read_ticket_record.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    await ticket_read_ticket_record.ticket_read_ticket_record.exec({ as: alice })
    const res_after = await ticket_read_ticket_record.ticket_read_ticket_record.get_res()
    assert(res_after[0].equals(ticket_read_ticket_record.ticket_read_ticket_record.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
  })

  it('ticket_read_ticket_record_list', async () => {
    await ticket_read_ticket_record_list.ticket_read_ticket_record_list.deploy({ as: alice })
    const res_before = await ticket_read_ticket_record_list.ticket_read_ticket_record_list.get_res()
    assert(res_before[0].equals(alice.get_address()))
    assert(res_before[1] == "")
    assert(res_before[2].equals(new Nat(0)))
    await ticket_read_ticket_record_list.ticket_read_ticket_record_list.exec({ as: alice })
    const res_after = await ticket_read_ticket_record_list.ticket_read_ticket_record_list.get_res()
    assert(res_after[0].equals(ticket_read_ticket_record_list.ticket_read_ticket_record_list.get_address()))
    assert(res_after[1] == "my_ticket")
    assert(res_after[2].equals(new Nat(10)))
  })

  it('ticket_record_list_var_0_0', async () => {
    await ticket_record_list_var_0_0.ticket_record_list_var_0_0.deploy({ as: alice })
    const res_before = await ticket_record_list_var_0_0.ticket_record_list_var_0_0.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_0_0.ticket_record_list_var_0_0.exec({ as: alice });
    const res_after = await ticket_record_list_var_0_0.ticket_record_list_var_0_0.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_0_1', async () => {
    await ticket_record_list_var_0_1.ticket_record_list_var_0_1.deploy({ as: alice })
    const res_before = await ticket_record_list_var_0_1.ticket_record_list_var_0_1.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_0_1.ticket_record_list_var_0_1.exec({ as: alice });
    const res_after = await ticket_record_list_var_0_1.ticket_record_list_var_0_1.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_0_2', async () => {
    await ticket_record_list_var_0_2.ticket_record_list_var_0_2.deploy({ as: alice })
    const res_before = await ticket_record_list_var_0_2.ticket_record_list_var_0_2.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_0_2.ticket_record_list_var_0_2.exec({ as: alice });
    const res_after = await ticket_record_list_var_0_2.ticket_record_list_var_0_2.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_1_0', async () => {
    await ticket_record_list_var_1_0.ticket_record_list_var_1_0.deploy({ as: alice })
    const res_before = await ticket_record_list_var_1_0.ticket_record_list_var_1_0.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_1_0.ticket_record_list_var_1_0.exec({ as: alice });
    const res_after = await ticket_record_list_var_1_0.ticket_record_list_var_1_0.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_1_1', async () => {
    await ticket_record_list_var_1_1.ticket_record_list_var_1_1.deploy({ as: alice })
    const res_before = await ticket_record_list_var_1_1.ticket_record_list_var_1_1.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_1_1.ticket_record_list_var_1_1.exec({ as: alice });
    const res_after = await ticket_record_list_var_1_1.ticket_record_list_var_1_1.get_res();
    assert(res_after.equals(new Nat(6)))

  })

  it('ticket_record_list_var_1_2', async () => {
    await ticket_record_list_var_1_2.ticket_record_list_var_1_2.deploy({ as: alice })
    const res_before = await ticket_record_list_var_1_2.ticket_record_list_var_1_2.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_1_2.ticket_record_list_var_1_2.exec({ as: alice });
    const res_after = await ticket_record_list_var_1_2.ticket_record_list_var_1_2.get_res();
    assert(res_after.equals(new Nat(6)))

  })

  it('ticket_record_list_var_2_0', async () => {
    await ticket_record_list_var_2_0.ticket_record_list_var_2_0.deploy({ as: alice })
    const res_before = await ticket_record_list_var_2_0.ticket_record_list_var_2_0.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_2_0.ticket_record_list_var_2_0.exec({ as: alice });
    const res_after = await ticket_record_list_var_2_0.ticket_record_list_var_2_0.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_2_1', async () => {
    await ticket_record_list_var_2_1.ticket_record_list_var_2_1.deploy({ as: alice })
    const res_before = await ticket_record_list_var_2_1.ticket_record_list_var_2_1.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_2_1.ticket_record_list_var_2_1.exec({ as: alice });
    const res_after = await ticket_record_list_var_2_1.ticket_record_list_var_2_1.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_2_2', async () => {
    await ticket_record_list_var_2_2.ticket_record_list_var_2_2.deploy({ as: alice })
    const res_before = await ticket_record_list_var_2_2.ticket_record_list_var_2_2.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_2_2.ticket_record_list_var_2_2.exec({ as: alice });
    const res_after = await ticket_record_list_var_2_2.ticket_record_list_var_2_2.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_3_0', async () => {
    await ticket_record_list_var_3_0.ticket_record_list_var_3_0.deploy({ as: alice })
    const res_before = await ticket_record_list_var_3_0.ticket_record_list_var_3_0.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_3_0.ticket_record_list_var_3_0.exec({ as: alice });
    const res_after = await ticket_record_list_var_3_0.ticket_record_list_var_3_0.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_3_1', async () => {
    await ticket_record_list_var_3_1.ticket_record_list_var_3_1.deploy({ as: alice })
    const res_before = await ticket_record_list_var_3_1.ticket_record_list_var_3_1.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_3_1.ticket_record_list_var_3_1.exec({ as: alice });
    const res_after = await ticket_record_list_var_3_1.ticket_record_list_var_3_1.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_record_list_var_3_2', async () => {
    await ticket_record_list_var_3_2.ticket_record_list_var_3_2.deploy({ as: alice })
    const res_before = await ticket_record_list_var_3_2.ticket_record_list_var_3_2.get_res();
    assert(res_before.equals(new Nat(0)))
    await ticket_record_list_var_3_2.ticket_record_list_var_3_2.exec({ as: alice });
    const res_after = await ticket_record_list_var_3_2.ticket_record_list_var_3_2.get_res();
    assert(res_after.equals(new Nat(6)))
  })

  it('ticket_store_map', async () => {
    await ticket_store_map.ticket_store_map.deploy({ as: alice })
    const mt_before = await ticket_store_map.ticket_store_map.get_mt();
    assert(mt_before.length == 0);
    const info_before = await ticket_store_map.ticket_store_map.get_info()
    assert(info_before.equals(Option.None()));
    await ticket_store_map.ticket_store_map.exec({ as: alice })
    const mt_after = await ticket_store_map.ticket_store_map.get_mt();
    assert(mt_after.length == 0);
    const info_after = await ticket_store_map.ticket_store_map.get_info()
    assert(info_after.equals(Option.Some([ticket_store_map.ticket_store_map.get_address(), "info", new Nat(1)])));
  })

  it('ticket_store_option', async () => {
    await ticket_store_option.ticket_store_option.deploy({ as: alice })
    const ot_before = await ticket_store_option.ticket_store_option.get_ot();
    assert(ot_before.equals(Option.None()));
    const info_before = await ticket_store_option.ticket_store_option.get_info()
    assert(info_before.equals(Option.None()));
    await ticket_store_option.ticket_store_option.exec({ as: alice })
    const ot_after = await ticket_store_option.ticket_store_option.get_ot();
    assert(ot_after.equals(Option.None()));
    const info_after = await ticket_store_option.ticket_store_option.get_info()
    assert(info_after.equals(Option.Some([ticket_store_option.ticket_store_option.get_address(), "info", new Nat(1)])));
  })

  it('ticket_var_detach_option', async () => {
    await ticket_var_detach_option.ticket_var_detach_option.deploy({ as: alice })
    const info_before = await ticket_var_detach_option.ticket_var_detach_option.get_info()
    assert(info_before.equals(Option.None()));
    await ticket_var_detach_option.ticket_var_detach_option.exec({ as: alice })
    const info_after = await ticket_var_detach_option.ticket_var_detach_option.get_info()
    assert(info_after.equals(Option.Some([ticket_var_detach_option.ticket_var_detach_option.get_address(), "info", new Nat(1)])));
  })

  it('ticket_var_list', async () => {
    await ticket_var_list.ticket_var_list.deploy({ as: alice })
    const info_before = await ticket_var_list.ticket_var_list.get_info()
    assert(info_before.equals(Option.None()));
    await ticket_var_list.ticket_var_list.exec({ as: alice })
    const info_after = await ticket_var_list.ticket_var_list.get_info()
    assert(info_after.equals(Option.Some([ticket_var_list.ticket_var_list.get_address(), "info", new Nat(1)])));
  })

  it('ticket_var_option', async () => {
    await ticket_var_option.ticket_var_option.deploy({ as: alice })
    const info_before = await ticket_var_option.ticket_var_option.get_info()
    assert(info_before.equals(Option.None()));
    await ticket_var_option.ticket_var_option.exec({ as: alice })
    const info_after = await ticket_var_option.ticket_var_option.get_info()
    assert(info_after.equals(Option.Some([ticket_var_option.ticket_var_option.get_address(), "info", new Nat(1)])));
  })

  it('ticket_var_or_left', async () => {
    await ticket_var_or_left.ticket_var_or_left.deploy({ as: alice })
    const info_before = await ticket_var_or_left.ticket_var_or_left.get_info()
    assert(info_before.equals(Option.None()));
    await ticket_var_or_left.ticket_var_or_left.exec({ as: alice })
    const info_after = await ticket_var_or_left.ticket_var_or_left.get_info()
    assert(info_after.equals(Option.Some([ticket_var_or_left.ticket_var_or_left.get_address(), "info", new Nat(1)])));
  })

  it('ticket_var_or_right', async () => {
    await ticket_var_or_right.ticket_var_or_right.deploy({ as: alice })
    const info_before = await ticket_var_or_right.ticket_var_or_right.get_info()
    assert(info_before.equals(Option.None()));
    await ticket_var_or_right.ticket_var_or_right.exec({ as: alice })
    const info_after = await ticket_var_or_right.ticket_var_or_right.get_info()
    assert(info_after.equals(Option.Some([ticket_var_or_right.ticket_var_or_right.get_address(), "info", new Nat(1)])));
  })

  it('ticket_var_simple', async () => {
    await ticket_var_simple.ticket_var_simple.deploy({ as: alice })
    const info_before = await ticket_var_simple.ticket_var_simple.get_info()
    assert(info_before.equals(Option.None()));
    await ticket_var_simple.ticket_var_simple.exec({ as: alice })
    const info_after = await ticket_var_simple.ticket_var_simple.get_info()
    assert(info_after.equals(Option.Some([ticket_var_simple.ticket_var_simple.get_address(), "info", new Nat(1)])));
  })

  it('timelock', async () => {
    await timelock.timelock.deploy({ as: alice })

    const res_before = await timelock.timelock.get_res()
    assert(res_before.equals(new Bytes("00")));

    await timelock.timelock.exec(
      new Chest_key("f18ca686eae9c4a0af9afaddaeb8f189f2bcdd85f2f8aec380e0a4b0d3fb98b1aae1a28bc8b1dce091def4ca96978ddabdf782a2acf5d69bbdbb9cedcfb980989298bcb4dfd1dce6df8fbad98180cbafaccaa2cfbea080ee83c0fbfdbe85c6aefbfeb095bdbbedc9acc0d8c495cf9db4b4c4c8f4ad9e96e8b9fdbf9792fbc090fea1f9c4cd95b283cafdec8eb5e5a9ddbac1adeff3b6cbfeb3bcf1d7e8c4ab97a59697d7e987ad92eb87b99cde93a09a949e92a6d4d092d99c9495e5d8d6a2b5acd5e1e298feaac8f3d8cecde4ea8d8badc0b7f3e283bfabfeb8ff8caec1ea92faacc68f83c38a988bc5a8cedc96bfb7a7d6aeeaa38b8bdb88a99ab994e089edb6c8ee84aead85cdd1abc3d481d3d29cc8b9a0b79e92dfb9ba90cfe8d5ba9098cfa7d4b70898e8a1d498b2a3e7a7d4aab294a2e484e5ea8af6e1b8a9d7dcdbfbffffc4f892a587adcdf1ddb6b28ce586e2c1c7d6bab8b8f48697fd8ccc8595f9e7e39cf6c2b48ffeeae9f2df9ed5dbc0f290edc8e5d08baccb8ad6df80a6f2bf8bab99fee09ac8f3859fcd87bdaed3a2c5bde49eb7b8978fb4b7eb8ecdbccfb3c1aeb089fedeeba3f191dadece97d3cc92c285f0fbc087c8d1ca8fa1cebecfc7c2d7d29690f8f7d4b6eec3c59087c2ea8feec3c5e8f1bb8da6d7aff2a2fbbec6c8d8e7a180f2fdeed3c0c6e1bafdf5e493c5a6e29bbec7be8aa5e3e7a7edef92c793d1a7a9c9ae86c5facba2b7b7c2b290aec3f288c385e6e8b9868ae7ad98c09db3ceb2eac9d6fdabb1a3f180b785c5d1b6a8999c99e5aa9686f38995b19de3b0b78c8af88398bdf707adbfe5f8f0ec90c1ecfda19bffe6f7c2e993f397a997ffc192aeb8b5bdf0dd9cedcbadbad1d5e5f5c6bc96c5fecca5b299dfc2abb499e798a3acabcf8e82ea83bdf586cffccdf8c7928fa892dad2c3ca9ce88992c286f7aed189aad9def7fcd6aca18accf398bdba8b94bc94eddf9599899d8abbabbbbbc3e7aba7c1cdec93eeb9e184fcdbe2cd9499b7a6b38afb95fdbde4b8a1ddc6a1b1bfd8b9c7a5ccd38eafc0dee8cbc796d49eabb983e88882c0998ecd95cab2adb8f3dfbf9ff38191afde8fa69f97edb3c197a2a7d2aba58dd88eafe59d9abae39986f3a4c3c0daebbcc3dbf4b4cfd8eee395defac8ed8fedb9f5fbf9a5cad7d7d5c584abf8dfb78197a5c4d587dff596aae6f5cfd5df8bf1ae85f5e0ced4e086f6cd958bdb899afde790d7c7b30182b8aecef88ede978981a0c4ffe8db94fdba03"),
      new Chest("dae4b7998aefb7e58aa6d8f59893e4e3aeb0cdaaf2ccada8e9eef7ac8efed8b0e0a7b8f5d0bbffcbdc88e4a1f9a3fba6de8087dbb085f0efb38e86e3f09cf9b0a6fea0dbaad0e68fe1bd98e3a6a7f8bfcee5d0b595abaf9aa5a4c3dcd3e2c38acbbcc9cffdd193cc8390ccc7f3f8a6a3d9b19ac390e6c6d6e2a3cdf9e6d7fec7dffcaeeddaee8eceeac288df939ed0bfadb696c7aac3b4fce1939ed5f0afb2bff2b9e5c1f4bc8cd196fe8490ccc1d2eb9798bdd1e5cbefceeac5c4aa8cec849aeaaa8bd9bac19d90b3c9cd94d5d0c68ff3b9a49ec1f9a9cfbba6cacdafa6e692a4949ba399d083aff4e3cae1ece8c5a2c6bb9dae848083c2c9e5dc98bf9df5ac8ec5c8eae1b7c9a9ee92fee8f0edb7ffecddc5a2c0bb91ae9fc2e0c18f92f0dda3e1abfb027b88ac13b80d13c2540181a679f1021aa4aa94ec1faf384e0000001f0c62bca2656e74df9b28296aa17e03bd476d28d813fd2f44d75e3259d0dc4b"),
      new Nat(3600),
      { as: alice })

    const res_after = await timelock.timelock.get_res()
    assert(res_after.equals(new Bytes("050100000009617263686574797065")));
  })

  it('timelock_hardcoded', async () => {
    await timelock_hardcoded.timelock_hardcoded.deploy({ as: alice })

    const res_before = await timelock_hardcoded.timelock_hardcoded.get_res()
    assert(res_before.equals(new Bytes("00")));

    await timelock_hardcoded.timelock_hardcoded.exec({ as: alice })

    const res_after = await timelock_hardcoded.timelock_hardcoded.get_res()
    assert(res_after.equals(new Bytes("050100000009617263686574797065")));
  })

  it('transfer_call', async () => {
    await transfer_call.transfer_call.deploy({ as: alice })

    const res_before = await transfer_call.transfer_call.get_res()
    assert(res_before.equals(new Nat(0)))

    await transfer_call.transfer_call.exec(transfer_call.transfer_call.get_address(), { as: alice })

    const res_after = await transfer_call.transfer_call.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('transfer_entrypoint', async () => {
    await transfer_entrypoint.transfer_entrypoint.deploy({ as: alice })

    const res_before = await transfer_entrypoint.transfer_entrypoint.get_res()
    assert(res_before.equals(new Nat(0)))

    await transfer_entrypoint.transfer_entrypoint.exec({ as: alice })

    const res_after = await transfer_entrypoint.transfer_entrypoint.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('transfer_entrypoint2', async () => {
    await transfer_entrypoint2.transfer_entrypoint2.deploy({ as: alice })

    const res_before = await transfer_entrypoint2.transfer_entrypoint2.get_res()
    assert(res_before.equals(new Nat(0)))

    await transfer_entrypoint2.transfer_entrypoint2.exec({ as: alice })

    const res_after = await transfer_entrypoint2.transfer_entrypoint2.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('transfer_op', async () => {
    await transfer_op.transfer_op.deploy({ amount: new Tez(1), as: alice })

    const alice_balance_before = await alice.get_balance()
    const contract_balance_before = await transfer_op.transfer_op.get_balance()

    await transfer_op.transfer_op.exec(alice.get_address(), { as: bob })

    const alice_balance_after = await alice.get_balance()
    const contract_balance_after = await transfer_op.transfer_op.get_balance()

    assert(alice_balance_before.plus(new Tez(1)).equals(alice_balance_after))
    assert(contract_balance_after.plus(new Tez(1)).equals(contract_balance_before))
  })

  it('transfer_require_entrypoint', async () => {
    await transfer_require_entrypoint.transfer_require_entrypoint.deploy({ as: alice })

    const res_before = await transfer_require_entrypoint.transfer_require_entrypoint.get_res()
    assert(res_before.equals(new Nat(0)))

    await transfer_require_entrypoint.transfer_require_entrypoint.exec({ as: alice })

    const res_after = await transfer_require_entrypoint.transfer_require_entrypoint.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('transfer_self', async () => {
    await transfer_self.transfer_self.deploy({ as: alice })

    const res_before = await transfer_self.transfer_self.get_res()
    assert(res_before.equals(new Nat(0)))

    await transfer_self.transfer_self.exec({ as: alice })

    const res_after = await transfer_self.transfer_self.get_res()
    assert(res_after.equals(new Nat(1)))
  })

  it('transfer_simple', async () => {
    await transfer_simple.transfer_simple.deploy({ amount: new Tez(1), as: alice })

    const alice_balance_before = await alice.get_balance()
    const contract_balance_before = await transfer_simple.transfer_simple.get_balance()

    await transfer_simple.transfer_simple.exec(alice.get_address(), { as: bob })

    const alice_balance_after = await alice.get_balance()
    const contract_balance_after = await transfer_simple.transfer_simple.get_balance()

    assert(alice_balance_before.plus(new Tez(1)).equals(alice_balance_after))
    assert(contract_balance_after.plus(new Tez(1)).equals(contract_balance_before))
  })

  it('transfer_simple_with_entrypoint', async () => {
    await transfer_simple_with_entrypoint.transfer_simple_with_entrypoint.deploy({ amount: new Tez(1), as: alice })

    const alice_balance_before = await alice.get_balance()
    const contract_balance_before = await transfer_simple_with_entrypoint.transfer_simple_with_entrypoint.get_balance()

    await transfer_simple_with_entrypoint.transfer_simple_with_entrypoint.exec(alice.get_address(), { as: bob })

    const alice_balance_after = await alice.get_balance()
    const contract_balance_after = await transfer_simple_with_entrypoint.transfer_simple_with_entrypoint.get_balance()

    assert(alice_balance_before.plus(new Tez(1)).equals(alice_balance_after))
    assert(contract_balance_after.plus(new Tez(1)).equals(contract_balance_before))
  })

  it('tuple_in_contains', async () => {
    await tuple_in_contains.tuple_in_contains.deploy({ as: alice })

    const my_asset_before = await tuple_in_contains.tuple_in_contains.get_my_asset();
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].id0 == "id")
    assert(my_asset_before[0][0].id1.equals(new Int(0)))
    assert(my_asset_before[0][1].equals(new Nat(0)))
    const res_before = await tuple_in_contains.tuple_in_contains.get_res()
    assert(res_before == false)

    await tuple_in_contains.tuple_in_contains.exec({ as: alice })

    const res_after = await tuple_in_contains.tuple_in_contains.get_res()
    assert(res_after == true)
    const my_asset_after = await tuple_in_contains.tuple_in_contains.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].id0 == "id")
    assert(my_asset_after[0][0].id1.equals(new Int(0)))
    assert(my_asset_after[0][1].equals(new Nat(0)))
  })

  it('type_never', async () => {
    await type_never.type_never.deploy({ as: alice })
    const res = await type_never.type_never.get_res();
    assert(res.equals(Or.Right<Micheline, Nat>(new Nat(1))), "Invalid Value")
  })

  it('type_or', async () => {
    await type_or.type_or.deploy({ as: alice })

    const ls = await type_or.type_or.get_ls()
    assert(ls.equals(Or.Left(new Nat(1))))
    const lc = await type_or.type_or.get_lc()
    assert(lc.equals(Or.Left(new Nat(1))))
    const rs = await type_or.type_or.get_rs()
    assert(rs.equals(Or.Right<Nat, string>("mystr")))
    const rc = await type_or.type_or.get_rc()
    assert(rc.equals(Or.Right<Nat, string>("mystr")))
  })

  it('type_set_enum_param', async () => {
    await type_set_enum_param.type_set_enum_param.deploy({ as: alice })

    const res_before = await type_set_enum_param.type_set_enum_param.get_res()
    assert(res_before.length == 0)

    await type_set_enum_param.type_set_enum_param.set_value(
      [
        new type_set_enum_param.e_1(),
        new type_set_enum_param.e_2(new Nat(2)),
        new type_set_enum_param.e_3("mystr"),
        new type_set_enum_param.e_4([new Bytes("ff"), true])
      ], { as: alice })

    const res_after = await type_set_enum_param.type_set_enum_param.get_res()
    assert(res_after.length == 4)
    assert(res_after[0].equals(new type_set_enum_param.e_1()))
    assert(res_after[1].equals(new type_set_enum_param.e_2(new Nat(2))))
    assert(res_after[2].equals(new type_set_enum_param.e_3("mystr")))
    assert(res_after[3].equals(new type_set_enum_param.e_4([new Bytes("ff"), true])))
  })

  it('type_storage_or', async () => {
    await type_storage_or.type_storage_or.deploy({ as: alice })

    const x_before = await type_storage_or.type_storage_or.get_x()
    assert(x_before.equals(Or.Left(new Nat(2))))

    await type_storage_or.type_storage_or.exec({ as: alice })

    const x_after = await type_storage_or.type_storage_or.get_x()
    assert(x_after.equals(Or.Right<Nat, string>("mystr")))
  })

  it('typetuple', async () => {
    await typetuple.typetuple.deploy({ as: alice })

    const v = await typetuple.typetuple.get_v()
    assert(v[0].equals(new Int(1)))
    assert(v[1] == '')
  })

  it('unused_argument', async () => {
    await unused_argument.unused_argument.deploy({ as: alice })

    const n_before = await unused_argument.unused_argument.get_n()
    assert(n_before.equals(new Nat(0)))

    await unused_argument.unused_argument.e("", new Nat(2), { as: alice })

    const n_after = await unused_argument.unused_argument.get_n()
    assert(n_after.equals(new Nat(2)))
  })

  it('unused_variable', async () => {
    await unused_variable.unused_variable.deploy({ as: alice })

    const n_before = await unused_variable.unused_variable.get_n()
    assert(n_before.equals(new Nat(0)))

    await unused_variable.unused_variable.e({ as: alice })

    const n_after = await unused_variable.unused_variable.get_n()
    assert(n_after.equals(new Nat(2)))
  })

  it('unused_variable_opt', async () => {
    await unused_variable_opt.unused_variable_opt.deploy({ as: alice })

    const n_before = await unused_variable_opt.unused_variable_opt.get_n()
    assert(n_before.equals(new Nat(0)))

    await unused_variable_opt.unused_variable_opt.e({ as: alice })

    const n_after = await unused_variable_opt.unused_variable_opt.get_n()
    assert(n_after.equals(new Nat(2)))
  })

  it('update_minus_equal', async () => {
    await update_minus_equal.update_minus_equal.deploy({ as: alice })

    const my_asset_before = await update_minus_equal.update_minus_equal.get_my_asset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Nat(10)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Nat(11)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Nat(12)))
    const res_before = await update_minus_equal.update_minus_equal.get_res()
    assert(res_before.equals(new Int(0)))

    await update_minus_equal.update_minus_equal.exec({ as: alice })

    const my_asset_after = await update_minus_equal.update_minus_equal.get_my_asset();
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Nat(10)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Nat(8)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Nat(12)))
    const res_after = await update_minus_equal.update_minus_equal.get_res()
    assert(res_after.equals(new Int(0)))
  })

  it('var_mult_ids', async () => {
    await var_mult_ids.var_mult_ids.deploy({ as: alice })

    const x_before = await var_mult_ids.var_mult_ids.get_x()
    assert(x_before.equals(new Nat(0)))

    const y_before = await var_mult_ids.var_mult_ids.get_y()
    assert(y_before.equals(new Nat(0)))

    await var_mult_ids.var_mult_ids.exec({ as: alice })

    const x_after = await var_mult_ids.var_mult_ids.get_x()
    assert(x_after.equals(new Nat(1)))

    const y_after = await var_mult_ids.var_mult_ids.get_y()
    assert(y_after.equals(new Nat(2)))
  })

  it('var_mult_ids_3', async () => {
    await var_mult_ids_3.var_mult_ids_3.deploy({ as: alice })

    const x_before = await var_mult_ids_3.var_mult_ids_3.get_x()
    assert(x_before.equals(new Nat(0)))

    const y_before = await var_mult_ids_3.var_mult_ids_3.get_y()
    assert(y_before.equals(new Nat(0)))

    const z_before = await var_mult_ids_3.var_mult_ids_3.get_z()
    assert(z_before.equals(new Nat(0)))

    await var_mult_ids_3.var_mult_ids_3.exec({ as: alice })

    const x_after = await var_mult_ids_3.var_mult_ids_3.get_x()
    assert(x_after.equals(new Nat(1)))

    const y_after = await var_mult_ids_3.var_mult_ids_3.get_y()
    assert(y_after.equals(new Nat(2)))

    const z_after = await var_mult_ids_3.var_mult_ids_3.get_z()
    assert(z_after.equals(new Nat(3)))
  })

  it('var_mult_ids_complex', async () => {
    await var_mult_ids_complex.var_mult_ids_complex.deploy({ as: alice })

    const x_before = await var_mult_ids_complex.var_mult_ids_complex.get_x()
    assert(x_before.equals(new Nat(0)))

    const y_before = await var_mult_ids_complex.var_mult_ids_complex.get_y()
    assert(y_before[0].equals(new Nat(0)))
    assert(y_before[1].equals(new Nat(0)))

    await var_mult_ids_complex.var_mult_ids_complex.exec({ as: alice })

    const x_after = await var_mult_ids_complex.var_mult_ids_complex.get_x()
    assert(x_after.equals(new Nat(1)))

    const y_after = await var_mult_ids_complex.var_mult_ids_complex.get_y()
    assert(y_after[0].equals(new Nat(2)))
    assert(y_after[1].equals(new Nat(3)))
  })

  it('var_mult_tickets', async () => {
    await var_mult_tickets.var_mult_tickets.deploy({ as: alice })

    const x_before = await var_mult_tickets.var_mult_tickets.get_x()
    assert(x_before.equals(Option.None()))

    const y_before = await var_mult_tickets.var_mult_tickets.get_y()
    assert(y_before.equals(Option.None()))

    await var_mult_tickets.var_mult_tickets.exec({ as: alice })

    const x_after = await var_mult_tickets.var_mult_tickets.get_x()
    assert(x_after.equals(Option.Some(new Ticket(var_mult_tickets.var_mult_tickets.get_address(), new Unit(), new Nat(1)))))

    const y_after = await var_mult_tickets.var_mult_tickets.get_y()
    assert(y_after.equals(Option.Some(new Ticket(var_mult_tickets.var_mult_tickets.get_address(), new Unit(), new Nat(2)))))
  })

  it('var_without_effect', async () => {
    await var_without_effect.var_without_effect.deploy({ as: alice })

    await var_without_effect.var_without_effect.exec({ as: alice })
  })

  it('variable_in_container', async () => {
    await variable_in_container.variable_in_container.deploy({ as: alice })

    const v_before = await variable_in_container.variable_in_container.get_v()
    assert(v_before.equals(new variable_in_container.rt([], [], [])))

    await variable_in_container.variable_in_container.exec({ as: alice })

    const v_after = await variable_in_container.variable_in_container.get_v()
    assert(v_after.equals(new variable_in_container.rt([new Nat(0)], [new Nat(0), new Nat(0)], [[new Nat(0), new Nat(0)]])))
  })

  it('very_simple', async () => {
    await very_simple.very_simple.deploy({ as: alice })

    const res_before = await very_simple.very_simple.get_res()
    assert(res_before.equals(new Nat(0)))

    await very_simple.very_simple.exec({ as: alice })

    const res_after = await very_simple.very_simple.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('view_0', async () => {
    await view_0.view_0.deploy({ as: alice })

    const res_before = await view_0.view_0.get_res()
    assert(res_before.equals(Option.None()))

    const v = await view_0.view_0.view_get({ as: alice });
    assert(v?.equals(new Nat(2)))

    await view_0.view_0.exec({ as: alice })

    const res_after = await view_0.view_0.get_res()
    assert(res_after.equals(Option.Some(new Nat(2))))
  })

  it('view_all_chain', async () => {
    await view_all_chain.view_all_chain.deploy({ as: alice })

    const n_before = await view_all_chain.view_all_chain.get_n()
    assert(n_before.equals(Option.None()))

    const v = await view_all_chain.view_all_chain.view_get({ as: alice });
    assert(v?.equals(new Nat(0)))

    await view_all_chain.view_all_chain.exec({ as: alice })

    const n_after = await view_all_chain.view_all_chain.get_n()
    assert(n_after.equals(Option.Some(new Nat(0))))
  })

  it('view_args_0', async () => {
    await view_args_0.view_args_0.deploy({ as: alice })

    const res_before = await view_args_0.view_args_0.get_res()
    assert(res_before.equals(Option.None()))

    const v = await view_args_0.view_args_0.view_get(new Nat(2), { as: alice });
    assert(v?.equals(new Nat(2)))

    await view_args_0.view_args_0.exec({ as: alice })

    const res_after = await view_args_0.view_args_0.get_res()
    assert(res_after.equals(Option.Some(new Nat(2))))
  })

  it('view_args_1', async () => {
    await view_args_1.view_args_1.deploy({ as: alice })

    const res_before = await view_args_1.view_args_1.get_res()
    assert(res_before.equals(Option.None()))

    const v = await view_args_1.view_args_1.view_get(new Nat(1), "toto", new Bytes("123456"), { as: alice });
    assert(v?.equals(new Nat(8)))

    await view_args_1.view_args_1.exec({ as: alice })

    const res_after = await view_args_1.view_args_1.get_res()
    assert(res_after.equals(Option.Some(new Nat(8))))
  })

  it('view_args_storage_0', async () => {
    await view_args_storage_0.view_args_storage_0.deploy({ as: alice })

    const res_before = await view_args_storage_0.view_args_storage_0.get_res()
    assert(res_before.equals(Option.None()))
    const n_before = await view_args_storage_0.view_args_storage_0.get_n()
    assert(n_before.equals(new Nat(2)))

    const v = await view_args_storage_0.view_args_storage_0.view_get(new Nat(2), { as: alice });
    assert(v?.equals(new Nat(4)))

    await view_args_storage_0.view_args_storage_0.exec({ as: alice })

    const res_after = await view_args_storage_0.view_args_storage_0.get_res()
    assert(res_after.equals(Option.Some(new Nat(4))))
    const n_after = await view_args_storage_0.view_args_storage_0.get_n()
    assert(n_after.equals(new Nat(2)))
  })

  it('view_args_storage_1', async () => {
    await view_args_storage_1.view_args_storage_1.deploy({ as: alice })

    const res_before = await view_args_storage_1.view_args_storage_1.get_res()
    assert(res_before.equals(Option.None()))
    const k_before = await view_args_storage_1.view_args_storage_1.get_k()
    assert(k_before.equals(new Int(10)))
    const str_before = await view_args_storage_1.view_args_storage_1.get_str()
    assert(str_before == "abc")

    const v = await view_args_storage_1.view_args_storage_1.view_get(new Nat(1), "toto", new Bytes("123456"), { as: alice });
    assert(v?.equals(new Nat(21)))

    await view_args_storage_1.view_args_storage_1.exec({ as: alice })

    const res_after = await view_args_storage_1.view_args_storage_1.get_res()
    assert(res_after.equals(Option.Some(new Nat(21))))
    const k_after = await view_args_storage_1.view_args_storage_1.get_k()
    assert(k_after.equals(new Int(10)))
    const str_after = await view_args_storage_1.view_args_storage_1.get_str()
    assert(str_after == "abc")
  })

  it('view_asset', async () => {
    await view_asset.view_asset.deploy({ as: alice })

    const my_asset_before = await view_asset.view_asset.get_my_asset();
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "value")
    const res_before = await view_asset.view_asset.get_res()
    assert(res_before.equals(Option.None()))

    const v = await view_asset.view_asset.view_get(new Nat(0), { as: alice });
    assert(v == "value")

    await view_asset.view_asset.exec({ as: alice })

    const my_asset_after = await view_asset.view_asset.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "value")
    const res_after = await view_asset.view_asset.get_res()
    assert(res_after.equals(Option.Some<string>("value")))
  })

  it('view_exhaustive', async () => {
    await view_exhaustive.view_exhaustive.deploy({ as: alice })

    const my_asset_before = await view_exhaustive.view_exhaustive.get_my_asset();
    assert(my_asset_before.length == 1)
    assert(my_asset_before[0][0].equals(new Nat(0)))
    assert(my_asset_before[0][1] == "value")
    const n_before = await view_exhaustive.view_exhaustive.get_n()
    assert(n_before.equals(new Nat(2)))
    const r_before = await view_exhaustive.view_exhaustive.get_r()
    assert(r_before.equals(new Nat(0)))
    const state_before = await view_exhaustive.view_exhaustive.get_state()
    assert(state_before == view_exhaustive.states.One)

    const v = await view_exhaustive.view_exhaustive.view_getN({ as: alice });
    assert(v?.equals(new Nat(2)))

    await view_exhaustive.view_exhaustive.exec({ as: alice })

    const my_asset_after = await view_exhaustive.view_exhaustive.get_my_asset();
    assert(my_asset_after.length == 1)
    assert(my_asset_after[0][0].equals(new Nat(0)))
    assert(my_asset_after[0][1] == "value")
    const n_after = await view_exhaustive.view_exhaustive.get_n()
    assert(n_after.equals(new Nat(2)))
    const r_after = await view_exhaustive.view_exhaustive.get_r()
    assert(r_after.equals(new Nat(2)))
    const state_after = await view_exhaustive.view_exhaustive.get_state()
    assert(state_after == view_exhaustive.states.One)
  })

  it('view_in_arg', async () => {
    await view_in_arg.view_in_arg.deploy({ as: alice })

    const my_asset_before = await view_in_arg.view_in_arg.get_my_asset();
    assert(my_asset_before.length == 3)
    assert(my_asset_before[0][0] == "id0")
    assert(my_asset_before[0][1].equals(new Int(0)))
    assert(my_asset_before[1][0] == "id1")
    assert(my_asset_before[1][1].equals(new Int(1)))
    assert(my_asset_before[2][0] == "id2")
    assert(my_asset_before[2][1].equals(new Int(2)))
    const res_before = await view_in_arg.view_in_arg.get_res()
    assert(res_before.equals(new Nat(0)))

    await view_in_arg.view_in_arg.exec({ as: alice })

    const my_asset_after = await view_in_arg.view_in_arg.get_my_asset();
    assert(my_asset_after.length == 3)
    assert(my_asset_after[0][0] == "id0")
    assert(my_asset_after[0][1].equals(new Int(0)))
    assert(my_asset_after[1][0] == "id1")
    assert(my_asset_after[1][1].equals(new Int(1)))
    assert(my_asset_after[2][0] == "id2")
    assert(my_asset_after[2][1].equals(new Int(2)))
    const res_after = await view_in_arg.view_in_arg.get_res()
    assert(res_after.equals(new Nat(2)))
  })

  it('view_offchain', async () => {
    await view_offchain.view_offchain.deploy({ as: alice })

    const n_before = await view_offchain.view_offchain.get_n()
    assert(n_before.equals(new Nat(0)))

    await view_offchain.view_offchain.set(new Nat(2), { as: alice })

    const n_after = await view_offchain.view_offchain.get_n()
    assert(n_after.equals(new Nat(2)))
  })

  it('view_offchain_nat', async () => {
    await view_offchain_nat.view_offchain_nat.deploy({ as: alice })

    const bm_0_before = await view_offchain_nat.view_offchain_nat.get_bm_value(new Nat(0))
    assert(bm_0_before == 'zero')
    const bm_1_before = await view_offchain_nat.view_offchain_nat.get_bm_value(new Nat(1))
    assert(bm_1_before == 'one')
    const bm_2_before = await view_offchain_nat.view_offchain_nat.get_bm_value(new Nat(2))
    assert(bm_2_before == 'two')
    const bm_3_before = await view_offchain_nat.view_offchain_nat.get_bm_value(new Nat(3))
    assert(bm_3_before == undefined)

    await view_offchain_nat.view_offchain_nat.set(new Nat(3), 'three', { as: alice })

    const bm_0_after = await view_offchain_nat.view_offchain_nat.get_bm_value(new Nat(0))
    assert(bm_0_after == 'zero')
    const bm_1_after = await view_offchain_nat.view_offchain_nat.get_bm_value(new Nat(1))
    assert(bm_1_after == 'one')
    const bm_2_after = await view_offchain_nat.view_offchain_nat.get_bm_value(new Nat(2))
    assert(bm_2_after == 'two')
    const bm_3_after = await view_offchain_nat.view_offchain_nat.get_bm_value(new Nat(3))
    assert(bm_3_after == 'three')
  })

  it('view_onchain', async () => {
    await view_onchain.view_onchain.deploy({ as: alice })

    const n_before = await view_onchain.view_onchain.get_n()
    assert(n_before.equals(Option.None()))

    const v = await view_onchain.view_onchain.view_getN({ as: alice });
    assert(v?.equals(new Nat(0)))

    await view_onchain.view_onchain.exec({ as: alice })

    const n_after = await view_onchain.view_onchain.get_n()
    assert(n_after.equals(Option.Some(new Nat(0))))
  })

  it('view_onchain_offchain', async () => {
    await view_onchain_offchain.view_onchain_offchain.deploy({ as: alice })

    const n_before = await view_onchain_offchain.view_onchain_offchain.get_n()
    assert(n_before.equals(Option.None()))

    const v = await view_onchain_offchain.view_onchain_offchain.view_getN({ as: alice });
    assert(v?.equals(new Nat(0)))

    await view_onchain_offchain.view_onchain_offchain.exec({ as: alice })

    const n_after = await view_onchain_offchain.view_onchain_offchain.get_n()
    assert(n_after.equals(Option.Some(new Nat(0))))
  })

  it('view_simple', async () => {
    await view_simple.view_simple.deploy({ as: alice })

    const n_before = await view_simple.view_simple.get_n()
    assert(n_before.equals(new Nat(2)))

    const n_view_before = await view_simple.view_simple.view_get({ as: alice })
    assert(n_view_before?.equals(new Nat(2)))

    await view_simple.view_simple.setN(new Nat(3), { as: alice })

    const n_after = await view_simple.view_simple.get_n()
    assert(n_after.equals(new Nat(3)))

    const n_view_after = await view_simple.view_simple.view_get({ as: alice })
    assert(n_view_after?.equals(new Nat(3)))
  })

  it('view_simple_call', async () => {
    await view_simple_call.view_simple_call.deploy({ as: alice })

    const res_before = await view_simple_call.view_simple_call.get_res()
    assert(res_before.equals(Option.None()))

    await view_simple_call.view_simple_call.exec({ as: alice })

    const res_after = await view_simple_call.view_simple_call.get_res()
    assert(res_after.equals(Option.Some(new Nat(10))))
  })

  it('view_simple_caller', async () => {
    await view_simple.view_simple.deploy({ as: alice })
    await view_simple_caller.view_simple_caller.deploy({ as: alice })

    const n_before = await view_simple_caller.view_simple_caller.get_n()
    assert(n_before.equals(Option.None()))

    await view_simple_caller.view_simple_caller.exec(view_simple.view_simple.get_address(), { as: alice })

    const n_after = await view_simple_caller.view_simple_caller.get_n()
    assert(n_after.equals(Option.Some(new Nat(2))))
  })

  it('view_storage_0', async () => {
    await view_storage_0.view_storage_0.deploy({ as: alice })

    const res_before = await view_storage_0.view_storage_0.get_res()
    assert(res_before.equals(Option.None()))
    const n_before = await view_storage_0.view_storage_0.get_n()
    assert(n_before.equals(new Nat(2)))

    const v = await view_storage_0.view_storage_0.view_get({ as: alice });
    assert(v?.equals(new Nat(2)))

    await view_storage_0.view_storage_0.exec({ as: alice })

    const res_after = await view_storage_0.view_storage_0.get_res()
    assert(res_after.equals(Option.Some(new Nat(2))))
    const n_after = await view_storage_0.view_storage_0.get_n()
    assert(n_after.equals(new Nat(2)))
  })

  it('view_storage_1', async () => {
    await view_storage_1.view_storage_1.deploy({ as: alice })

    const res_before = await view_storage_1.view_storage_1.get_res()
    assert(res_before.equals(Option.None()))
    const i_before = await view_storage_1.view_storage_1.get_i()
    assert(i_before.equals(new Nat(1)))

    const v = await view_storage_1.view_storage_1.view_get({ as: alice });
    assert(v?.equals(new Nat(1)))

    await view_storage_1.view_storage_1.exec({ as: alice })

    const res_after = await view_storage_1.view_storage_1.get_res()
    assert(res_after.equals(Option.Some(new Nat(1))))
    const i_after = await view_storage_1.view_storage_1.get_i()
    assert(i_after.equals(new Nat(1)))
  })

  it('view_storage_2', async () => {
    await view_storage_2.view_storage_2.deploy({ as: alice })

    const res_before = await view_storage_2.view_storage_2.get_res()
    assert(res_before.equals(Option.None()))
    const i_before = await view_storage_2.view_storage_2.get_i()
    assert(i_before.equals(new Nat(1)))
    const n_before = await view_storage_2.view_storage_2.get_n()
    assert(n_before.equals(new Nat(2)))

    const v = await view_storage_2.view_storage_2.view_get({ as: alice });
    assert(v?.equals(new Nat(3)))

    await view_storage_2.view_storage_2.exec({ as: alice })

    const res_after = await view_storage_2.view_storage_2.get_res()
    assert(res_after.equals(Option.Some(new Nat(3))))
    const i_after = await view_storage_2.view_storage_2.get_i()
    assert(i_after.equals(new Nat(1)))
    const n_after = await view_storage_2.view_storage_2.get_n()
    assert(n_after.equals(new Nat(2)))
  })

  it('view_storage_3', async () => {
    await view_storage_3.view_storage_3.deploy({ as: alice })

    const res_before = await view_storage_3.view_storage_3.get_res()
    assert(res_before.equals(Option.None()))
    const a_before = await view_storage_3.view_storage_3.get_a()
    assert(a_before.equals(new Nat(1)))
    const b_before = await view_storage_3.view_storage_3.get_b()
    assert(b_before.equals(new Nat(2)))
    const c_before = await view_storage_3.view_storage_3.get_c()
    assert(c_before.equals(new Nat(3)))

    const v = await view_storage_3.view_storage_3.view_get({ as: alice });
    assert(v?.equals(new Nat(5)))

    await view_storage_3.view_storage_3.exec({ as: alice })

    const res_after = await view_storage_3.view_storage_3.get_res()
    assert(res_after.equals(Option.Some(new Nat(5))))
    const a_after = await view_storage_3.view_storage_3.get_a()
    assert(a_after.equals(new Nat(1)))
    const b_after = await view_storage_3.view_storage_3.get_b()
    assert(b_after.equals(new Nat(2)))
    const c_after = await view_storage_3.view_storage_3.get_c()
    assert(c_after.equals(new Nat(3)))
  })

  it('view_storage_4', async () => {
    await view_storage_4.view_storage_4.deploy({ as: alice })

    const res_before = await view_storage_4.view_storage_4.get_res()
    assert(res_before.equals(Option.None()))
    const a_before = await view_storage_4.view_storage_4.get_a()
    assert(a_before.equals(new Nat(1)))
    const b_before = await view_storage_4.view_storage_4.get_b()
    assert(b_before.equals(new Nat(2)))
    const c_before = await view_storage_4.view_storage_4.get_c()
    assert(c_before.equals(new Nat(3)))

    const v = await view_storage_4.view_storage_4.view_get({ as: alice });
    assert(v?.equals(new Nat(3)))

    await view_storage_4.view_storage_4.exec({ as: alice })

    const res_after = await view_storage_4.view_storage_4.get_res()
    assert(res_after.equals(Option.Some(new Nat(3))))
    const a_after = await view_storage_4.view_storage_4.get_a()
    assert(a_after.equals(new Nat(1)))
    const b_after = await view_storage_4.view_storage_4.get_b()
    assert(b_after.equals(new Nat(2)))
    const c_after = await view_storage_4.view_storage_4.get_c()
    assert(c_after.equals(new Nat(3)))
  })

  it('view_storage_5', async () => {
    await view_storage_5.view_storage_5.deploy({ as: alice })

    const res_before = await view_storage_5.view_storage_5.get_res()
    assert(res_before.equals(Option.None()))
    const a_before = await view_storage_5.view_storage_5.get_a()
    assert(a_before.equals(new Nat(1)))
    const b_before = await view_storage_5.view_storage_5.get_b()
    assert(b_before.equals(new Nat(2)))
    const c_before = await view_storage_5.view_storage_5.get_c()
    assert(c_before.equals(new Nat(3)))
    const d_before = await view_storage_5.view_storage_5.get_d()
    assert(d_before.equals(new Nat(4)))

    const v = await view_storage_5.view_storage_5.view_get({ as: alice });
    assert(v?.equals(new Nat(5)))

    await view_storage_5.view_storage_5.exec({ as: alice })

    const res_after = await view_storage_5.view_storage_5.get_res()
    assert(res_after.equals(Option.Some(new Nat(5))))
    const a_after = await view_storage_5.view_storage_5.get_a()
    assert(a_after.equals(new Nat(1)))
    const b_after = await view_storage_5.view_storage_5.get_b()
    assert(b_after.equals(new Nat(2)))
    const c_after = await view_storage_5.view_storage_5.get_c()
    assert(c_after.equals(new Nat(3)))
    const d_after = await view_storage_5.view_storage_5.get_d()
    assert(d_after.equals(new Nat(4)))
  })

  it('view_with_nat_to_string', async () => {
    await view_with_nat_to_string.view_with_nat_to_string.deploy({ as: alice })

    const res_123 = await view_with_nat_to_string.view_with_nat_to_string.view_my_view(new Nat(123), { as: alice })
    assert(res_123 == "123")

    const res_0 = await view_with_nat_to_string.view_with_nat_to_string.view_my_view(new Nat(0), { as: alice })
    assert(res_0 == "0")
  })

  it('view_with_self', async () => {
    await view_with_self.view_with_self.deploy({ as: alice })

    const res_before = await view_with_self.view_with_self.get_res()
    assert(res_before.equals(Option.None()))

    await view_with_self.view_with_self.exec({ as: alice })

    const res_after = await view_with_self.view_with_self.get_res()
    assert(res_after.equals(Option.Some(new Nat(2))))
  })

  it('view_with_self_add', async () => {
    await view_with_self_add.view_with_self_add.deploy({ as: alice })

    const res_before = await view_with_self_add.view_with_self_add.get_res()
    assert(res_before.equals(Option.None()))

    await view_with_self_add.view_with_self_add.exec({ as: alice })

    const res_after = await view_with_self_add.view_with_self_add.get_res()
    assert(res_after.equals(Option.Some(new Nat(5))))
  })

  it('with_metadata_json', async () => {
    await with_metadata_json.with_metadata_json.deploy({ as: alice })

    const ks = await with_metadata_json.with_metadata_json.get_metadata_value("");
    assert(ks?.hex_decode() == 'tezos-storage:here')
    const v = await with_metadata_json.with_metadata_json.get_metadata_value("here");
    assert(v)
    assert(JSON.stringify(JSON.parse(v?.hex_decode())) == '{"symbol":"MTK","name":"MyToken","decimals":"1","description":"description of MyToken","thumbnailUri":"https://completium.com/img/logo_completium_128.png"}')

  })

  it('with_metadata_json_with_offchain_view', async () => {
    await with_metadata_json_with_offchain_view.with_metadata_json_with_offchain_view.deploy({ as: alice })

    const ks = await with_metadata_json_with_offchain_view.with_metadata_json_with_offchain_view.get_metadata_value("");
    assert(ks?.hex_decode() == 'tezos-storage:here')
    const v = await with_metadata_json_with_offchain_view.with_metadata_json_with_offchain_view.get_metadata_value("here");
    assert(v)
    assert(JSON.stringify(JSON.parse(v?.hex_decode())) == '{"symbol":"MTK","name":"MyToken","decimals":"1","description":"description of MyToken","thumbnailUri":"https://completium.com/img/logo_completium_128.png"}')
  })

  it('with_metadata_uri', async () => {
    await with_metadata_uri.with_metadata_uri.deploy({ as: alice })

    const ks = await with_metadata_uri.with_metadata_uri.get_metadata_value("");
    assert(ks?.hex_decode() == 'https://completium.com/metadata/token_metadata.json')
  })

})