open Model
open Printer_tools

let pragma = ">=0.5.0 <0.7.0"

(* -------------------------------------------------------------------------- *)
let pp_model fmt (model : model) =

  let pp_pragma fmt _ =
    Format.fprintf fmt "pragma solidity %a;@\n" pp_str pragma
  in

  let pp_btyp fmt x =
    let pp = Format.fprintf fmt in
    match x with
    | Bbool       -> pp "bool"
    | Bint        -> pp "int"
    | Brational   -> pp "rational"
    | Bdate       -> pp "timestamp"
    | Bduration   -> pp "duration"
    | Btimestamp  -> pp "timestamp"
    | Bstring     -> pp "string"
    | Baddress    -> pp "address"
    | Brole       -> pp "address"
    | Bcurrency   -> pp "tez"
    | Bkey        -> pp "key"
  in

  let pp_container fmt = function
    | Collection -> Format.fprintf fmt "list"
    | Partition  -> Format.fprintf fmt "list"
    | List       -> Format.fprintf fmt "list"
  in

  let rec pp_type fmt t =
    match t with
    | Tasset an    -> pp_id fmt an
    | Tenum en     -> pp_id fmt en
    | Tcontract cn -> pp_id fmt cn
    | Tbuiltin b   -> pp_btyp fmt b
    | Tstate       -> pp_str fmt "states"
    | Tcontainer (t, c) ->
      Format.fprintf fmt "%a %a"
        pp_type t
        pp_container c
    | Toption t ->
      Format.fprintf fmt "%a option"
        pp_type t
    | Ttuple ts ->
      Format.fprintf fmt "%a"
        (pp_list " * " pp_type) ts
    | Tassoc (k, v) ->
      Format.fprintf fmt "(%a, %a) map"
        pp_btyp k
        pp_type v
    | Tunit -> pp_str fmt "unit"
    | Tstorage -> pp_str fmt "storage"
    | Toperation -> pp_str fmt "operation"
    | Tentry -> pp_str fmt "entry"
    | Tprog _
    | Tvset _
    | Ttrace _ -> pp_str fmt "todo"
  in

  (* {
     name: 'id;
     type_: type_;
     original_type: type_;
     constant: bool;
     default: 'id mterm_gen option;
     invariants: 'id label_term_gen list;
     loc: Location.t;
     } *)

  let pp_mterm fmt (mt : mterm) =
    match mt.node with
    | Mstring str -> Format.fprintf fmt "\"%s\"" str
    | _ -> assert false
  in

  let pp_var fmt (var : var) =
    Format.fprintf fmt "%a %a%a;"
      pp_type var.type_
      pp_id var.name
      (pp_option (fun fmt x -> Format.fprintf fmt " = %a" pp_mterm x)) var.default
  in

  let pp_decl_node fmt = function
    | Dvar v -> pp_var fmt v
    | Denum _ -> ()
    | Dasset _ -> ()
    | Dcontract _ -> ()
  in

  let pp_decls fmt x = (pp_list "@\n" pp_decl_node) fmt x in

  let pp_contract_content _fmt _ =
    pp_decls fmt model.decls
  in

  let pp_contract fmt _ =
    Format.fprintf fmt "contract %a {@\n  @[%a@]@\n}@."
      pp_id model.name
      pp_contract_content ()
  in

  Format.fprintf fmt "// Solidity output generated by %a@."
    pp_bin ();
  pp_newline fmt ();
  pp_pragma fmt ();
  pp_newline fmt ();
  pp_contract fmt ()


(* -------------------------------------------------------------------------- *)
let string_of__of_pp pp x =
  Format.asprintf "%a@." pp x

let show_model (x : model) = string_of__of_pp pp_model x
