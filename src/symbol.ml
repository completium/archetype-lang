open Parser
open Parser.MenhirInterpreter

let string_of_token = function
  | XOR                  -> "XOR"
  | WITH_METADATA        -> "WITH_METADATA"
  | WITH                 -> "WITH"
  | WHILE                -> "WHILE"
  | WHEN                 -> "WHEN"
  | VIEW                 -> "VIEW"
  | VARIABLE             -> "VARIABLE"
  | VAR                  -> "VAR"
  | UTZ n                -> Printf.sprintf "UTZ(%s)" n
  | UNPACK               -> "UNPACK"
  | UNIT                 -> "UNIT"
  | UNDERSCORE           -> "UNDERSCORE"
  | TZ_EXPR s            -> Printf.sprintf "TZ_EXPR(%s)" s
  | TZ n                 -> Printf.sprintf "TZ(%s)" n
  | TYPE                 -> "TYPE"
  | TRUE                 -> "TRUE"
  | TRANSITION           -> "TRANSITION"
  | TRANSFER             -> "TRANSFER"
  | TO                   -> "TO"
  | TICKET               -> "TICKET"
  | THEN                 -> "THEN"
  | STRING_EXT s         -> Printf.sprintf "STRING_EXT(%s)" s
  | STRING s             -> Printf.sprintf "STRING(%s)" s
  | STATES               -> "STATES"
  | STATE_IS             -> "STATE_IS"
  | SOURCED              -> "SOURCED"
  | SORTED               -> "SORTED"
  | SOME                 -> "SOME"
  | SLASHPERCENT         -> "SLASHPERCENT"
  | SLASH                -> "SLASH"
  | SET                  -> "SET"
  | SEMI_COLON           -> "SEMI_COLON"
  | SELF                 -> "SELF"
  | SAPLING_TRANSACTION  -> "SAPLING_TRANSACTION"
  | SAPLING_STATE        -> "SAPLING_STATE"
  | RPAREN               -> "RPAREN"
  | RIGHT                -> "RIGHT"
  | RETURN               -> "RETURN"
  | REQUIRE_ENTRYPOINT   -> "REQUIRE_ENTRYPOINT"
  | REQUIRE              -> "REQUIRE"
  | RECORD               -> "RECORD"
  | RBRACKET             -> "RBRACKET"
  | RBRACE               -> "RBRACE"
  | QUESTIONIS           -> "QUESTIONIS"
  | QUESTIONEQUAL        -> "QUESTIONEQUAL"
  | QUESTIONDOT          -> "QUESTIONDOT"
  | QUESTIONCOLONEQUAL   -> "QUESTIONCOLONEQUAL"
  | QUESTION             -> "QUESTION"
  | PLUSEQUAL            -> "PLUSEQUAL"
  | PLUS                 -> "PLUS"
  | PIPEEQUAL            -> "OREQUAL"
  | PIPE_GREATER_GREATER -> "PIPE_GREATER_GREATER"
  | PIPE                 -> "PIPE"
  | PIDENT s             -> Printf.sprintf "PIDENT(%s)" s
  | PERCENT_LIT n        -> Printf.sprintf "PERCENT_LIT(%s)" n
  | PERCENT              -> "PERCENT"
  | PARTITION            -> "PARTITION"
  | OTHERWISE            -> "OTHERWISE"
  | OR                   -> "OR"
  | OPTION               -> "OPTION"
  | ONCHAIN              -> "ONCHAIN"
  | OFFCHAIN             -> "OFFCHAIN"
  | NUMBERNAT n          -> Printf.sprintf "NUMBERNAT(%s)" (Big_int.string_of_big_int n)
  | NUMBERINT n          -> Printf.sprintf "NUMBERINT(%s)" (Big_int.string_of_big_int n)
  | NUMBER_FR n          -> Printf.sprintf "NUMBER_FR(%s)" (Big_int.string_of_big_int n)
  | NOT                  -> "NOT"
  | NONE                 -> "NONE"
  | NO_TRANSFER          -> "NO_TRANSFER"
  | NEQUAL               -> "NEQUAL"
  | NAMESPACE            -> "NAMESPACE"
  | MULTEQUAL            -> "MULTEQUAL"
  | MULT                 -> "MULT"
  | MTZ n                -> Printf.sprintf "MTZ(%s)" n
  | MINUSEQUAL           -> "MINUSEQUAL"
  | MINUS                -> "MINUS"
  | MICHELSON            -> "MICHELSON"
  | MATCH                -> "MATCH"
  | MAP                  -> "MAP"
  | MAKE_SET             -> "MAKE_SET"
  | MAKE_MAP             -> "MAKE_MAP"
  | MAKE_LIST            -> "MAKE_LIST"
  | MAKE_EVENT           -> "MAKE_EVENT"
  | MAKE_BIG_MAP         -> "MAKE_BIG_MAP"
  | MAKE_ASSET           -> "MAKE_ASSET"
  | LPAREN               -> "LPAREN"
  | LIST                 -> "LIST"
  | LET                  -> "LET"
  | LESSEQUAL            -> "LESSEQUAL"
  | LESS_LESS_PIPE       -> "LESS_LESS_PIPE"
  | LESS_EQUAL_GREATER   -> "LESS_EQUAL_GREATER"
  | LESS                 -> "LESS"
  | LEFT                 -> "LEFT"
  | LBRACKET             -> "LBRACKET"
  | LBRACE               -> "LBRACE"
  | LAMBDA_MICHELSON     -> "LAMBDA_MICHELSON"
  | LAMBDA               -> "LAMBDA"
  | ITERABLE_BIG_MAP     -> "ITERABLE_BIG_MAP"
  | ITER                 -> "ITER"
  | IS                   -> "IS"
  | INVALID_EXPR         -> "INVALID_EXPR"
  | INVALID_EFFECT       -> "INVALID_EFFECT"
  | INVALID_DECL         -> "INVALID_DECL"
  | INITIALIZED          -> "INITIALIZED"
  | INITIAL              -> "INITIAL"
  | IN                   -> "IN"
  | IMPORT               -> "IMPORT"
  | IMPLY                -> "IMPLY"
  | IF                   -> "IF"
  | IDENTIFIED           -> "IDENTIFIED"
  | IDENT s              -> Printf.sprintf "IDENT(%s)" s
  | GREATEREQUAL         -> "GREATEREQUAL"
  | GREATER              -> "GREATER"
  | GLOBAL_CONSTANT      -> "GLOBAL_CONSTANT"
  | GETTER               -> "GETTER"
  | GET_ENTRYPOINT       -> "GET_ENTRYPOINT"
  | FUNCTION             -> "FUNCTION"
  | FROM                 -> "FROM"
  | FOR                  -> "FOR"
  | FOLD                 -> "FOLD"
  | FALSE                -> "FALSE"
  | FAILSOME             -> "FAILSOME"
  | FAIL_IF              -> "FAIL_IF"
  | FAIL                 -> "FAIL"
  | EVENT                -> "EVENT"
  | EQUAL                -> "EQUAL"
  | EOF                  -> "EOF"
  | ENUM                 -> "ENUM"
  | ENTRY                -> "ENTRY"
  | END                  -> "END"
  | EMIT                 -> "EMIT"
  | ELSE                 -> "ELSE"
  | EFFECT               -> "EFFECT"
  | DURATION s           -> Printf.sprintf "DURATION(%s)" s
  | DOT                  -> "DOT"
  | DONE                 -> "DONE"
  | DO_REQUIRE           -> "DO_REQUIRE"
  | DO_FAIL_IF           -> "DO_FAIL_IF"
  | DO                   -> "DO"
  | DIVEQUAL             -> "DIVEQUAL"
  | DIV                  -> "DIV"
  | DETACH               -> "DETACH"
  | DECIMAL s            -> Printf.sprintf "DECIMAL(%s)" s
  | DATE s               -> Printf.sprintf "DATE(%s)" s
  | CONTRACT             -> "CONTRACT"
  | CONSTANT             -> "CONSTANT"
  | CONST                -> "CONST"
  | COMMA                -> "COMMA"
  | COLONEQUAL           -> "COLONEQUAL"
  | COLONCOLON           -> "COLONCOLON"
  | COLON                -> "COLON"
  | CALLED               -> "CALLED"
  | CALL_VIEW            -> "CALL_VIEW"
  | CALL                 -> "CALL"
  | BYTES_G2 s           -> Printf.sprintf "BYTES_G2(%s)" s
  | BYTES_G1 s           -> Printf.sprintf "BYTES_G1(%s)" s
  | BYTES_FR s           -> Printf.sprintf "BYTES_FR(%s)" s
  | BYTES s              -> Printf.sprintf "BYTES(%s)" s
  | BY                   -> "BY"
  | BIG_MAP              -> "BIG_MAP"
  | BEGIN                -> "BEGIN"
  | ASSET_VIEW           -> "ASSET_VIEW"
  | ASSET_VALUE          -> "ASSET_VALUE"
  | ASSET_KEY            -> "ASSET_KEY"
  | ASSET_CONTAINER      -> "ASSET_CONTAINER"
  | ASSET                -> "ASSET"
  | AS                   -> "AS"
  | ARCHETYPE            -> "ARCHETYPE"
  | ANY                  -> "ANY"
  | ANNOTATION s         -> Printf.sprintf "ANNOTATION(%s)" s
  | AND                  -> "AND"
  | AMPEQUAL             -> "AMPEQUAL"
  | AGGREGATE            -> "AGGREGATE"
  | ADDRESS_TO_CONTRACT  -> "ADDRESS_TO_CONTRACT"
  | ADDRESS s            -> Printf.sprintf "DURATION(%s)" s
  | ACCEPT_TRANSFER      -> "ACCEPT_TRANSFER"

let string_of_symbol = function
  | X (T T_XOR) -> "xor"
  | X (T T_WITH) -> "with"
  | X (T T_WITH_METADATA) -> "with metadata"
  | X (T T_WHILE) -> "while"
  | X (T T_WHEN) -> "when"
  | X (T T_VIEW) -> "view"
  | X (T T_VARIABLE) -> "variable"
  | X (T T_VAR) -> "var"
  | X (T T_UTZ) -> "a utz"
  | X (T T_UNPACK) -> "unpack"
  | X (T T_UNIT) -> "Unit"
  | X (T T_UNDERSCORE) -> "_"
  | X (T T_TZ) -> "a tz"
  | X (T T_TZ_EXPR) -> "a tz_expr"
  | X (T T_TYPE) -> "a type"
  | X (T T_TRUE) -> "true"
  | X (T T_TRANSITION) -> "transition"
  | X (T T_TRANSFER) -> "transfer"
  | X (T T_TO) -> "to"
  | X (T T_TICKET) -> "ticket"
  | X (T T_THEN) -> "then"
  | X (T T_STRING) -> "a string"
  | X (T T_STRING_EXT) -> "a string ext"
  | X (T T_STATES) -> "states"
  | X (T T_STATE_IS) -> "state is"
  | X (T T_SOURCED) -> "sourced"
  | X (T T_SORTED) -> "sorted"
  | X (T T_SOME) -> "some"
  | X (T T_SLASHPERCENT) -> "slashpercent"
  | X (T T_SLASH) -> "slash"
  | X (T T_SET) -> "set"
  | X (T T_SEMI_COLON) -> ";"
  | X (T T_SELF) -> "self"
  | X (T T_SAPLING_TRANSACTION) -> "sapling_transaction"
  | X (T T_SAPLING_STATE) -> "sapling_state"
  | X (T T_RPAREN) -> ")"
  | X (T T_RIGHT) -> "right"
  | X (T T_RETURN) -> "return"
  | X (T T_REQUIRE) -> "require"
  | X (T T_REQUIRE_ENTRYPOINT) -> "require_entrypoint"
  | X (T T_RECORD) -> "record"
  | X (T T_RBRACKET) -> "]"
  | X (T T_RBRACE) -> "}"
  | X (T T_QUESTIONIS) -> "?is"
  | X (T T_QUESTIONEQUAL) -> "?="
  | X (T T_QUESTIONDOT) -> "?."
  | X (T T_QUESTIONCOLONEQUAL) -> "?:="
  | X (T T_QUESTION) -> "question"
  | X (T T_PLUSEQUAL) -> "+="
  | X (T T_PLUS) -> "+"
  | X (T T_PIPEEQUAL) -> "|="
  | X (T T_PIPE) -> "|"
  | X (T T_PIPE_GREATER_GREATER) -> "|>>"
  | X (T T_PIDENT) -> "an pident"
  | X (T T_PERCENT) -> "%"
  | X (T T_PERCENT_LIT) -> "a literal percent"
  | X (T T_PARTITION) -> "partition"
  | X (T T_OTHERWISE) -> "otherwise"
  | X (T T_OR) -> "or"
  | X (T T_OPTION) -> "option"
  | X (T T_ONCHAIN) -> "onchain"
  | X (T T_OFFCHAIN)-> "offchain"
  | X (T T_NUMBERNAT) -> "a nat number"
  | X (T T_NUMBERINT) -> "a int number"
  | X (T T_NUMBER_FR) -> "number_fr"
  | X (T T_NOT) -> "not"
  | X (T T_NONE) -> "none"
  | X (T T_NO_TRANSFER) -> "no transfer"
  | X (T T_NEQUAL) -> "<>"
  | X (T T_NAMESPACE) -> "namespace"
  | X (T T_MULTEQUAL) -> "*="
  | X (T T_MULT) -> "*"
  | X (T T_MTZ) -> "a mtz"
  | X (T T_MINUSEQUAL) -> "-="
  | X (T T_MINUS) -> "-"
  | X (T T_MICHELSON) -> "michelson"
  | X (T T_MATCH) -> "match"
  | X (T T_MAP) -> "map"
  | X (T T_MAKE_SET) -> "make_set"
  | X (T T_MAKE_MAP) -> "make_map"
  | X (T T_MAKE_LIST) -> "make_list"
  | X (T T_MAKE_EVENT) -> "make_event"
  | X (T T_MAKE_BIG_MAP) -> "make_big_map"
  | X (T T_MAKE_ASSET) -> "make_asset"
  | X (T T_LPAREN) -> "("
  | X (T T_LIST) -> "list"
  | X (T T_LET) -> "let"
  | X (T T_LESSEQUAL) -> "<="
  | X (T T_LESS) -> "<"
  | X (T T_LESS_LESS_PIPE) -> "<<|"
  | X (T T_LESS_EQUAL_GREATER) -> "<=>"
  | X (T T_LEFT) -> "left"
  | X (T T_LBRACKET) -> "["
  | X (T T_LBRACE) -> "{"
  | X (T T_LAMBDA) -> "lambda"
  | X (T T_LAMBDA_MICHELSON) -> "lambda_michelson"
  | X (T T_ITERABLE_BIG_MAP) -> "iterable_big_map"
  | X (T T_ITER) -> "iter"
  | X (T T_IS) -> "is"
  | X (T T_INVALID_EXPR) -> "invalid-expression"
  | X (T T_INVALID_EFFECT) -> "invalid-effect"
  | X (T T_INVALID_DECL) -> "invalid-declaration"
  | X (T T_INITIALIZED) -> "initialized"
  | X (T T_INITIAL) -> "initial"
  | X (T T_IN) -> "in"
  | X (T T_IMPORT) -> "import"
  | X (T T_IMPLY) -> "->"
  | X (T T_IF) -> "if"
  | X (T T_IDENTIFIED) -> "identified"
  | X (T T_IDENT) -> "an ident"
  | X (T T_GREATEREQUAL) -> ">="
  | X (T T_GREATER) -> ">"
  | X (T T_GLOBAL_CONSTANT) -> "global_constant"
  | X (T T_GETTER) -> "getter"
  | X (T T_GET_ENTRYPOINT) -> "get_entrypoint"
  | X (T T_FUNCTION) -> "function"
  | X (T T_FROM) -> "from"
  | X (T T_FOR) -> "for"
  | X (T T_FOLD) -> "fold"
  | X (T T_FALSE) -> "false"
  | X (T T_FAILSOME) -> "fail_some"
  | X (T T_FAIL) -> "fail"
  | X (T T_FAIL_IF) -> "fail if"
  | X (T T_EVENT) -> "event"
  | X (T T_error) -> "error"
  | X (T T_EQUAL) -> "="
  | X (T T_EOF) -> "end-of-file"
  | X (T T_ENUM) -> "enum"
  | X (T T_ENTRY) -> "entry"
  | X (T T_END) -> "end"
  | X (T T_EMIT) -> "emit"
  | X (T T_ELSE) -> "else"
  | X (T T_EFFECT) -> "effect"
  | X (T T_DURATION) -> "duration"
  | X (T T_DOT) -> "."
  | X (T T_DONE) -> "done"
  | X (T T_DO) -> "do"
  | X (T T_DO_REQUIRE) -> "do_require"
  | X (T T_DO_FAIL_IF) -> "do_fail_if"
  | X (T T_DIVEQUAL) -> "/="
  | X (T T_DIV) -> "/"
  | X (T T_DETACH) -> "detach"
  | X (T T_DECIMAL) -> "decimal"
  | X (T T_DATE) -> "a date"
  | X (T T_CONTRACT) -> "contract"
  | X (T T_CONSTANT) -> "constant"
  | X (T T_CONST) -> "const"
  | X (T T_COMMA) -> ","
  | X (T T_COLONEQUAL) -> ":="
  | X (T T_COLONCOLON) -> "::"
  | X (T T_COLON) -> ":"
  | X (T T_CALLED) -> "called"
  | X (T T_CALL) -> "call"
  | X (T T_CALL_VIEW) -> "call_view"
  | X (T T_BYTES) -> "bytes"
  | X (T T_BYTES_G2) -> "bytes_g2"
  | X (T T_BYTES_G1) -> "bytes_g1"
  | X (T T_BYTES_FR) -> "bytes_fr"
  | X (T T_BY) -> "by"
  | X (T T_BIG_MAP) -> "big_map"
  | X (T T_BEGIN) -> "begin"
  | X (T T_ASSET) -> "asset"
  | X (T T_ASSET_VIEW) -> "asset_view"
  | X (T T_ASSET_VALUE) -> "asset_value"
  | X (T T_ASSET_KEY) -> "asset_key"
  | X (T T_ASSET_CONTAINER) -> "asset_container"
  | X (T T_AS) -> "as"
  | X (T T_ARCHETYPE) -> "archetype"
  | X (T T_ANY) -> "any"
  | X (T T_ANNOTATION) -> "annotation"
  | X (T T_AND) -> "and"
  | X (T T_AMPEQUAL) -> "%="
  | X (T T_AGGREGATE) -> "aggregate"
  | X (T T_ADDRESS) -> "an address"
  | X (T T_ADDRESS_TO_CONTRACT) -> "address_to_contract"
  | X (T T_ACCEPT_TRANSFER) -> "accept address"
  | X (N N_view_decl) -> "a view declaration"
  | X (N N_vc_decl_VARIABLE_) -> "a variable declaration"
  | X (N N_vc_decl_CONSTANT_) -> "a constant declaration"
  | X (N N_variable) -> "a variable"
  | X (N N_type_s_unloc) -> "types"
  | X (N N_type_r) -> "a type"
  | X (N N_type_decl) -> "a type decl"
  | X (N N_transition) -> "a transition"
  | X (N N_transition_to_item) -> "a transition to item"
  | X (N N_start_expr) -> "a start expression"
  | X (N N_sourcedby) -> "a sourced by"
  | X (N N_snl2_COMMA_expr_) -> "a non empty list of expression separated by  ,"
  | X (N N_snl_SEMI_COLON_rf_WITH__) -> "a list of rf with"
  | X (N N_snl_SEMI_COLON_rf_OTHERWISE__) -> "a list of rf otherwise"
  | X (N N_snl_SEMI_COLON_mich_node_) -> "a list of mich node"
  | X (N N_snl_SEMI_COLON_field_) -> "a non empty list of field"
  | X (N N_snl_SEMI_COLON_cf_) -> "a non empty list of constant"
  | X (N N_snl_COMMA_type_t_) -> "a non empty list of type"
  | X (N N_snl_COMMA_simple_expr_) -> ""
  | X (N N_snl_COMMA_parameter_) -> "a non empty list of parameter"
  | X (N N_snl_COMMA_function_arg_) -> "a non empty list of function argument"
  | X (N N_snl_COMMA_expr_) -> ""
  | X (N N_snl_COLON_simple_expr_) -> "a non list of simple expression"
  | X (N N_sl_SEMI_COLON_field_) -> "a list of field"
  | X (N N_sl_COMMA_simple_expr_) -> ""
  | X (N N_sl_COMMA_function_arg_) -> "a list of function argument"
  | X (N N_simple_expr_r) -> "a simple expression"
  | X (N N_separated_nonempty_list_SEMI_COLON_recupdate_item_) -> "a non empty list of record update item by ;"
  | X (N N_separated_nonempty_list_SEMI_COLON_record_item_) -> "a non empty list of record item by ;"
  | X (N N_separated_nonempty_list_SEMI_COLON_record_expr_) -> "a non empty list of record expression by ;"
  | X (N N_separated_nonempty_list_MULT_type_s_) -> "a non empty *-separated list of types"
  | X (N N_separated_nonempty_list_COMMA_ident_) -> "a non empty comma-separated list of identifiers"
  | X (N N_rf_WITH_) -> "rf with"
  | X (N N_rf_OTHERWISE_) -> "rf otherwise"
  | X (N N_recupdate_item) -> "a record update item"
  | X (N N_record) -> "a record"
  | X (N N_record_item) -> "a record item"
  | X (N N_pname) -> "a pattern identifier"
  | X (N N_order_operations) -> "order operations"
  | X (N N_order_operation) -> "an order operation"
  | X (N N_option_with_effect_) -> "a with effect option"
  | X (N N_option_tentry_postfix_) -> "option_tentry_postfix_"
  | X (N N_option_state_is_) -> "an option state is"
  | X (N N_option_sourcedby_) -> "an option sourced by"
  | X (N N_option_SEMI_COLON_) -> ""
  | X (N N_option_require_value_) -> "a require option"
  | X (N N_option_require_) -> "a require option"
  | X (N N_option_record_position_) -> "an option record position"
  | X (N N_option_prefix_EQUAL_enum_body__) -> "an optional enum body"
  | X (N N_option_paren_separated_nonempty_list_COMMA_ident___) -> "a list of constructor arguments"
  | X (N N_option_parameter_init_) -> "parameter initialization"
  | X (N N_option_otherwise_section_) -> "an otherwise section"
  | X (N N_option_function_return_) -> "a function return option"
  | X (N N_option_failif_) -> "a failif option"
  | X (N N_option_effect_) -> "an effect option"
  | X (N N_option_default_value_) -> "a default value option"
  | X (N N_option_constants_) -> "a constant option"
  | X (N N_option_calledby_) -> "a call by option"
  | X (N N_option_asset_options_) -> "assets option"
  | X (N N_option_asset_fields_) -> "asset fields option"
  | X (N N_option_app_args_) -> "app args option"
  | X (N N_nonempty_list_type_tuple_) -> "a non empty list of type tuple"
  | X (N N_nonempty_list_transition_to_item_) -> "a non empty list of transition to item"
  | X (N N_nonempty_list_mich_argument_) -> "a non empty list of mich arguments"
  | X (N N_nonempty_list_loc_pattern__) -> "a non empty list of pattern"
  | X (N N_nonempty_list_ident_) -> "a non empty list of identifier"
  | X (N N_nonempty_list_declaration_) -> "a non empty list of declaration"
  | X (N N_nonempty_list_branch_) -> "a non empty list of branch"
  | X (N N_nonempty_list_asset_option_) -> "a non empty list of asset option"
  | X (N N_namespace) -> "a namespace"
  | X (N N_mich_node) -> "a mich node"
  | X (N N_mich_argument) -> "a mich argument"
  | X (N N_main) -> "archetype"
  | X (N N_loption_separated_nonempty_list_SEMI_COLON_recupdate_item__) -> "a non empty list of record update item"
  | X (N N_loption_separated_nonempty_list_SEMI_COLON_record_item__) -> "a non empty list of record item"
  | X (N N_literal) -> "a literal"
  | X (N N_list_mich_annot_) -> "a list of mich annot"
  | X (N N_list_function_item_) -> "a list of item function"
  | X (N N_list_enum_option_) -> "an optional list of enum options"
  | X (N N_list_enum_cdecl_) -> "a list of enum constructors declarations"
  | X (N N_list_asset_post_option_) -> "a list of asset post option"
  | X (N N_import) -> "import declaration"
  | X (N N_implementation_archetype) -> "an archetype implementation"
  | X (N N_getter_decl) -> "a getter declaration"
  | X (N N_function_item) -> "an item function"
  | X (N N_function_decl) -> "a function declaration"
  | X (N N_field_r) -> "a field"
  | X (N N_expr_r) -> "an expression"
  | X (N N_event) -> "an event declaration"
  | X (N N_enum) -> "an enum"
  | X (N N_enum_option) -> "an enum option"
  | X (N N_enum_cdecl) -> "an enum constructor declaration"
  | X (N N_enum_body) -> "an enum body declaration"
  | X (N N_entry) -> "an entry"
  | X (N N_entry_simple) -> "an entry simple"
  | X (N N_entry_properties) -> "entry properties"
  | X (N N_effect) -> "an effect"
  | X (N N_declaration_r) -> "a declaration"
  | X (N N_constant) -> "a constant"
  | X (N N_cfs) -> "constants"
  | X (N N_cf) -> "constant item"
  | X (N N_calledby) -> "called by"
  | X (N N_branch) -> "branch"
  | X (N N_boption_CONST_) -> "an optional const"
  | X (N N_asset) -> "an asset"
  | X (N N_asset_post_option) -> "asset post option"
  | X (N N_asset_option) -> "an asset option"
  | X (N N_archetype) -> "archetype"
  | X (N N_archetype_r) -> "archetype"


let string_of_item (p, i) =
  string_of_symbol (lhs p) ^ " -> "
  ^ String.concat " " (
    List.mapi (fun j s ->
        (if j = i then "." else "") ^ string_of_symbol s)
      (rhs p))
  ^ (if i = List.length (rhs p) then "." else "")
