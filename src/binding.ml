open Location
open Model
open Printer_tools
open Options

module T = Michelson

type type_kind =
  | Type
  | Init of string

let rec to_type (tk : type_kind) fmt (t : type_) =
  let pp = Format.fprintf fmt in
  let todo        _ = pp "TODO" in
  let unsupported _ = pp "Unsupported" in
  let number      _ = pp "BigNumber" in
  let string      _ = pp "string" in
  let bytes       _ = pp "Bytes" in
  let date        _ = pp "Date" in
  let bool        _ = pp "bool" in
  let self = to_type tk fmt in
  let doit a b =
    match tk with
    | Type -> a ()
    | Init f -> b f
  in
  let id_f = (fun f -> Format.fprintf fmt "%s" f ) in
  match get_ntype t with
  | Tasset _                        -> todo()
  | Tenum _                         -> todo()
  | Tstate                          -> todo()
  | Tbuiltin Bunit                  -> todo()
  | Tbuiltin Bbool                  -> doit bool   id_f
  | Tbuiltin Bint                   -> doit number id_f
  | Tbuiltin Brational              -> doit number (fun f -> Format.fprintf fmt "%s.dividedby(%s)" f f )
  | Tbuiltin Bdate                  -> doit date   (fun f -> Format.fprintf fmt "new Date(%s)" f )
  | Tbuiltin Bduration              -> doit number id_f
  | Tbuiltin Btimestamp             -> doit date   (fun f -> Format.fprintf fmt "new Date(%s)" f )
  | Tbuiltin Bstring                -> doit string id_f
  | Tbuiltin Baddress               -> doit string id_f
  | Tbuiltin Bcurrency              -> doit number id_f
  | Tbuiltin Bsignature             -> doit string id_f
  | Tbuiltin Bkey                   -> doit string id_f
  | Tbuiltin Bkeyhash               -> doit string id_f
  | Tbuiltin Bbytes                 -> doit bytes  id_f
  | Tbuiltin Bnat                   -> doit number id_f
  | Tbuiltin Bchainid               -> doit string id_f
  | Tbuiltin Bbls12_381_fr          -> doit bytes  id_f
  | Tbuiltin Bbls12_381_g1          -> doit bytes  id_f
  | Tbuiltin Bbls12_381_g2          -> doit bytes  id_f
  | Tbuiltin Bnever                 -> unsupported()
  | Tbuiltin Bchest                 -> doit bytes  id_f
  | Tbuiltin Bchest_key             -> doit bytes  id_f
  | Tcontainer _                    -> unsupported()
  | Tlist _ty                       -> todo()
  | Toption ty                      -> self ty
  | Ttuple _tys                     -> todo()
  | Tset _ty                        -> todo()
  | Tmap (false, _kty, _vty)        -> todo()
  | Tmap (true, _kty, _vty)         -> unsupported()
  | Tor (_lty, _rty)                -> todo()
  | Trecord _id                     -> todo()
  | Tevent _id                      -> unsupported()
  | Tlambda (_ity, _rty)            -> todo()
  | Tunit                           -> todo()
  | Tstorage                        -> unsupported()
  | Toperation                      -> unsupported()
  | Tcontract _                     -> unsupported()
  | Tprog _                         -> unsupported()
  | Tvset _                         -> unsupported()
  | Ttrace _                        -> unsupported()
  | Tticket _                       -> unsupported()
  | Tsapling_state _                -> unsupported()
  | Tsapling_transaction _          -> todo()

let compute_type (model : model) (r : record) =
  let kt = mktype (Tbuiltin Bstring) ~annot:(dumloc "%_kind") in
  let mkt = Gen_michelson.to_type model kt in
  let ty = mktype (Tevent r.name) in
  let mty = Gen_michelson.to_type model ty in
  let mty =
    match r.fields with
    | [] -> T.tunit
    | [ f ] -> {mty with annotation = Some ("%" ^ (unloc f.name))}
    | _ -> mty
  in
  let ty = T.mk_type (T.Tpair(mkt, mty)) in
  let t = Michelson.Utils.type_to_micheline ty in
  t

type input_event = {
  r : record;
  ty : T.obj_micheline;
}

let mk_input_event r ty : input_event =
  { r; ty }

let pp_none _fmt _ = ()

let process (l : language) (model : model) : string =

  let pp_language ppjs ppts =
    match l with
    | Javascript -> ppjs
    | Typescript -> ppts
  in

  let pp_prelude fmt _ =
    Format.fprintf fmt
      "/* Bindings %s generated by archetype version: %s */

import { MichelsonType } from '@taquito/michel-codec';
import { registerEvent, WellEvent, WellEventProcessor, hex_to_data } from '@completium/event-well-crank';
import BigNumber from 'bignumber.js';
" (language_to_string l) version
  in

  let pp_event fmt (ie : input_event) =
    let pp_interface fmt _ =
      let pp_field fmt (f : record_field) =
        Format.fprintf fmt "%a : %a" pp_id f.name (to_type Type) f.type_
      in
      Format.fprintf fmt "export interface %a extends WellEvent {@\n  @[%a@]@\n}"
        pp_id ie.r.name
        (pp_list ",@\n" pp_field) ie.r.fields
    in
    let pp_michelson_type fmt =
      Format.fprintf fmt "const michelsonType_%a%a =@\n%a;"
        pp_id ie.r.name
        (pp_language pp_none pp_str) " : MichelsonType"
        Printer_michelson.pp_obj_micheline ie.ty
    in
    let pp_make fmt =
      let pp_field fmt (f : record_field) =
        Format.fprintf fmt "%a : %a" pp_id f.name (to_type (Init ("data." ^ unloc f.name))) f.type_
      in
      Format.fprintf fmt "function make_%a(input%a)%a {
  const data = hex_to_data(michelsonType_%a, input)

  if (data._kind !== '%a') {
    return undefined;
  }
  return { @[%a@] }
}"
        pp_id ie.r.name
        (pp_language pp_none pp_str) " : string"
        (pp_language pp_none pp_str) (" : " ^ (unloc ie.r.name) ^ " | undefined")
        pp_id ie.r.name
        pp_id ie.r.name
        (pp_list ",@\n" pp_field) ie.r.fields
    in
    let pp_register fmt =
      Format.fprintf fmt "export function register_%a(source%a, handler%a) {
  registerEvent({ s: source, c: make_%a, p: handler })
}"
        pp_id ie.r.name
        (pp_language pp_none pp_str) " : string"
        (pp_language pp_none pp_str) (" : WellEventProcessor<" ^ (unloc ie.r.name) ^ ">")
        pp_id ie.r.name
    in
    let pp_newline fmt _ = Format.fprintf fmt "@\n@\n" in

    Format.fprintf fmt "/* Event: %a */" pp_id ie.r.name;
    pp_newline fmt ();
    (pp_language (pp_none fmt) (pp_interface fmt)) ();
    (pp_language (pp_none fmt) (pp_newline fmt)) ();
    pp_michelson_type fmt;
    pp_newline fmt ();
    pp_make fmt;
    pp_newline fmt ();
    pp_register fmt
  in

  let events = List.map (fun (r : record) -> mk_input_event r (compute_type model r)) (Model.Utils.get_events model) in
  Format.asprintf "%a@\n%a@."
    pp_prelude ()
    (pp_list "@\n@\n@\n" pp_event) events
