archetype autocallable

constant issuer : address = @tz1bfVgcJC4ukaQSHUe1EbrUd5SekXeP9CWk
constant owner  : address = @tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg
constant oracle : address = @tz1iawHeddgggn6P5r5jtq2wDRqcJVksGVSa (* exchange *)

constant nominal : tez = 1000tz

constant trade       : date = 2017-03-14T00:00:00
constant init        : date = 2017-03-14T00:00:00
constant issue       : date = 2017-03-28T00:00:00
constant final       : date = 2020-03-16T00:00:00
constant gredemption : date = 2020-03-30T00:00:00

(* UNDERLYINGS *)
constant bac_initial : rational = 25.32
constant sg_initial  : rational = 46.945
constant ubs_initial : rational = 15.98

constant bac_strike : rational = 12.66   (* ~ 0.5 * bac_initial *)
constant sg_strike  : rational = 23.4725 (* ~ 0.5 * sg_initial  *)
constant ubs_strike : rational = 15.98   (* ~ 0.5 * ubs_initial *)

(* CONTRACT DATA *)
asset early identified by eobservation {
  eobservation : date;
  redemption   : date;
  trigger      : rational;
  value        : rational;
} with {
  i1 : 0 <= trigger <= 1;
  i2 : 0 <= value   <= 1;
} initialized by {
  { 2018-03-14T00:00:00; 2018-03-28T00:00:00; 0.95; 1 };
  { 2018-06-14T00:00:00; 2018-06-28T00:00:00; 0.95; 1 };
  { 2018-09-14T00:00:00; 2018-09-28T00:00:00; 0.95; 1 };
  { 2018-12-14T00:00:00; 2019-01-02T00:00:00; 0.95; 1 };
  { 2019-03-14T00:00:00; 2019-03-28T00:00:00; 0.80; 1 };
  { 2019-06-14T00:00:00; 2019-06-28T00:00:00; 0.80; 1 };
  { 2019-09-16T00:00:00; 2020-09-30T00:00:00; 0.70; 1 };
  { 2019-12-16T00:00:00; 2020-01-02T00:00:00; 0.70; 1 };
  { 2020-03-16T00:00:00; 2020-03-30T00:00:00; 0.70; 1 }
}

asset interest identified by iobservation {
  iobservation : date;
  payment     : date;
  barrier     : rational;
  rate        : rational;
} with {
  i3 : 0 <= barrier <= 1;
} initialized by {
  { 2017-06-14T00:00:00; 2017-06-28T00:00:00; 0.5; 2.025  };
  { 2017-09-14T00:00:00; 2017-09-28T00:00:00; 0.5; 4.05   };
  { 2017-12-14T00:00:00; 2018-01-02T00:00:00; 0.5; 6.075  };
  { 2018-03-14T00:00:00; 2018-03-28T00:00:00; 0.5; 8.1    };
  { 2018-06-14T00:00:00; 2018-06-28T00:00:00; 0.5; 10.125 };
  { 2018-09-14T00:00:00; 2018-09-28T00:00:00; 0.5; 12.15  };
  { 2018-12-14T00:00:00; 2019-01-02T00:00:00; 0.5; 14.175 };
  { 2019-03-14T00:00:00; 2019-03-28T00:00:00; 0.5; 16.2   };
  { 2019-06-14T00:00:00; 2019-06-28T00:00:00; 0.5; 18.225 };
  { 2019-09-16T00:00:00; 2019-09-30T00:00:00; 0.5; 20.25  };
  { 2019-12-16T00:00:00; 2020-01-02T00:00:00; 0.5; 22.275 };
  { 2020-03-16T00:00:00; 2020-03-30T00:00:00; 0.5; 24.3   }
}

(* underlyings values *)
asset fixing identified by fobservation {
  fobservation : date;
  bac : rational;  (* Bank of America Corporation *)
  sg  : rational;  (* Societe Generale *)
  ubs : rational;  (* Union des Banques Suisses *)
}

(* EXPECTED PAYMENT COMPUTATION *)

function compute_expected (d : date) : tez {

  effect {
    var expected = 0tz;
    var terminated = false;
    var redeem_date = final;
    (* early redemption *)
    for : redeemloop e in early do
      if early[e].redemption <= d
      then ( (* is there early redemption ? *)
        if     fixing[e].bac >= early[e].trigger * bac_initial
           and fixing[e].sg  >= early[e].trigger * sg_initial
           and fixing[e].ubs >= early[e].trigger * ubs_initial
        then (
           expected += early[e].value * nominal;
           redeem_date := e;
           terminated := true
        ))
    done;
    (* redemption *)
    if not terminated and gredemption <= d
    then
      if     fixing[gredemption].bac >= bac_strike
         and fixing[gredemption].sg  >= sg_strike
         and fixing[gredemption].ubs >= ubs_strike
      then
         expected += nominal
      else (
         var bac_trigger = fixing[gredemption].bac / bac_strike;
         var sg_trigger  = fixing[gredemption].sg  / sg_strike;
         var ubs_trigger = fixing[gredemption].ubs / ubs_strike;
         var worst = min ((min (bac_trigger, sg_trigger)), ubs_trigger);
         expected += worst * nominal
      );
    (* expected interests *)
    var exp_interests = 0tz;
    for : interestloop i in interest do
      if i <= redeem_date and interest[i].payment <= d
      then (
        if     fixing[i].bac >= interest[i].barrier * bac_initial
           and fixing[i].sg  >= interest[i].barrier * sg_initial
           and fixing[i].ubs >= interest[i].barrier * ubs_initial
        then exp_interests := interest[i].rate * nominal
      )
    done;
    expected += exp_interests;
    return expected
  }
}

(* PAYMENT action *)
variable actual_payment : tez = 0tz

entry pay_note () {
   called by issuer
   effect {
      actual_payment += transferred
   }
}

entry add_fixing (ffobservation : date, fbac : rational, fsg : rational, fubs : rational) {
  effect {
    fixing.add({ffobservation; fbac; fsg; fubs})
  }
}

(* STATE MACHINE *)
states =
 | Created initial (** doc initial state. *)
 | Canceled        (** owner or issuer has canceled the transaction. *)
 | Confirmed       (** owner has confirmed. *)
 | Defaulted
 | Terminated

(** Used by owner to confirm transaction. It transfers the price of contract (nominal) *)
transition confirm () {
  called by owner
  from Created
  to Confirmed when { transferred = nominal }
}

transition cancel () {
  called by owner or issuer
  from Created
  to Canceled
}

transition check () {
  called by owner
  from Confirmed
  to Defaulted when { actual_payment < compute_expected(now) }
}

transition terminate () {
  called by issuer
  from Confirmed
  to Terminated when { actual_payment >= compute_expected(now) }
}
