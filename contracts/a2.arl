archetype a2(
  admin  : address = tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg,
  issuer : address = tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg
)

variable users         : big_map<address, nat>      = []

record transferlist {
  unrestricted         : bool;
  allowedTransferlists : set<nat>;
}
variable transferlists : big_map<nat, transferlist> = []

function assertReceiver(addr : address) : bool {
  return
    match users[addr] with
    | some v ->
        match transferlists[v] with
        | some(r) -> r.unrestricted
        | none -> false
        end
    | none   -> false
    end
}

entry assertReceivers (addrs : list<address>) {
  for addr in addrs do
    if (addr <> issuer)
    then do_require(assertReceiver(addr), "USER_RESTRICTED")
  done
}

entry assertTransfers (input_list : list<address * list<address>>) {
  for input_item in input_list do
    var %from = input_item[0];
    var tos   = input_item[1];
    for %to in tos do
      if %from = issuer
      then do_require(assertReceiver(%to), "TO_RESTRICTED")
      else begin
        do_require(assertReceiver(%from), "FROM_RESTRICTED");
        do_require(assertReceiver(%to), "TO_RESTRICTED");
        var fromid       ?= users[%from] : "NOT_FOUND";
        var toid         ?= users[%to] : "NOT_FOUND";
        var tl ?= transferlists[fromid] : "NOT_FOUND";
        do_require(tl.allowedTransferlists.contains(toid), "TO_NOT_ALLOWED")
      end
    done
  done
}

entry assertTransferlist (transferlistId : nat, input : option<transferlist>) {
  match input with
  | some tl -> begin
    do_require(contains(transferlists, transferlistId), "TRANSFERLIST_NOT_FOUND");
    var l ?= transferlists[transferlistId] : "NOT_FOUND";
    do_require(l.unrestricted = tl.unrestricted, "INVALID_UNRESTRICTED_STATE");
    for i in tl.allowedTransferlists do
      do_require(contains(l.allowedTransferlists, i), "IS_NOT_SUBSET")
    done
    end
  | none -> do_fail_if(contains(transferlists, transferlistId), "EXISTS_TRANSFERLIST")
  end
}

entry updateUser (user : address, transferlistId : option<nat>) {
  called by admin
  require {
    r0 : issuer <> user otherwise "ISSUER_NOT_USER"
  }
  effect {
    users.update(user, transferlistId)
  }
}

entry updateTransferlist (
    transferlistId : nat,
    u : option<(bool * list<nat> * set<nat>)>) {
  called by admin
  effect {
    match u with
    | some v -> begin
      var ltransferlist ?= transferlists[transferlistId] : "NOT_FOUND";
      var lunrestricted          = v[0];
      var ldisallowTransferlists = v[1];
      var lallowTransferlists    = v[2];
      ltransferlist.unrestricted := lunrestricted;
      for r in ldisallowTransferlists do
        ltransferlist.allowedTransferlists.remove(r)
      done;
      for a in lallowTransferlists do
        ltransferlist.allowedTransferlists.add(a)
      done;
      transferlists.put(transferlistId, ltransferlist)
      end
    | none -> transferlists.remove(transferlistId)
    end
  }
}

entry setAdmin (value : address) {
  called by admin
  effect {
    admin := value;
  }
}

entry setIssuer (value : address) {
  called by admin
  effect {
    issuer := value;
  }
}

getter getAdmin () : address {
  return admin
}

getter getIssuer () : address {
  return issuer
}

getter getUser (user : address) : option<nat> {
  return users[user]
}
